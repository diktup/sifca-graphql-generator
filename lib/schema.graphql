type FilterNameFieldType {
  id: ID!
  name: String
}

type FilterLabelFieldType {
  id: ID!
  label: String
}

type PictureType {
  baseUrl: String
  path: String
  width: Int
  height: Int
  x: Int
  y: Int
  alt: String
}

type NestedPicturesType {
  cover: PictureType
  profile: PictureType
}

type CountryType {
  id: ID!
  name: String!
  code: String
  dialCode: String
  flagSquare: PictureType
  flagWide: PictureType
  iconFlag: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

# A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
scalar DateTime

type CountryPaginatedType {
  count: Int
  isLast: Boolean
  objects: [CountryType!]!
}

type DeleteResponseDtoType {
  message: String!
  success: Boolean!
}

type StateType {
  id: ID!
  name: String!
  created: DateTime!
  surface: String!
  code: String
  dialCode: String
  flagSquare: PictureType
  flagWide: PictureType
  country: CountryType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatePaginatedType {
  count: Int
  isLast: Boolean
  objects: [StateType!]!
}

type LanguageType {
  id: ID!
  name: String!
  code: String
  flagSquare: PictureType
  flagWide: PictureType
  iconFlag: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LanguagePaginatedType {
  count: Int
  isLast: Boolean
  objects: [LanguageType!]!
}

type SocialImagesImagesSetType {
  size48: PictureType
  size96: PictureType
  size144: PictureType
  size240: PictureType
  size480: PictureType
}

type SocialImagesImagesType {
  svg: SocialImagesImagesSetType
  png: SocialImagesImagesSetType
}

type SocialImagesType {
  style: SocialImageStyleEnum!
  images: [SocialImagesImagesType!]
}

enum SocialImageStyleEnum {
  BUBBLE
  COLOR
  STICKER
  COLOR_HAND_DROWN
}

type SocialType {
  id: ID!
  name: String!
  code: String
  fontIcon: String
  images: [SocialImagesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SocialPaginatedType {
  count: Int
  isLast: Boolean
  objects: [SocialType!]!
}

type PaymentImagesPngType {
  alt: PictureType
  alt2x: PictureType
  alt_128: PictureType
  alt_256: PictureType
  alt_512: PictureType
  card_flat: PictureType
  card_flat2x: PictureType
  card_flat_128: PictureType
  card_flat_256: PictureType
  card_flat_512: PictureType
  dark: PictureType
  dark2x: PictureType
  dark_128: PictureType
  dark_256: PictureType
  dark_512: PictureType
  flat: PictureType
  flat2x: PictureType
  flat_128: PictureType
  flat_256: PictureType
  flat_512: PictureType
  light: PictureType
  light2x: PictureType
  light_128: PictureType
  light_256: PictureType
  light_512: PictureType
  default: PictureType
  default2x: PictureType
  default_128: PictureType
  default_256: PictureType
  default_512: PictureType
}

type PaymentImagesSvgType {
  alt: PictureType
  card_flat: PictureType
  dark: PictureType
  flat: PictureType
  light: PictureType
  default: PictureType
}

type PaymentImagesType {
  svg: PaymentImagesSvgType
  png: PaymentImagesPngType
}

type PaymentType {
  id: ID!
  name: String!
  code: String
  paymentType: PaymentTypeEnum
  materialIcon: String
  images: PaymentImagesType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PaymentTypeEnum {
  CREDIT_CARD
  PAYMENT
  METHODS
}

type PaymentPaginatedType {
  count: Int
  isLast: Boolean
  objects: [PaymentType!]!
}

type GlobalCategoryType {
  id: ID!
  identifier: Int!
  name: String!
  provider: GlobalCategoryProviderEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GlobalCategoryProviderEnum {
  GOOGLE
  FACEBOOK
}

type GlobalCategoryPaginatedType {
  count: Int
  isLast: Boolean
  objects: [GlobalCategoryType!]!
}

type BrowserLogoPngType {
  default: PictureType
  size16: PictureType
  size24: PictureType
  size32: PictureType
  size48: PictureType
  size64: PictureType
  size128: PictureType
  size256: PictureType
  size512: PictureType
}

type BrowserLogoType {
  svg: PictureType
  png: BrowserLogoPngType
  icon: String
}

type BrowserType {
  id: ID!
  name: String
  tags: [String!]
  code: String!
  logo: BrowserLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BrowserPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BrowserType!]!
}

type DeviceBrandLogoPngType {
  default: PictureType
  size16: PictureType
  size24: PictureType
  size32: PictureType
  size48: PictureType
  size64: PictureType
  size128: PictureType
  size256: PictureType
  size512: PictureType
}

type DeviceBrandLogoType {
  svg: PictureType
  png: DeviceBrandLogoPngType
  icon: String
}

type TechDeviceBrandType {
  id: ID!
  name: String!
  code: String
  tags: [String!]
  logo: DeviceBrandLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechDeviceBrandPaginatedType {
  count: Int
  isLast: Boolean
  objects: [TechDeviceBrandType!]!
}

type TechDeviceSpecsType {
  technology: String
  band2g: String
  gprs: String
  edge: String
  announced: String
  status: String
  dimensions: String
  weight: String
  sim: String
  type: String
  size: String
  resolution: String
  cardSlot: String
  phonebook: String
  callRecords: String
  loudspeaker: String
  alertTypes: String
  jack35mm: String
  wlan: String
  bluetooth: String
  gps: String
  radio: String
  usb: String
  sensors: String
  messaging: String
  browser: String
  clock: String
  alarm: String
  games: String
  languages: String
  java: String
  colors: String
}

type TechDeviceType {
  id: ID!
  name: String
  tags: [String!]
  code: String
  picture: PictureType
  releasedat: String
  body: String
  os: String
  storage: String
  displaySize: String
  displayResolution: String
  cameraPixels: String
  videoPixels: String
  ram: String
  chipset: String
  batterySize: String
  batteryType: String
  specifications: TechDeviceSpecsType
  brand: TechDeviceBrandType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechDevicePaginatedType {
  count: Int
  isLast: Boolean
  objects: [TechDeviceType!]!
}

type TechDeviceTypeType {
  id: ID!
  name: String
  tags: [String!]
  nodeName: String
  code: String
  pictureSquare: PictureType
  pictureWide: PictureType
  icon: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechDeviceTypePaginatedType {
  count: Int
  isLast: Boolean
  objects: [TechDeviceTypeType!]!
}

type OSLogoPngType {
  default: PictureType
  size16: PictureType
  size24: PictureType
  size32: PictureType
  size48: PictureType
  size64: PictureType
  size128: PictureType
}

type OSLogoType {
  svg: PictureType
  png: OSLogoPngType
  icon: String
}

type OperatingSystemType {
  id: ID!
  name: String!
  code: String
  tags: [String!]
  slug: String
  logo: OSLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type OperatingSystemPaginatedType {
  count: Int
  isLast: Boolean
  objects: [OperatingSystemType!]!
}

type PluginPicturesType {
  square: PictureType
  wide: PictureType
}

type PluginType {
  id: ID!
  name: String!
  description: String
  code: String
  cost: String
  url: String
  info: String
  category: String
  pictures: PluginPicturesType
  icon: String
  recommended: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PluginPaginatedType {
  count: Int
  isLast: Boolean
  objects: [PluginType!]!
}

type LonLatType {
  type: String
  coordinates: [Float!]
}

type FullAddressOwnerPhoneType {
  number: String
  countryCode: String
}

type FullAddressOwnerType {
  name: String
  phone: FullAddressOwnerPhoneType
}

type FullAddressType {
  owner: FullAddressOwnerType
  address: String
  postCode: String
  city: String
  country: CountryType
  state: StateType
  addressLine: String
  location: LonLatType
}

type BankType {
  id: ID!
  name: String!
  code: String
  bic: String
  address: FullAddressType
  logo: BrowserLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BankType!]!
}

type BankDetailsHolderType {
  name: String!
  type: BankDetailsHolderTypeEnum
  address: FullAddressType!
}

enum BankDetailsHolderTypeEnum {
  PRIVATE
  COMPANY
}

type BankDetailsType {
  id: ID!
  account: String!
  iban: String
  bank: BankType!
  holder: BankDetailsHolderType!
  externalId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankDetailsPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BankDetailsType!]!
}

type ContentTypeImageFormatType {
  png: PictureType
  svg: PictureType
}

type ContentTypeImageType {
  background: ContentTypeImageFormatType
  black: ContentTypeImageFormatType
  white: ContentTypeImageFormatType
  icon: String
}

type ContentTypeType {
  id: ID!
  name: String!
  type: String
  image: ContentTypeImageType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContentTypePaginatedType {
  count: Int
  isLast: Boolean
  objects: [ContentTypeType!]!
}

type CurrencyType {
  id: ID!
  name: String!
  code: String
  symbol: String
  flagSquare: PictureType
  flagWide: PictureType
  iconFlag: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CurrencyPaginatedType {
  count: Int
  isLast: Boolean
  objects: [CurrencyType!]!
}

type SocialValueType {
  name: SocialType
  value: String
}

type TagType {
  name: String
  content: String
}

type DateRangeType {
  min: DateTime
  max: DateTime
}

type PriceRangeType {
  min: String
  max: String
}

type GroupType {
  id: ID!
  name: String!
  description: String
  isVerified: Boolean
  picture: NestedPicturesType
  privacy: GroupPrivacyEnum!
  members: [UserType!]!
  moderators: [UserType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GroupPrivacyEnum {
  PRIVATE
  PUBLIC
}

type MediaType {
  videos: [String!]
  pictures: [PictureType!]
  deg360: [PictureType!]
}

type IPhoneType {
  number: String
  countryCode: String
}

type PhoneType {
  number: String
  countryCode: String
  isValid: Boolean
  validationNumber: Int
}

type CompanyCustomerType {
  phase: CustomerPhaseEnum
  score: String
}

enum CustomerPhaseEnum {
  LEAD
  CUSTOMER
  TERMINATION
}

type CompanySupplierType {
  kind: SupplierTypeEnum
}

enum SupplierTypeEnum {
  WHOLESALER
  MANUFACTURER
  FRANCHISE
}

type CompanyContactDetailsType {
  website: String
  email: String
  phone: PhoneType
}

type CompanyLegalType {
  vat: String
  register: String
  licence: String
}

type CompanyType {
  id: ID!
  name: String
  description: String
  tags: [String!]
  media: MediaType
  address: FullAddressType
  legal: CompanyLegalType
  banks: [BankDetailsType!]
  contact: CompanyContactDetailsType
  customer: CompanyCustomerType
  supplier: CompanySupplierType
  logistic: Boolean
  target: TargetType
  externalId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TargetCurrencyType {
  currency: CurrencyType
  default: Boolean
}

type WholesalerType {
  id: ID!
  name: String
  description: String
  address: FullAddressType
  picture: PictureType
  email: String
  website: String
  phone: IPhoneType
  contactEmails: [String!]
  fax: IPhoneType
  currencies: [TargetCurrencyType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  company: CompanyType
}

type LoyaltyProgramType {
  id: ID!
  programName: String
  picture: PictureType
  company: CompanyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSLoyaltyType {
  loyaltyProgram: LoyaltyProgramType
  from: DateTime!
  to: DateTime!
}

type OpeningHoursDayType {
  day: Days
  from: String
  to: String
}

enum Days {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

type OpeningHoursType {
  status: OpeningStatus
  hours: [OpeningHoursDayType!]
}

enum OpeningStatus {
  ALWAYS_OPEN
  NOT_AVAILABLE
  SELECTED_HOURS
  PERMANENTLY_CLOSED
}

type SpecialOfferType {
  offerType: SpecialOffersType
  hours: [OpeningHoursDayType!]
}

enum SpecialOffersType {
  BAR
  LUNCH
  BRUNCH
  DINNER
  BREAKFAST
  HAPPY_HOUR
}

type POSCategoryType {
  id: ID!
  name: String
  mapPicture: String
  picture: PictureType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSServicesType {
  id: ID
  index: Int
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PointOfSaleType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currencies: [TargetCurrencyType!]
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
}

type ManufacturerType {
  id: ID!
  name: String
  description: String
  picture: PictureType
  externalId: String
  address: FullAddressType
  email: String
  website: String
  contactEmails: [String!]
  currencies: [TargetCurrencyType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  company: CompanyType
}

type StoryContentPositionType {
  left: Float
  right: Float
  top: Float
  bottom: Float
}

type StoryContentDimensionType {
  height: Float
  width: Float
  fontSize: Float
}

type StoryContentContentType {
  content: String
  position: StoryContentPositionType
  dimension: StoryContentDimensionType
  color: String
  contentType: StoriesContentTypeEnum
}

enum StoriesContentTypeEnum {
  GIF
  TEXT
  STICKER
  EMOJI
}

type StoryMediaType {
  picture: PictureType
  video: PictureType
}

type StoriesType {
  id: ID!
  media: StoryMediaType
  seenBy: [UserType!]
  seen: Boolean
  content: [StoryContentContentType!]
  user: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType

  # group
  group: GroupType
}

type StoriesViewsStatusType {
  id: ID!
  seen: Boolean!
  user: String
  pos: String
  group: String
  wholesaler: String
  manufacturer: String
}

type StoriesPaginatedType {
  count: Int
  isLast: Boolean
  objects: [StoriesType!]!
  isAllStoriesSeen: Boolean!
}

type TargetType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType
}

type TargetWithUserType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType

  # user
  user: UserType
}

type TargetFilterType {
  # PointOfSale
  pos: FilterNameFieldType

  # wholesaler
  wholesaler: FilterNameFieldType

  # manufacturer
  manufacturer: FilterNameFieldType
}

type TargetWithGroupType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType

  # user
  user: UserType

  # group
  group: GroupType
}

type TargetWithGroupAndStoriesType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType

  # user
  user: UserType

  # group
  group: GroupType

  # Stories list
  stories: [StoriesType!]

  # is all Stories are seen
  isAllStoriesSeen: Boolean!
}

type TargetsType {
  # list of pointOfSales
  pos: [PointOfSaleType!]

  # list of wholesalers
  wholesaler: [WholesalerType!]

  # list of manufacturers
  manufacturer: [ManufacturerType!]
}

type TargetPaginateType {
  count: Int
  isLast: Boolean
  objects: [TargetType!]!
}

type DiscountDtoType {
  discountType: DiscountType
  amount: String
}

enum DiscountType {
  AMOUNT
  PERCENTAGE
}

type DocumentResultType {
  doc: String
}

type ContentType {
  content: String
}

type MetaItemType {
  name: String
  content: String
  property: String
}

type LinkItemType {
  rel: String
  href: String
  type: String
  sizes: String
}

type ContentJSONType {
  title: String
  description: String
  metas: [MetaItemType!]
  links: [LinkItemType!]
}

type InvoicePDFType {
  content: String
}

type StringListType {
  list: [String!]
}

type PriceCountType {
  price: String
  count: Float
}

type DifferenceInnerType {
  amount: String
  percentage: String
}

type DifferenceType {
  price: DifferenceInnerType
  count: DifferenceInnerType
}

type CurrentPreviousType {
  current: PriceCountType!
  previous: PriceCountType
  difference: DifferenceType
}

type InstallmentType {
  _id: ID!
  amount: String!
  paymentMethod: PaymentType!
  paymentStatus: PaymentStatusEnum!
  user: UserType
  paidAt: DateTime
  deadline: DateTime
}

enum PaymentStatusEnum {
  OPEN
  PAID
  CANCELED
  REFUNDED
  REFUND_REQUESTED
}

type ProductSpecsType {
  key: String
  value: String
}

type KeyValueListType {
  key: String
  value: String
}

type SuccessResponseDtoType {
  message: String!
  success: Boolean!
}

type OoredooDataType {
  id: String
}

type FacebookDataType {
  id: String!
  token: String!
  email: String!
  name: String
  first_name: String
  last_name: String
}

type GoogleDataType {
  sub: String!
  given_name: String
  name: String
  family_name: String
  picture: String
  email: String!
  token: String!
  locale: String
  email_verified: Boolean
}

type AppleDataType {
  email: String
  status: String
  givenName: String
  familyName: String
  identityToken: String!
  userIdentifier: String
  authorizationCode: String
}

type SocialLoginDataType {
  facebook: FacebookDataType
  google: GoogleDataType
  apple: AppleDataType
  ooredoo: OoredooDataType
}

type UserWorkType {
  company: String
  position: String
  description: String
  city: StateType
  tags: [String!]
  from: DateTime
  to: DateTime
  current: Boolean
}

type UserEducationType {
  level: AcademicLevel
  name: String
  description: String
  tags: [String!]
  from: DateTime
  to: DateTime
  graduated: Boolean
}

enum AcademicLevel {
  PRIMARY
  HIGH_SCHOOL
  UNIVERSITY
}

type UserType {
  id: ID!
  email: String
  picture: PictureType
  pictures: [PictureType!]
  covers: [PictureType!]
  roles: [UserRole!]
  username: String
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  apps: [App!]
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [LanguageType!]
  education: [UserEducationType!]
  work: [UserWorkType!]
  lived: [StateType!]
  hobbies: [String!]
  interests: [String!]
  isMailValid: Boolean
  plugged: Boolean
  hasAutoGeneratedEmail: Boolean
  dateOfBirth: DateTime
  phoneNumber: String
  phone: PhoneType
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  socialLoginData: SocialLoginDataType
  nationality: CountryType
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressType!]
  shippingAddress: [FullAddressType!]
  billingAddress: [FullAddressType!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum UserRole {
  API
  ADMIN
  EDITOR
  MANAGER
  CONSUMER
  COMMUNITY
  FINANCIAL
  WAREHOUSE
  COMMERCIAL
  MERCHANDISER
  NOT_SPECIFIED
  GROUP_MODERATOR
  WHOLESALER_OWNER
  WHOLESALER_MANAGER
  MANUFACTURER_OWNER
  WHOLESALER_ASSISTANT
  MANUFACTURER_MANAGER
  MANUFACTURER_ASSISTANT
  SALES
  SYSTEM
  CATALOG
  CONTENT
  LOYALTY
  NETWORK
  CUSTOMERS
  INVENTORY
  ORGANIZATION
  MERCHANDISING
  DASHBOARDS_SALES
  DASHBOARDS_FINANCE
  DASHBOARDS_ANALYTICS
  DASHBOARDS_WAREHOUSE
  DASHBOARDS_MERCHANDISING
  POS_OWNER
  POS_WAITER
  POS_MANAGER
  DELIVERY_MAN
  POS_ASSISTANT
}

enum UserStatus {
  ONLINE
  AWAY
  BUSY
  OFFLINE
}

enum App {
  BOSK
  SKUAD
  FIGAMY
  COCKPIT
  DIKTUP
  MAGARI
  RECOLDA
  SIFCA
}

enum MaritalStatus {
  SINGLE
  MARRIED
  ENGAGED
  WIDOWED
  DIVORCED
  SEPERATED
  IN_RELATIONSHIP
  PREFER_NOT_TO_SAY
}

enum Gender {
  MALE
  FEMALE
  PREFER_NOT_TO_SAY
}

enum MobileThemesEnum {
  DARK
  LIGHT
  SYSTEM
}

enum SourcesEnum {
  FIGAMY
  OOREDOO
}

type UserExistType {
  exist: Boolean!
  user: UserType
}

type VapidKeyType {
  vapidKey: String!
}

type UserStatsType {
  user: UserType!
  allUsers: Int!
  onlineUsers: Int!
}

type IsLoggedInType {
  expired: Boolean!
}

type UserPaginateType {
  count: Int
  isLast: Boolean
  objects: [UserType!]!
}

type MailResponseDto {
  accepted: [String!]!
  rejected: [String!]!
  envelopeTime: Float!
  messageTime: Float!
  messageSize: Float!
  response: String!
  messageId: String!
}

type EmailTemplateType {
  name: EmailTemplateTypeEnum!
  content: String
  icon: String
  color: String
}

enum EmailTemplateTypeEnum {
  STYLE
  WELCOME_USER
  VALIDATE_EMAIL
  FORGOT_PASSWORD
  CONFIRM_PASSWORD
  CONTACT_REQUEST
  DEMO_BOOKING
  EXPORT
  FORM_EXPORT
  INVOICE
  DOCUMENT
  MERGE_ACCOUNTS
  PARTNERSHIP_REFERRAL
  PARTNERSHIP_REQUEST
  POS_CONTACT_REQUEST
  TABLE_GUIDANCE
  SUBSCRIPTION
  PAYMENT_DECLINED
  PAYMENT_CONFIRMED
  ARTICLE_CONFIRMED
  ARTICLE_DELIVERED
  ARTICLE_READY_FOR_PICKUP
  ARTICLE_CANCELED
  PROMOTION
  NEWSLETTER
  BLOG
}

type AuthDashboardAgeType {
  ageRange: String!
  count: Int!
}

type AuthDashboardRoleType {
  role: UserRole!
  count: Int!
}

type AuthDashboardGenderType {
  gender: Gender!
  count: Int!
}

type AuthDashboardUsersByAppsType {
  app: App!
  count: Int!
}

type AuthDashboardMaritalStatusType {
  maritalStatus: MaritalStatus!
  count: Int!
}

type AuthDashboardUsersByRegionType {
  region: CountryEnum!
  count: Int!
}

enum CountryEnum {
  AFGHANISTAN
  ALBANIA
  ALGERIA
  ANDORRA
  ANGOLA
  ANTIGUA_AND_BARBUDA
  ARGENTINA
  ARMENIA
  AUSTRALIA
  AUSTRIA
  AZERBAIJAN
  BAHAMAS
  BAHRAIN
  BANGLADESH
  BARBADOS
  BELARUS
  BELGIUM
  BELIZE
  BENIN
  BHUTAN
  BOLIVIA
  BOSNIA_AND_HERZEGOVINA
  BOTSWANA
  BRAZIL
  BRUNEI
  BULGARIA
  BURKINA_FASO
  BURUNDI
  IVORY_COAST
  CABO_VERDE
  CAMBODIA
  CAMEROON
  CANADA
  CENTRALA_FRICAN_REPUBLIC
  CHAD
  CHILE
  CHINA
  COLOMBIA
  COMOROS
  CONGO_BRAZZAVILLE
  COSTA_RICA
  CROATIA
  CUBA
  CYPRUS
  CZECH_REPUBLIC
  DEMOCRATIC_REPUBLIC_OF_THE_CONGO
  DENMARK
  DJIBOUTI
  DOMINICA
  DOMINICAN_REPUBLIC
  ECUADOR
  EGYPT
  EL_SALVADOR
  EQUATORIAL_GUINEA
  ERITREA
  ESTONIA
  ESWATINI
  ETHIOPIA
  FIJI
  FINLAND
  FRANCE
  GABON
  GAMBIA
  GEORGIA
  GERMANY
  GHANA
  GREECE
  GRENADA
  GUATEMALA
  GUINEA
  GUINEA_BISSAU
  GUYANA
  HAITI
  HOLY_SEE
  HONDURAS
  HUNGARY
  ICELAND
  INDIA
  INDONESIA
  IRAN
  IRAQ
  IRELAND
  ISRAEL
  ITALY
  JAMAICA
  JAPAN
  JORDAN
  KAZAKHSTAN
  KENYA
  KIRIBATI
  KUWAIT
  KYRGYZSTAN
  LAOS
  LATVIA
  LEBANON
  LESOTHO
  LIBERIA
  LIBYA
  LIECHTENSTEIN
  LITHUANIA
  LUXEMBOURG
  MADAGASCAR
  MALAWI
  MALAYSIA
  MALDIVES
  MALI
  MALTA
  MARSHALL_ISLANDS
  MAURITANIA
  MAURITIUS
  MEXICO
  MICRONESIA
  MOLDOVA
  MONACO
  MONGOLIA
  MONTENEGRO
  MOROCCO
  MOZAMBIQUE
  MYANMAR
  NAMIBIA
  NAURU
  NEPAL
  NETHERLANDS
  NEW_ZEALAND
  NICARAGUA
  NIGER
  NIGERIA
  NORTH_KOREA
  NORTH_MACEDONIA
  NORWAY
  OMAN
  PAKISTAN
  PALAU
  PALESTINE_STATE
  PANAMA
  PAPUA_NEW_GUINEA
  PARAGUAY
  PERU
  PHILIPPINES
  POLAND
  PORTUGAL
  QATAR
  ROMANIA
  RUSSIA
  RWANDA
  SAINT_KITTS_AND_NEVIS
  SAINT_LUCIA
  SAINT_VINCENT_AND_THE_GRENADINES
  SAMOA
  SAN_MARINO
  SAO_TOME_AND_PRINCIPE
  SAUDI_ARABIA
  SENEGAL
  SERBIA
  SEYCHELLES
  SIERRA_LEONE
  SINGAPORE
  SLOVAKIA
  SLOVENIA
  SOLOMON_ISLANDS
  SOMALIA
  SOUTH_AFRICA
  SOUTH_KOREA
  SOUTH_SUDAN
  SPAIN
  SRI_LANKA
  SUDAN
  SURINAME
  SWEDEN
  SWITZERLAND
  SYRIA
  TAJIKISTAN
  TANZANIA
  THAILAND
  TIMOR_LESTE
  TOGO
  TONGA
  TRINIDAD_AND_TOBAGO
  TUNISIA
  TURKEY
  TURKMENISTAN
  TUVALU
  UGANDA
  UKRAINE
  UNITED_ARAB_EMIRATES
  UNITED_KINGDOM
  UNITED_STATES_OF_AMERICA
  URUGUAY
  UZBEKISTAN
  VANUATU
  VENEZUELA
  VIETNAM
  YEMEN
  ZAMBIA
  ZIMBABWE
  NOT_SPECIFIED
}

type AuthDashboardMailValidationType {
  isMailValid: Boolean!
  count: Int!
}

type AuthDashboardType {
  gender: [AuthDashboardGenderType!]!
  maritalStatus: [AuthDashboardMaritalStatusType!]!
  usersByRegion: [AuthDashboardUsersByRegionType!]!
  mailValidation: [AuthDashboardMailValidationType!]!
  roles: [AuthDashboardRoleType!]!
  usersByApp: [AuthDashboardUsersByAppsType!]!
  age: [AuthDashboardAgeType!]!
}

type AuthDashboardAgeByAppType {
  ageRange: String!
  count: Int!
  app: App!
}

type AuthDashboardRoleByAppType {
  role: UserRole!
  count: Int!
  app: App!
}

type AuthDashboardGenderByAppType {
  gender: Gender!
  count: Int!
  app: App!
}

type AuthDashboardMaritalStatusByAppType {
  maritalStatus: MaritalStatus!
  count: Int!
  app: App!
}

type AuthDashboardUsersByRegionByAppType {
  region: CountryEnum!
  count: Int!
  app: App!
}

type AuthDashboardMailValidationByAppType {
  isMailValid: Boolean!
  count: Int!
  app: App!
}

type AuthDashboardByAppType {
  gender: [AuthDashboardGenderByAppType!]!
  maritalStatus: [AuthDashboardMaritalStatusByAppType!]!
  usersByRegion: [AuthDashboardUsersByRegionByAppType!]!
  mailValidation: [AuthDashboardMailValidationByAppType!]!
  roles: [AuthDashboardRoleByAppType!]!
  usersByApp: [AuthDashboardUsersByAppsType!]!
  age: [AuthDashboardAgeByAppType!]!
}

type OnlineUsersByDeviceTypeType {
  deviceType: DeviceTypeEnum!
  onlineUsers: Int!
}

enum DeviceTypeEnum {
  TV
  TABLET
  CAMERA
  NO_DATA
  DESKTOP
  CONSOLE
  PHABLET
  WEARABLE
  SMARTPHONE
  PERIPHERAL
  CAR_BROWSER
  FEATURE_PHONE
  SMART_DISPLAY
  SMART_SPEAKER
  PORTABLE_MEDIA_PLAYER
}

type AuthDashboardPreviewByAppType {
  totalUsers: Int!
  onlineUsers: Int!
  onlineUsersByDeviceType: [OnlineUsersByDeviceTypeType!]!
}

type GetCockPitDashboardAnalyticsByAppType {
  totalUsers: Int!
  onlineUsers: Int!
}

type DailyCountType {
  total: Int!
  date: String!
}

type DurationsCountType {
  count: Int
  duration: Float
}

type GetCockPitDashboardUserAnalyticsByAppType {
  currentNewUsersCount: Int!
  previousNewUsersCount: Int!
  currentActiveUsersCount: Int!
  previousActiveUsersCount: Int!
  currentReturningUsersCount: Int!
  previousReturningUsersCount: Int!
  dailyNewUsersCount: [DailyCountType!]
  dailyActiveUsersCount: [DailyCountType!]
  dailyReturningUsersCount: [DailyCountType!]
}

type ClientDataType {
  name: String
  engine: String
  family: String
  version: String
  clientType: String
  engineVersion: String
  type: String
}

type OperatingSystemDataType {
  name: String
  version: String
  brand: String
  model: String
}

type MachineDataType {
  id: String
  deviceType: String
  brand: String
  model: String
}

type IosDataType {
  name: String
  model: String
  systemName: String
  systemVersion: String
  localizedModel: String
  utsnameMachine: String
  utsnameRelease: String
  utsnameSysname: String
  utsnameVersion: String
  utsnameNodename: String
  isPhysicalDevice: String
  identifierForVendor: String
}

type AndroidDataType {
  id: String
  host: String
  tags: String
  deviceType: String
  board: String
  brand: String
  model: String
  device: String
  display: String
  product: String
  hardware: String
  androidId: String
  bootloader: String
  fingerprint: String
  manufacturer: String
  versionBaseOS: String
  versionSdkInt: String
  versionRelease: String
  supportedAbis: [String!]
  versionCodename: String
  systemFeatures: [String!]
  isPhysicalDevice: String
  versionIncremental: String
  versionPreviewSdkInt: String
  versionSecurityPatch: String
  supported32BitAbis: [String!]
  supported64BitAbis: [String!]
}

type DeviceDataType {
  iosData: IosDataType!
  androidData: AndroidDataType!
  os: OperatingSystemDataType!
  client: ClientDataType!
  device: MachineDataType!
}

type LoginType {
  accessToken: String!
  expiresIn: Float!
  user: UserType!
}

type UserAuthenticationType {
  actionType: ActionTypeEnum!
  user: UserType!
}

enum ActionTypeEnum {
  LOGIN
  REGISTER
  APPLE_LOGIN
  GOOGLE_LOGIN
  LOGIN_FOR_APP
  FACEBOOK_LOGIN
  REGISTER_FOR_APP
}

type FormOwnerDtoType {
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type JockerType {
  id: ID!
  title: String
  description: String
  icon: String
  cost: Int
  kind: JockerKindEnum
  media: MediaType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum JockerKindEnum {
  ADD_10_SEC
  ELIMINATE_2_SUGGESTIONS
  SHOW_USERS_PERCENTAGE
}

type PredefinedActionType {
  enable: Boolean
  action: PredefinedActionsEnum
}

enum PredefinedActionsEnum {
  COMPLETE_PROFILE
  ADD_WISHLIST
  REGISTER
  LOGIN
  NEWSLETTER
  SIGNUP
  PRODUCT_RATING
  PRODUCT_REVIEW
  SHARE_PRODUCT_FACEBOOK
  SHARE_BLOG_FACEBOOK
}

type ActivityTypeType {
  id: ID!
  title: String
  description: String
  icon: String
  theme: String
  media: MediaType
  predefined: PredefinedActionType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActivityTypePaginateType {
  count: Int
  isLast: Boolean
  objects: [ActivityTypeType!]!
}

type ChallengeTypeTypeJocker {
  jocker: JockerType
  cost: String
}

type ChallengeTypeType {
  id: ID!
  title: String
  description: String
  rules: String
  icon: String
  media: MediaType
  minStep: Int
  minCheckPoints: Int
  minGiftValue: String

  # In days.
  claimReward: Int
  activityTypes: [ActivityTypeType!]
  jockers: [ChallengeTypeTypeJocker!]
  fees: String
  enable: Boolean
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PerksType {
  discount: String!
  description: String
}

type LevelIntervalType {
  min: Int
  max: Int
}

type ReputationType {
  id: ID!
  reputationLevel: String
  lossAmount: Int!
  rank: Int!
  target: TargetType!
  picture: PictureType
  levelInterval: LevelIntervalType
  inactivityCycle: Int!
  nextLevelMax: Int
  perks: PerksType
  color: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReputationWithoutTargetType {
  id: ID!
  reputationLevel: String
  lossAmount: Int!
  rank: Int!
  picture: PictureType
  levelInterval: LevelIntervalType
  inactivityCycle: Int!
  nextLevelMax: Int
  perks: PerksType
  color: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReputationPaginateType {
  count: Int
  isLast: Boolean
  objects: [ReputationType!]!
}

type AudienceCriteriaFieldType {
  field: AudienceCriteriaFieldEnum
  operators: [OperatorEnum!]
}

enum AudienceCriteriaFieldEnum {
  AGE
  STATE
  GENDER
  COUNTRY
  HOBBIES
  LANGUAGE
  LOCATION
  EDUCATION
  INTERESTS
  JOIN_DATE
  OCCUPATION
  MARITAL_STATUS
  REPUTATION_LEVEL
  QUANTITATIVE_CURRENT
  QUANTITATIVE_OVERALL
}

enum OperatorEnum {
  EQUAL
  GREATER
  BETWEEN
  DIFFERENT
  NOT_BETWEEN
  INCLUDED_IN
  AT_LEAST_ONE
  NOT_SPECIFIED
  NOT_INCLUDED_IN
}

type AudienceCriteriaType {
  id: ID!
  title: String
  description: String
  icon: String
  style: String
  enable: Boolean
  media: MediaType
  fields: [AudienceCriteriaFieldType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AudienceCriteriaPaginateType {
  count: Int
  isLast: Boolean
  objects: [AudienceCriteriaType!]!
}

type DeliveryZonePathType {
  lng: Float!
  lat: Float!
  order: Float!
}

type DeliveryZonesType {
  id: ID!
  target: TargetType!
  radius: Float
  order: Float
  minPrice: String
  extraFees: String
  color: String
  type: ZoneTypesEnum!
  paths: [DeliveryZonePathType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ZoneTypesEnum {
  Point
  Polygon
}

type QuestActionDefinitionDefinitionTextBoxType {
  min: Int
  max: Int
}

type QuestActionDefinitionDefinitionRatingType {
  max: Int
  text: Boolean
}

type QuestActionDefinitionDefinitionCalculatedValuesType {
  minValue: Int
  maxValue: Int
  score: Boolean
}

type QuestActionDefinitionDefinitionCalculatedType {
  output: CalculatedOutputEnum
  show: Boolean
  formula: String
  values: [QuestActionDefinitionDefinitionCalculatedValuesType!]
}

enum CalculatedOutputEnum {
  NUMBER
  TEXT
}

type QuestActionDefinitionDefinitionDateType {
  outdated: Boolean
  interval: Boolean
}

type QuestActionDefinitionDefinitionContactType {
  firstname: Boolean
  lastname: Boolean
  email: Boolean
  phone: Boolean
  description: Boolean
  address: Boolean
  birthday: Boolean
  gender: Boolean
  civility: Boolean
  profession: Boolean
  academicLevel: Boolean
  language: Boolean
}

type QuestActionDefinitionDefinitionNumberType {
  minValue: Int
  maxValue: Int
  interval: Boolean
}

type QuestActionDefinitionDefinitionApiParamsType {
  name: String
  type: String
}

type QuestActionDefinitionDefinitionApiType {
  link: Int
  method: ApiMethods
  auth: String
  secret: String
  params: [QuestActionDefinitionDefinitionApiParamsType!]
}

enum ApiMethods {
  GET
  POST
}

type QuestActionDefinitionDefinitionMatrixType {
  lines: String
  columns: String
}

type QuestActionDefinitionDefinitionToggleType {
  leftLabel: String
  rightLabel: String
}

type QuestActionDefinitionDefinitionChoicesType {
  maxResponses: Float
  personalised: Boolean
  unique: Boolean
  random: Boolean
  leaderboard: Boolean
  api: Boolean
  image: Boolean
  interaction: Boolean
  suggestions: QuestionDtoType
}

type QuestActionDefinitionDefinitionSmileyType {
  levels: Int
}

type QuestActionDefinitionDefinitionScoreType {
  min: Int
}

type QuestActionDefinitionDefinitionLeadType {
  url: String
  image: String
}

type QuestActionDefinitionDefinitionVerificationItemContentType {
  rank: Int
}

type QuestActionDefinitionDefinitionVerificationItemType {
  verification: QuestActionDefinitionDefinitionVerificationItemContentType
  verified: QuestActionDefinitionDefinitionVerificationItemContentType
}

type QuestActionDefinitionDefinitionVerificationType {
  number: QuestActionDefinitionDefinitionVerificationItemType
  email: QuestActionDefinitionDefinitionVerificationItemType
}

type QuestActionDefinitionDefinitionVideoType {
  minSeconds: Int
}

type QuestActionDefinitionDefinitionSocialMediaType {
  socialMedia: SocialType
  action: SocialActionEnum
  socialContent: SocialContentTypeEnum
  url: String
}

enum SocialActionEnum {
  SHARE
  LIKE
}

enum SocialContentTypeEnum {
  PAGE
  PROFILE
  POST
  VIDEO
  STORY
  REEL
}

type QuestActionDefinitionDefinitionAppDownloadType {
  playstore: String
  appstore: String
  appgallery: String
}

type QuestActionDefinitionDefinitionType {
  textBox: QuestActionDefinitionDefinitionTextBoxType
  rating: QuestActionDefinitionDefinitionRatingType
  calculated: QuestActionDefinitionDefinitionCalculatedType
  date: QuestActionDefinitionDefinitionDateType
  contact: QuestActionDefinitionDefinitionContactType
  number: QuestActionDefinitionDefinitionNumberType
  api: QuestActionDefinitionDefinitionApiType
  matrix: QuestActionDefinitionDefinitionMatrixType
  toggle: QuestActionDefinitionDefinitionToggleType
  choices: QuestActionDefinitionDefinitionChoicesType
  smiley: QuestActionDefinitionDefinitionSmileyType
  score: QuestActionDefinitionDefinitionScoreType
  lead: QuestActionDefinitionDefinitionLeadType
  verification: QuestActionDefinitionDefinitionVerificationType
  video: QuestActionDefinitionDefinitionVideoType
  socialMedia: QuestActionDefinitionDefinitionSocialMediaType
  appDownload: QuestActionDefinitionDefinitionAppDownloadType
}

type QuestActionDefinitionType {
  id: ID!
  activityType: ActivityTypeType
  required: Boolean
  definition: QuestActionDefinitionDefinitionType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestActionDefinitionPaginateType {
  count: Int
  isLast: Boolean
  objects: [QuestActionDefinitionType!]!
}

type AudienceReachType {
  reach: Int
  total: Int
}

type AudienceSegmentFilterZoneType {
  radius: Float
  type: ZoneTypesEnum
  paths: [DeliveryZonePathType!]
}

type AudienceSegmentFilterValuesType {
  startDate: DateTime
  endDate: DateTime
  minValue: String
  maxValue: String
  value: String
  values: [String!]
  zone: AudienceSegmentFilterZoneType
  languages: [LanguageType!]
  reputations: [ReputationType!]
  countries: [CountryType!]
  states: [StateType!]
}

type AudienceSegmentFilterFieldType {
  value: AudienceCriteriaFieldEnum
  action: QuestActionDefinitionType
}

type AudienceSegmentFilterType {
  field: AudienceSegmentFilterFieldType
  operator: OperatorEnum
  values: [AudienceSegmentFilterValuesType!]
}

type AudienceSegmentType {
  rank: Int
  criteria: AudienceCriteriaType
  filters: [AudienceSegmentFilterType!]
}

type AudienceType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  segments: [AudienceSegmentType!]
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AudienceWithReachType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  segments: [AudienceSegmentType!]
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
  reach: AudienceReachType!
}

type AudiencePaginateType {
  count: Int
  isLast: Boolean
  objects: [AudienceType!]!
}

type AudienceReachPaginateType {
  count: Int
  isLast: Boolean
  objects: [AudienceWithReachType!]!
}

type ChallengeTypeWinner {
  rank: Int!
  reward: Float
}

type ChallengeTypeCheckpoint {
  checkpoint: Int
  amount: Float
}

type ChallengeType {
  id: ID!
  title: String
  description: String
  media: MediaType
  creator: UserType
  challengeType: ChallengeTypeType
  startDate: DateTime
  endDate: DateTime
  status: ChallengeStatusEnum
  winners: [ChallengeTypeWinner!]
  checkpoints: [ChallengeTypeCheckpoint!]
  maxAnswers: Int
  audience: AudienceType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ChallengeStatusEnum {
  DRAFT
  ONGOING
  FINISHED
}

type ChallengeStepType {
  id: ID!
  title: String
  description: String
  media: MediaType
  startDate: DateTime
  endDate: DateTime
  rank: Int
  randomize: Boolean
  challenge: ChallengeType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestionChoiceDtoType {
  item: String!
  enable: Boolean
}

type QuestionDtoType {
  id: ID!
  mandatory: Boolean
  title: String
  description: String
  choices: [QuestionChoiceDtoType!]!
  order: Int
  type: QuestionTypeEnum
  challengeStep: ChallengeStepType
  score: Boolean
  points: Int
  duration: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum QuestionTypeEnum {
  SHORT_ANSWER
  PARAGRAPH
  MULTIPLE_CHOICE
  CHECKBOXES
  DROPDOWN
  PICTURE
  DATE
  TIME
}

type FormResponseType {
  id: ID!
  title: String!
  description: String!
  questions: [QuestionDtoType!]!
  owner: FormOwnerDtoType!
  type: FormType!
  status: FormStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum FormType {
  GUIDED
  AUTONOMOUS
}

enum FormStatus {
  DRAFT
  CHECKED
  ONGOING
  FINISHED
}

type AnswerDtoType {
  count: Int!
  answers: [String!]!
}

type TargetDtoType {
  pos: PointOfSaleType
  user: UserType
}

type ResponseDtoType {
  id: ID!
  target: TargetDtoType!
  executor: UserType!
  question: QuestionDtoType!
  answers: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SingleAnswerDtoType {
  count: Int!
  answer: String!
}

type AccessLoggerClientDataType {
  name: String
  engine: String
  family: String
  version: String
  clientType: String
  engineVersion: String
  type: String
}

type AccessLoggerOperatingSystemDataType {
  name: String
  version: String
  brand: String
  model: String
}

type AccessLoggerMachineDataType {
  id: String
  deviceType: String
  brand: String
  model: String
}

type AccessLoggerIosDataType {
  name: String
  model: String
  systemName: String
  systemVersion: String
  localizedModel: String
  utsnameMachine: String
  utsnameRelease: String
  utsnameSysname: String
  utsnameVersion: String
  utsnameNodename: String
  isPhysicalDevice: String
  identifierForVendor: String
}

type AccessLoggerAndroidDataType {
  id: String
  host: String
  tags: String
  deviceType: String
  board: String
  brand: String
  model: String
  device: String
  display: String
  product: String
  hardware: String
  androidId: String
  bootloader: String
  fingerprint: String
  manufacturer: String
  versionBaseOS: String
  versionSdkInt: String
  versionRelease: String
  supportedAbis: [String!]
  versionCodename: String
  systemFeatures: [String!]
  isPhysicalDevice: String
  versionIncremental: String
  versionPreviewSdkInt: String
  versionSecurityPatch: String
  supported32BitAbis: [String!]
  supported64BitAbis: [String!]
}

type AccessLoggerDeviceDataType {
  iosData: AccessLoggerIosDataType!
  androidData: AccessLoggerAndroidDataType!
  os: AccessLoggerOperatingSystemDataType!
  client: AccessLoggerClientDataType!
  device: AccessLoggerMachineDataType!
}

type AccessLoggerRequestType {
  host: String
  port: String
  token: String
  origin: String
  hostname: String
  pathname: String
  protocol: String
  variables: String
  url: String!
  query: String!
  operationName: String!
}

type ReduciblePriceType {
  beforeReduction: String
  afterReduction: String
}

type PriceCreditType {
  amount: String
  periodValue: Int
  periodCycle: RecurrenceType
}

enum RecurrenceType {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

type PriceFullType {
  net: ReduciblePriceType
  gross: ReduciblePriceType
}

type TaxValueType {
  unit: String
  total: String
}

type LocationType {
  id: ID!
  name: String
  externalId: String
  media: MediaType
  tags: [String!]
  company: CompanyType
  address: FullAddressType
  locationType: LocationTypeEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LocationTypeEnum {
  OFFICE
  STORAGE
  FACTORY
  WAREHOUSE
}

type LocationPaginateType {
  count: Int
  isLast: Boolean
  objects: [LocationType!]!
}

type WarehouseType {
  id: ID!
  name: String
  media: MediaType
  tags: [String!]
  location: LocationType
  totalSurface: Float
  nonStorageSurface: Float
  externalId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WarehousePaginateType {
  count: Int
  isLast: Boolean
  objects: [WarehouseType!]!
}

type StockPixelType {
  quantityToSellOnFacebook: Int
}

type StockRawType {
  id: ID!
  stockCapacity: Int!
  currentStock: Int!
  stockPercentage: String!
  minimumStockQuantity: Int!
  pixel: StockPixelType
  outOfStock: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StockType {
  id: ID!
  stockCapacity: Int!
  currentStock: Int!
  stockPercentage: String!
  minimumStockQuantity: Int!
  pixel: StockPixelType
  outOfStock: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  barcode: BarcodeType!
  target: TargetType!
  warehouse: WarehouseType
}

type StockPaginateType {
  count: Int
  isLast: Boolean
  objects: [StockType!]!
}

type MetaKeywordsType {
  name: String
  content: String
}

type CatalogueCategorySeoType {
  urlKey: String
  metaTitle: String
  metaDesription: String
  metaKeywords: [MetaKeywordsType!]
}

type CatalogueCategoryBaseType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProductVarietyEnum {
  PRODUCT
  EQUIPMENT
  SERVICE
  VEHICULE
}

type CatalogueCategoryType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type CatalogueCategoryWithChildrenType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  children: [CatalogueCategoryWithChildrenType!]
}

type BrandType {
  id: ID
  name: String
  picture: PictureType
  externalId: String
  website: String
  target: TargetType
  manufacturer: ManufacturerType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TaxVaType {
  sign: TaxSignEnum!
  value: String
  type: DiscountType!
}

enum TaxSignEnum {
  POSITIVE
  NEGATIVE
}

type TaxType {
  id: ID!
  label: String
  externalId: String
  value: TaxVaType
  use: [TaxUseEnum!]
  product: Boolean
  company: CompanyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TaxUseEnum {
  SALE
  PURCHASE
}

type TaxPaginateType {
  count: Int
  isLast: Boolean
  objects: [TaxType!]!
}

type PriceType {
  id: ID!
  label: String
  enable: Boolean
  company: CompanyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PricePaginateType {
  count: Int
  isLast: Boolean
  objects: [PriceType!]!
}

type AttributeValueBaseType {
  id: ID!
  label: String!
  externalId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AttributeValueBaseRawType {
  id: ID!
  label: String!
  externalId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  attribute: AttributeBaseType!
}

type AttributeValueType {
  id: ID!
  label: String!
  externalId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  attribute: AttributeType!
}

type AttributeValueFilterType {
  id: ID!
  label: String!
  attribute: AttributeRawBaseType!
}

type AttributeValuePaginateType {
  count: Int
  isLast: Boolean
  objects: [AttributeValueType!]!
}

type AttributePixelType {
  pixelAttribute: String
}

type AttributeRawBaseType {
  id: ID!
  label: String!
}

type AttributeBaseType {
  id: ID!
  label: String!
  externalId: String!
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelType
  variety: ProductVarietyEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AttributeWithValueFilterType {
  id: ID!
  label: String
  attributeValues: [FilterLabelFieldType!]
}

type AttributeType {
  id: ID!
  label: String!
  externalId: String!
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelType
  variety: ProductVarietyEnum
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType
}

type AttributePaginateType {
  count: Int
  isLast: Boolean
  objects: [AttributeType!]!
}

type ProductAttributeType {
  id: ID!
  attribute: AttributeType!
  isRequired: Boolean!
  isMultipleChoice: Boolean!
  possibleValues: [String!]!
  reference: String!
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductAttributePaginateType {
  count: Int
  isLast: Boolean
  objects: [ProductAttributeType!]!
}

type InventoryCategoryType {
  id: ID!
  name: String!
  picture: PictureType
  layer: Int!
  rank: Int!
  hasChildren: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductPriceListType {
  price: PriceType
  value: String
}

type ProductTaxesType {
  tax: TaxType
  rank: Int
}

type ProductType {
  id: ID
  name: String
  externalId: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  tags: [String!]
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  ean: String
  weight: Float
  price: String
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  wholesalerPrice: String
  factoryPrice: String
  tax: String
  taxes: [ProductTaxesType!]
  productAttributes: [ProductAttributeType!]

  # list of barcodes
  barcodes: [BarcodeType!]
  brand: BrandType
  category: [InventoryCategoryType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProductClassEnum {
  TOP_PRODUCTS
  FEATURED_PRODUCTS
  NEW_ARRIVALS
  BEST_SELLERS
}

enum ProductStructureEnum {
  STOCKABLE
  CONSUMABLE
  SERVICE
}

type InternalProductAttributeInnerType {
  selectedValue: String
  price: String
  productAttribute: ProductAttributeType
}

type InternalProductAttributeType {
  attributes: [InternalProductAttributeInnerType!]
}

type InternalProductAttributesValuesBaseType {
  attributesValues: [AttributeValueBaseRawType!]
}

type InternalProductAttributesValuesType {
  attributesValues: [AttributeValueType!]
}

type InternalProductAttributesValuesFilterType {
  attributesValues: [AttributeValueFilterType!]
}

type InternalProductMaintenanceType {
  active: Boolean
  owner: UserType
  technician: UserType
  prevMaintenanceDuration: Int
  maintenanceDuration: Int
  expectedMeantime: Int
}

type GlobalCategoryProductType {
  googleCategory: GlobalCategoryType
  facebookCategory: GlobalCategoryType
}

type InternalProductType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
}

enum ProductConditionEnum {
  NEW
  REFURBISHED
  USED
}

enum ProductStatusEnum {
  ACTIVE
  ARCHIVED
}

type InternalProductWithStockType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  stock: StockRawType
}

type InternalProductWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  isFavorite: Boolean
  barcodes: [BarcodeWithPublicPriceType!]
}

type RecentlyViewedInternalProductWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  isFavorite: Boolean
}

type InternalProductWithBarcodesWithPublicPriceType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeWithPublicPriceType!]
}

type InternalProductWithoutClassType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  internalProductAttributes: InternalProductAttributeType
  barcodes: [BarcodeType!]
  ratings: String
}

type InternalProductByClassType {
  BEST_SELLERS: [InternalProductWithoutClassType!]
  NEW_ARRIVALS: [InternalProductWithoutClassType!]
  TOP_PRODUCTS: [InternalProductWithoutClassType!]
  FEATURED_PRODUCTS: [InternalProductWithoutClassType!]
}

type InternalProductWithoutClassWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  internalProductAttributes: InternalProductAttributeType
  barcodes: [BarcodeType!]
  ratings: String
  isFavorite: Boolean
}

type InternalProductByClassTypeWithFavoriteStatus {
  BEST_SELLERS: [InternalProductWithoutClassWithFavoriteStatusType!]
  NEW_ARRIVALS: [InternalProductWithoutClassWithFavoriteStatusType!]
  TOP_PRODUCTS: [InternalProductWithoutClassWithFavoriteStatusType!]
  FEATURED_PRODUCTS: [InternalProductWithoutClassWithFavoriteStatusType!]
}

type InternalProductWithRatingsType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  catalogueCategory: [CatalogueCategoryType!]
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  target: TargetFilterType!
  ratings: String
}

type InternalProductWithRatingsWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  catalogueCategory: [CatalogueCategoryType!]
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  target: TargetFilterType!
  ratings: String
  isFavorite: Boolean
  barcodes: [BarcodeWithPublicPriceType!]
}

type BarcodePeriodCreditType {
  periodCycle: RecurrenceType!
  periodValue: Int!
  amount: String
}

type PixelBarcodeType {
  include: Boolean
}

type BarcodeBaseRawType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  productAttributesValues: InternalProductAttributesValuesBaseType
}

type BarcodeType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
}

type BarcodeWithPublicPriceType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
  publicPrice: String
}

type BarcodeWithStockDataType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
  currentStock: Int
  outOfStock: Boolean
}

type BarcodeWithStockType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
  stock: StockRawType
}

type BarcodeForTargetType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  productAttributesValues: InternalProductAttributesValuesType
}

type BarcodePaginateType {
  count: Int
  isLast: Boolean
  objects: [BarcodeType!]!
}

type BarcodeWithStockPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BarcodeWithStockType!]!
}

type BarcodeWithStockDataPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BarcodeWithStockDataType!]!
}

type ProductPriceType {
  unitNet: String
  unitGross: String
  net: String
  gross: String
}

type OrderShoppingCartProductType {
  name: String
  target: TargetType
  taxValue: TaxValueType!
  price: ProductPriceType!
  deliveryMan: UserType
  quantity: Int!
  pickupTime: DateTime
  barcode: BarcodeType!
  orderProductStatus: OrderStatus!
}

enum OrderStatus {
  OPEN
  CONFIRMED
  ASSIGNED
  READY_FOR_PICKUP
  DELIVERED
  CANCELED
}

type MarketPlaceOrderShoppingCartType {
  target: TargetType
  products: [OrderShoppingCartProductType!]
  taxValue: ReduciblePriceType
  deliveryFees: String
  price: PriceFullType
  discount: DiscountDtoType
}

type MarketPlaceOrderDtoType {
  id: ID!
  number: String!
  user: UserType
  notes: String
  orderType: OrderTypeEnum
  installments: [InstallmentType!]
  deliveryFees: String
  deliveryAddress: FullAddressType
  hasInvoice: Boolean
  shoppingCart: MarketPlaceOrderShoppingCartType!
  orderTime: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum OrderTypeEnum {
  ORDER_AHEAD
  PICKUP
  DELIVERY
  IN_HOUSE
}

type MarketPlaceOrderWithLoginType {
  user: UserType!
  accessToken: String!
  expiresIn: Float!
  order: MarketPlaceOrderDtoType!
}

type RemunerationDtoType {
  pocketType: PocketTypeEnum
  amount: String
}

enum PocketTypeEnum {
  QUANTITATIVE
  QUALITATIVE
}

type RemunerationWithReputationDtoType {
  qualitativeAmount: String!
  quantitativeAmount: String!
  reputationLevel: ReputationType
}

type QuestActionsRecurrenceType {
  enable: Boolean
  cycle: Int
}

type QuestType {
  id: ID!
  title: String
  description: String
  media: MediaType
  category: QuestCategoryEnum
  status: QuestStatusEnum
  recurrence: QuestActionsRecurrenceType
  remuneration: [RemunerationDtoType!]
  activityType: ActivityTypeType
  creator: UserType
  sponsored: Boolean
  leaderboard: Boolean
  rewards: String
  maxAnswers: Int
  audience: AudienceType
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum QuestCategoryEnum {
  INDUSTRY
  FAMILY
  FITNESS
  GASTRONOMY
}

enum QuestStatusEnum {
  DRAFT
  ONGOING
  ON_HOLD
  FINISHED
}

type QuestPaginateType {
  count: Int
  isLast: Boolean
  objects: [QuestType!]!
}

type QuestRecurrencyStatusType {
  isReccurent: Boolean!
  repeatDate: DateTime
}

type QuestActionActionContentType {
  content: String
}

type QuestActionActionPerformedType {
  performed: Boolean
}

type QuestActionActionContactType {
  firstname: String
  lastname: String
  email: String
  phone: String
  description: String
  address: FullAddressType
  birthday: DateTime
  gender: Gender
  civility: MaritalStatus
  profession: String
  academicLevel: AcademicLevel
  language: [LanguageType!]
}

type QuestActionActionDateType {
  startDate: DateTime
  endDate: DateTime
}

type QuestActionActionNumberType {
  from: Float
  to: Float
}

type QuestActionActionApiType {
  code: Float
  content: Float
}

type QuestActionActionVerificationContentType {
  verification: QuestActionActionPerformedType
  verified: QuestActionActionPerformedType
}

type QuestActionActionVerificationType {
  number: QuestActionActionVerificationContentType
  email: QuestActionActionVerificationContentType
}

type QuestActionActionChoicesType {
  responses: [String!]
}

type QuestActionActionType {
  textBox: QuestActionActionContentType
  rating: QuestActionActionContentType
  calculated: QuestActionActionContentType
  date: QuestActionActionDateType
  contact: QuestActionActionContactType
  number: QuestActionActionNumberType
  api: QuestActionActionApiType
  matrix: QuestActionActionContentType
  toggle: QuestActionActionContentType
  choices: QuestActionActionChoicesType
  smiley: QuestActionActionContentType
  score: QuestActionActionContentType
  lead: QuestActionActionContentType
  verification: QuestActionActionVerificationType
  video: QuestActionActionPerformedType
  socialMedia: QuestActionActionPerformedType
  appDownload: QuestActionActionPerformedType
}

type QuestActionType {
  id: ID!
  status: QuestActionStatus!
  user: UserType!
  activity: QuestActivityType!
  action: QuestActionActionType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum QuestActionStatus {
  EXPIRED
  PERFORMED
  IN_PROGRESS
}

type QuestActionPaginateType {
  count: Int
  isLast: Boolean
  objects: [QuestActionType!]!
}

type QuestActivityIntType {
  id: ID!
  title: String
  description: String
  tags: [String!]
  media: MediaType
}

type IQuestActivityActivitiesConditionConditionActionType {
  definition: QuestActivityIntType
  action: QuestActionActionType
}

type IQuestActivityActivitiesConditionConditionScoreType {
  operator: OperatorEnum
  value: OperatorEnum
}

type IQuestActivityActivitiesConditionConditionType {
  action: IQuestActivityActivitiesConditionConditionActionType
  score: IQuestActivityActivitiesConditionConditionScoreType
}

type IQuestActivityActivitiesConditionTransitionGotoType {
  action: QuestActivityIntType
}

type IQuestActivityActivitiesConditionTransitionType {
  transition: QuestActivityTransitionType
  goto: IQuestActivityActivitiesConditionTransitionGotoType
  endMessage: String
}

enum QuestActivityTransitionType {
  CONNECTION
  END
}

type IQuestActivityActivitiesConditionType {
  conditionType: QuestActivityConditionType
  condition: IQuestActivityActivitiesConditionConditionType
  transition: IQuestActivityActivitiesConditionTransitionType
}

enum QuestActivityConditionType {
  ACTION
  SCORE
}

type IQuestActivityActivitiesTransitionType {
  title: String
  description: String
}

type IQuestActivityActivitiesType {
  action: QuestActionDefinitionType
  transition: IQuestActivityActivitiesTransitionType
  condition: IQuestActivityActivitiesConditionType
}

type QuestActivityType {
  id: ID!
  title: String
  description: String
  tags: [String!]
  media: MediaType
  quest: QuestType
  rank: Int
  activity: IQuestActivityActivitiesType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestActivityPaginateType {
  count: Int
  isLast: Boolean
  objects: [QuestActivityType!]!
}

type ActivityLogActionType {
  quest: QuestType
  activity: QuestActivityType
  order: MarketPlaceOrderDtoType
}

type ActivityLogAffectedType {
  user: UserType
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ActivityLogBalanceAmountType {
  qualitative: String
  quantitative: String
}

type ActivityLogBalanceType {
  sign: TaxSignEnum!
  amount: ActivityLogBalanceAmountType
}

type ActivityLogType {
  id: ID!
  balance: ActivityLogBalanceType
  action: ActivityLogActionType
  affected: ActivityLogAffectedType
  target: ActivityLogAffectedType
  activityType: ActivityLogTypeEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ActivityLogTypeEnum {
  CONVERSION
  ORDER_ADDED
  WALLET_TOPUP
  ONSITE_ACTIVITY
  QUEST_FULFILLED
  REPUTATION_LOST
  DEAL_ORDER_ADDED
  QUEST_ACTIVITY_FULFILLED
}

type ActivityLogPaginateType {
  count: Int
  isLast: Boolean
  objects: [ActivityLogType!]!
}

type RequestRequestorType {
  firstName: String
  lastName: String
  email: String
  phone: IPhoneType
  address: FullAddressType
}

type RequestCompanyType {
  name: String
  address: FullAddressType
  vatId: String
  registerNo: String
  licenceNo: String
  website: String
  email: String
  phone: IPhoneType
}

type RequestRequestType {
  subject: String
  content: String
}

type RequestType {
  id: ID!
  requestor: RequestRequestorType
  company: RequestCompanyType
  request: RequestRequestType
  type: RequestTypeEnum
  status: RequestStatusEnum
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum RequestTypeEnum {
  CONTACT
  DEMO
  PARTNER
}

enum RequestStatusEnum {
  REQUESTED
  TREATED
  CLOSED
}

type RequestPaginateType {
  count: Int
  isLast: Boolean
  objects: [RequestType!]!
}

type OriginType {
  id: ID!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PartnerReferralType {
  id: ID!
  posTitle: String
  picture: PictureType
  address: FullAddressType
  referralReference: String
  content: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PartnerReferralPaginateType {
  count: Int
  isLast: Boolean
  objects: [PartnerReferralType!]!
}

type CloudinaryResourceType {
  public_id: String
  format: String
  version: String
  resource_type: String
  type: String
  created_at: String
  bytes: String
  width: String
  height: String
  url: String
  secure_url: String
}

type CloudinarySignatureType {
  tags: String
  folder: String
  public_id: String
  timestamp: Float
  signature: String
}

type ShortcutType {
  id: ID!
  label: String!
  description: String
  icon: String!
  picture: PictureType
  link: String!
  router: Boolean!
  user: UserType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ShortcutPaginateType {
  count: Int
  isLast: Boolean
  objects: [ShortcutType!]!
}

type StaticDataType {
  id: ID
  key: String
  value: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type VersionType {
  id: ID!
  version: String!
  platform: PlatformEnum!
  requireUpdate: Boolean!
  versionContent: [VersionContentType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PlatformEnum {
  IOS
  ANDROID
  WEB
  DESKTOP
}

type VersionContentType {
  contentType: VersionContentTypeEnum!
  content: String!
}

enum VersionContentTypeEnum {
  ADDED
  CHANGED
  FIXED
}

type VersionsPaginateType {
  count: Int
  isLast: Boolean
  objects: [VersionType!]!
}

type BookingAttributeType {
  id: ID!
  label: String!
  isRequired: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SettingsAttributeType {
  value: String!
  attribute: BookingAttributeType!
}

type BookingType {
  id: ID!
  user: UserType!
  pos: PointOfSaleType!
  bookingNumber: Float
  instructions: String
  bookingTime: DateTime
  attributes: [SettingsAttributeType!]
  people: Int
  status: BookingStatusEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BookingStatusEnum {
  OPEN
  CONFIRMED
  CLOSED
  CANCELED
}

type AdhocNotificationType {
  title: String
  executed: Boolean
  executedAt: DateTime
  description: String
  picture: PictureType
}

type NotificationOnsiteConverterType {
  qualitativeAmountPushed: String
  quantitativeAmountPushed: String
}

type ActionType {
  reputationLoss: Float
  internalProduct: String
  onsite: NotificationOnsiteConverterType
  adhocNotification: AdhocNotificationType
  booking: BookingType
  subscription: String
  order: String
  adhocOrder: String
  table: String
  quest: String
  activity: String
}

type SubjectsType {
  pos: String
  user: String
  consumer: String
  deliveryMan: String
}

type SubjectsFullType {
  pos: PointOfSaleType
  user: UserType
  consumer: UserType
  deliveryMan: UserType
}

type NotificationType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  action: ActionType
  subjects: SubjectsType
}

enum EventTypeEnum {
  QUEST_FULFILLED
  QUEST_ACTIVITY_FULFILLED
  REPUTATION_LOST
  APP_LOG
  PUSH_AMOUNT
  ORDER_CREATED
  ADHOC_NOTIFICATION
  SUBSCRIPTION_APPROVED
  SUBSCRIPTION_REJECTED
  SUBSCRIPTION_REQUESTED
  PRODUCT_CANCELLED
  PRODUCT_STATUS_UPDATED
  PRODUCT_PAYMENT_STATUS_UPDATED
  WALLET_TOPUP
  WAITER_CALLED
  CALL_WAITER_FOR_CHECK
  DELIVERY_MAN_ASSIGNED
  DEAL_CONFIRMED
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED_BY_POS
  BOOKING_CANCELLED_BY_CONSUMER
}

type AdhocNotificationTestType {
  event: EventTypeEnum
  executed: Boolean
  executedAt: DateTime
  seen: Boolean
  action: ActionType
}

type UnseenNotificationCountType {
  count: Int!
}

type NotificationFullType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  action: ActionType
  subjects: SubjectsFullType
}

type NotificationResponse {
  success: Boolean!
}

type GroupInviteType {
  id: ID!
  group: GroupType
  requestor: UserType
  status: GroupInviteStatusEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GroupInviteStatusEnum {
  PENDING
  CONFIRMED
  CANCELED
  REJECTED
}

type GroupLeaderboardBaseType {
  user: UserType!
  group: GroupType!
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: DateTime!
}

type GroupLeaderboardType {
  user: UserType!
  group: GroupType!
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: DateTime!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowType {
  id: ID!
  user: UserType!
  target: TargetWithGroupType!
}

type MembersType {
  users: [UserType!]
}

type LastMessageType {
  text: String
  gif: String
  sticker: String
  media: MessageMediaType
  location: LonLatType
  custom: CustomMessageType
  unread: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MessageGroupWallpaperType {
  picture: PictureType
  gradientColors: [String!]
  assetImage: String
}

type MessageGroupType {
  id: ID!
  name: String
  mute: Boolean
  creator: UserType
  profilePicture: PictureType
  wallpaper: MessageGroupWallpaperType
  sound: MessageSoundEnum
  status: MessageGroupStatusEnum
  type: MessageGroupTypeEnum
  members: MembersType
  lastMessage: LastMessageType
  unreadCount: Int
  isDirectMessage: Boolean
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum MessageSoundEnum {
  DEFAULT
  NONE
  AURORA
}

enum MessageGroupStatusEnum {
  ACTIVE
  ARCHIVED
}

enum MessageGroupTypeEnum {
  SUPPORT
  INTERNAL
}

type MessageGroupPaginateType {
  count: Int
  isLast: Boolean
  objects: [MessageGroupType!]!
}

type MessageMediaType {
  picture: [PictureType!]
  video: [PictureType!]
}

type CustomMessageType {
  id: String
  type: String
}

type MessageType {
  id: ID!
  text: String
  gif: String
  sticker: String
  custom: CustomMessageType
  media: MessageMediaType
  location: LonLatType
  messageGroup: MessageGroupType!
  sender: UserType!
  seenBy: [UserType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UnseenMessagesCountType {
  unseenMessagesCount: Int!
}

type MessagePaginateType {
  count: Int
  isLast: Boolean
  objects: [MessageType!]!
}

type MessageMediaPaginateType {
  count: Int
  isLast: Boolean
  objects: [PictureType!]!
}

type CorporateEmailTemplateType {
  id: ID!
  name: EmailTemplateTypeEnum
  content: String!
  icon: String
  color: String
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CorporateEmailTemplatePaginateType {
  count: Int
  isLast: Boolean
  objects: [CorporateEmailTemplateType!]!
}

type AccountType {
  id: ID!
  expiresAt: DateTime
  user: UserType
  targets: TargetsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccountPaginateType {
  count: Int
  isLast: Boolean
  objects: [AccountType!]!
}

type CompanyPaginateType {
  count: Int
  isLast: Boolean
  objects: [CompanyType!]!
}

type CompanyContactType {
  id: ID!
  firstName: String
  lastName: String
  email: String
  phone: IPhoneType
  dateOfBirth: DateTime
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  media: MediaType
  tags: [String!]
  lastContacted: DateTime
  leadScore: String
  externalId: String
  company: CompanyType
  address: FullAddressType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CompanyContactPaginateType {
  count: Int
  isLast: Boolean
  objects: [CompanyContactType!]!
}

type CompanySettingsPurchaseNoteType {
  reference: DocumentReferenceModelEnum
  prefix: String
  note: String
}

enum DocumentReferenceModelEnum {
  WITH_PREFIX
  WITH_PREFIX_AND_DATE
  WITH_DATE
  WITH_DATE_WITHOUT_HYPHEN
  WITHOUT_PREFIX
}

type CompanySettingsPurchaseType {
  inventory: CompanySettingsPurchaseNoteType
  order: CompanySettingsPurchaseNoteType
  invoice: CompanySettingsPurchaseNoteType
  deliveryNote: CompanySettingsPurchaseNoteType
}

type CompanySettingsSaleQuotationValidityType {
  period: String
  cycle: String
}

type CompanySettingsSaleQuotationType {
  reference: DocumentReferenceModelEnum
  prefix: String
  label: String
  validity: CompanySettingsSaleQuotationValidityType
  color: String
  note: String
}

type CompanySettingsSaleType {
  quotation: CompanySettingsSaleQuotationType
  order: CompanySettingsSaleQuotationType
  invoice: CompanySettingsSaleQuotationType
  deliveryNote: CompanySettingsSaleQuotationType
  issueNote: CompanySettingsSaleQuotationType
}

type CompanySettingsTicketsType {
  prefix: String
}

type CompanySettingsType {
  id: ID!
  sale: CompanySettingsSaleType
  purchase: CompanySettingsPurchaseType
  tickets: CompanySettingsTicketsType
  logistic: CompanySettingsTicketsType
  company: CompanyType
  documentLogo: PictureType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DepartmentBaseType {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DepartmentType {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type DepartmentPaginatedType {
  count: Int
  isLast: Boolean
  objects: [DepartmentType!]!
}

type AssigneeDtoType {
  user: UserType
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ModulesDefinitionType {
  id: ID!
  name: String!
  target: TargetTypeEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TargetTypeEnum {
  POS
  MANUFACTURER
  USER
}

type ModulesAssignmentType {
  id: ID!
  module: ModulesDefinitionType!
  assignee: AssigneeDtoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SupplierType {
  id: ID!
  reference: String!
  externalId: String!
  supplier: TargetType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedSupplierType {
  count: Int
  isLast: Boolean
  objects: [SupplierType!]!
}

type CorporateTemplateType {
  id: ID!
  name: CorporateTemplateTypeEnum!
  content: String!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CorporateTemplateTypeEnum {
  ROBOTS
  BROWSER_CONFIG
  WEB_MANIFEST
  SITE_MAP
  ADS
}

type ComplaintTargetType {
  user: UserType
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ComplaintType {
  id: ID!
  reporter: UserType!
  report: String!
  target: ComplaintTargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ComplaintPaginateType {
  count: Int
  isLast: Boolean
  objects: [ComplaintType!]!
}

type BrandPaginateType {
  count: Int
  isLast: Boolean
  objects: [BrandType!]!
}

type ProductFilterType {
  createdAtRange: DateRangeType
  updatedAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of brands
  brands: [BrandType!]

  # list of inventoryCategories
  categories: [InventoryCategoryType!]

  # list of productAttributes
  productAttributes: [ProductAttributeType!]

  # list of barcodes
  barcodes: [BarcodeType!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  rent: Boolean
}

type ProductPaginateType {
  count: Int
  isLast: Boolean
  objects: [ProductType!]!
}

type ProductPaginateWithFilterType {
  count: Int
  isLast: Boolean
  filter: ProductFilterType
  objects: [ProductType!]!
}

type ProductRatingDefinitionType {
  id: ID
  reviewType: String
  active: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductRatingDefinitionPaginateType {
  count: Int
  isLast: Boolean
  objects: [ProductRatingDefinitionType!]!
}

type ByMarkRatingType {
  mark: Int!
  count: Int!
}

type AverageRatingType {
  byMark: [ByMarkRatingType!]!
  overAllAverage: String!
}

type ProductRatingType {
  id: ID!
  mark: Int!
  comment: String
  user: UserType!
  reviewType: ProductRatingDefinitionType!
  product: ProductType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductRatingPaginateType {
  count: Int
  isLast: Boolean
  objects: [ProductRatingType!]!
}

type ProductRatingWithStatsPaginatedType {
  count: Int
  isLast: Boolean
  objects: [ProductRatingType!]!
  stats: [ByMarkRatingType!]
}

type InventoryCategoryCountType {
  id: String
  name: String
  picture: PictureType
  layer: Int
  rank: Int
  parent: String
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int
}

type NumberOfInventoryCategoriesType {
  layer: Int!
  numberOfInventoryCategories: Int!
}

type PriceRangeCountType {
  numberOfProducts: Int!
  priceRange: [Float!]
}

type NumberOfProductsInventoryDashboardType {
  total: Int
  byInventoryCategory: [InventoryCategoryCountType!]!
  byPriceRange: [PriceRangeCountType!]!
  byWholesalerPriceRange: [PriceRangeCountType!]!
  byFactoryPriceRange: [PriceRangeCountType!]!
}

type InventoryDashboardType {
  numberOfBrands: Int
  numberOfProducts: NumberOfProductsInventoryDashboardType!
  numberOfInventoryCategories: [NumberOfInventoryCategoriesType!]!
}

type FavoriteProductType {
  id: ID!
  user: UserType
  products: [ProductType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type IsFavoriteProductType {
  isFavorite: Boolean!
}

type InventoryCategoryPaginateType {
  count: Int
  isLast: Boolean
  objects: [InventoryCategoryType!]!
}

type ProductsByCatalogueCategoryCountType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int!
}

type POSByPOSCategoryCountType {
  id: ID!
  name: String
  mapPicture: String
  picture: PictureType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfPos: Int!
}

type AccountsByRoleCountType {
  numberOfAccounts: Int!
  role: UserRole!
}

type RolesCountType {
  numberOfPosRoles: Int!
  numberOfManufacturersRoles: Int!
  numberOfWholesalersRoles: Int!
  countByRoles: [AccountsByRoleCountType!]!
}

type AccountsCountType {
  total: Int!
  totalNumberOfPosAccounts: Int!
  totalNumberOfWholesalerAccounts: Int!
  totalNumberOfManufacturerAccounts: Int!
}

type InternalProductsByCatalogueCategoryCountType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int!
}

type InternalProductsByInventoryCategoryCountType {
  id: ID!
  name: String!
  picture: PictureType
  layer: Int!
  rank: Int!
  hasChildren: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int!
}

type InternalProductsByPOSCountType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currencies: [TargetCurrencyType!]
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfPosProducts: Int!
}

type InternalProductsByWholesalerCountType {
  id: ID!
  name: String
  description: String
  address: FullAddressType
  picture: PictureType
  email: String
  website: String
  phone: IPhoneType
  contactEmails: [String!]
  fax: IPhoneType
  currencies: [TargetCurrencyType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfWholesalerProducts: Int!
}

type InternalProductsByManufacturerCountType {
  id: ID!
  name: String
  description: String
  picture: PictureType
  externalId: String
  address: FullAddressType
  email: String
  website: String
  contactEmails: [String!]
  currencies: [TargetCurrencyType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfManufacturerProducts: Int!
}

type NumberOfInternalProductsType {
  total: Int!
  byPos: [InternalProductsByPOSCountType!]!
  byWholesalers: [InternalProductsByWholesalerCountType!]!
  byManufacturers: [InternalProductsByManufacturerCountType!]!
  byCatalogueCategory: [InternalProductsByCatalogueCategoryCountType!]!
  byInventoryCategory: [InternalProductsByInventoryCategoryCountType!]!
}

type NumberOfProductsType {
  total: Int!
  byCatalogueCategory: [ProductsByCatalogueCategoryCountType!]!
  byInventoryCategory: [InventoryCategoryCountType!]!
}

type NumberOfPointOfSalesType {
  total: Int!
  byPosCategory: [POSByPOSCategoryCountType!]!
}

type CorporateUserDashboardType {
  gender: [AuthDashboardGenderType!]!
  mailValidation: [AuthDashboardMailValidationType!]!
  age: [AuthDashboardAgeType!]!
  returningUsers: Int!
  newUsers: Int!
}

type CorporateTargetDashboardType {
  numberOfRoles: [AccountsByRoleCountType!]!
  numberOfInternalProducts: NumberOfProductsType!
}

type CorporateUsersStatsType {
  current: Int!
  previous: Int!
  percentage: Float!
}

type GetCorporateUserAnalyticsType {
  activeUsers: CorporateUsersStatsType!
  overAllUsers: CorporateUsersStatsType!
  returningUsers: CorporateUsersStatsType!
}

type PeriodStatsType {
  date: String!
  total: Float!
}

type GetCorporateUserByDayInPeriodAnalyticsType {
  newUsers: [PeriodStatsType!]!
  activeUsers: [PeriodStatsType!]!
}

type TotalAndInPeriodCountsType {
  inPeriod: Int!
  total: Int!
}

type StockStatsType {
  total: Int!
  daily: [PeriodStatsType!]!
}

type StocksCountType {
  inPeriod: Int!
  total: Int!
  inStock: StockStatsType!
  outOfStock: StockStatsType!
}

type RatingsCountType {
  inPeriod: Int!
  total: Int!
  oneStarDaily: [PeriodStatsType!]!
  twoStarsDaily: [PeriodStatsType!]!
  threeStarsDaily: [PeriodStatsType!]!
  fourStarsDaily: [PeriodStatsType!]!
  fiveStarsDaily: [PeriodStatsType!]!
}

type VisitsFieldType {
  current: Int!
  previous: Int!
  percentage: Float!
  weeklyVisits: [PeriodStatsType!]!
}

type ConversionsFieldType {
  current: Int!
  previous: Int!
  percentage: Float!
  weeklyConversions: [PeriodStatsType!]!
}

type ImpressionsFieldType {
  current: Int!
  previous: Int!
  percentage: Float!
  weeklyImpressions: [PeriodStatsType!]!
}

type GetCorporateUsersRequestsAnalyticsType {
  visits: VisitsFieldType!
  impressions: ImpressionsFieldType!
  conversions: ConversionsFieldType!
}

type GetCorporateUsersTechnologiesDashboardDataType {
  web: Int!
  mobile: Int!
  unknown: Int!
  webDaily: [PeriodStatsType!]!
  mobileDaily: [PeriodStatsType!]!
  unknownDaily: [PeriodStatsType!]!
}

type CorporateDashboardType {
  totalNumberOfCompanies: Int!
  totalNumberOfWholesalers: Int!
  totalNumberOfManufacturers: Int!
  numberOfPointOfSales: NumberOfPointOfSalesType!
  rolesCount: RolesCountType!
  accountsCount: AccountsCountType!
  numberOfInternalProducts: NumberOfInternalProductsType!
}

type GetCorporateWarehouseDashboardDataType {
  stocksCount: StocksCountType!
  ratingsCount: RatingsCountType!
  categoriesCount: TotalAndInPeriodCountsType!
  productsCount: TotalAndInPeriodCountsType!
}

type WholesalerPaginateType {
  count: Int
  isLast: Boolean
  objects: [WholesalerType!]!
}

type BrandValidationType {
  headersValid: Boolean!
  isIdComplete: Boolean!
  isNameComplete: Boolean!
  overallValidation: Boolean!
  length: Int!
}

type BarcodeValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isNameComplete: Boolean
  isProductsComplete: Boolean
  isPricesComplete: Boolean
  overallValidation: Boolean
  length: Int
  numBarcodesWithAttributes: Int
}

type ProductValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isNameComplete: Boolean
  isCategoriesComplete: Boolean
  isBrandsComplete: Boolean
  isVATComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type AttributesValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isLabelComplete: Boolean
  isRequiredComplete: Boolean
  isMultipleComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type CategoriesValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isLayerComplete: Boolean
  isRankComplete: Boolean
  isNameComplete: Boolean
  isParentComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type AttributesValuesValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isValueComplete: Boolean
  isAttributeComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type StockValidationType {
  headersValid: Boolean
  isBarcodeComplete: Boolean
  isMinimumComplete: Boolean
  isCapacityComplete: Boolean
  isStockComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type CatalogueImportValidationType {
  brandValidation: BrandValidationType!
  barcodeValidation: BarcodeValidationType!
  productValidation: ProductValidationType!
  attributesValidation: AttributesValidationType!
  categoriesValidation: CategoriesValidationType!
  attributesValuesValidation: AttributesValuesValidationType!
  stockValidation: StockValidationType!
  notRecognizedSheets: [String!]!
  overallValidation: Boolean!
}

type ManufacturerPaginateType {
  count: Int
  isLast: Boolean
  objects: [ManufacturerType!]!
}

type IsUserNearPOSDtoType {
  isUserNearPOS: Boolean!
}

type PointOfSalePaginateType {
  count: Int
  isLast: Boolean
  objects: [PointOfSaleType!]!
}

type BookingPaginateType {
  count: Int
  isLast: Boolean
  objects: [BookingType!]!
}

type BookingAttributePaginateType {
  count: Int
  isLast: Boolean
  objects: [BookingAttributeType!]!
}

type MonthDaysType {
  month: Int!
  days: [Int!]
}

type TimeFromToType {
  from: String
  to: String
}

type BookingTypeType {
  id: ID
  index: Int
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookingSettingsType {
  id: ID!
  bookTime: TimeFromToType
  bookingMaxCapacity: Int
  mobileBooking: Boolean
  portalBooking: Boolean
  facebookBooking: Boolean
  nonBookableDays: [MonthDaysType!]
  settingsAttributes: [SettingsAttributeType!]
  bookingType: BookingTypeType
  createdAt: DateTime!
  updatedAt: DateTime!
  pos: String
}

type BookingSettingsFullType {
  id: ID!
  bookTime: TimeFromToType
  bookingMaxCapacity: Int
  mobileBooking: Boolean
  portalBooking: Boolean
  facebookBooking: Boolean
  nonBookableDays: [MonthDaysType!]
  settingsAttributes: [SettingsAttributeType!]
  bookingType: BookingTypeType
  createdAt: DateTime!
  updatedAt: DateTime!
  pos: PointOfSaleType
}

type BookingTypePaginateType {
  count: Int
  isLast: Boolean
  objects: [BookingTypeType!]!
}

type BookingsStatusesCountType {
  OPEN: Int!
  CLOSED: Int!
  CANCELED: Int!
  CONFIRMED: Int!
}

type BookingsSourcesCountType {
  APP: Int!
  EMAIL: Int!
  PHONE: Int!
  FACEBOOK: Int!
  INSTAGRAM: Int!
}

type BookingsCountType {
  total: Int!
  numberOfPeople: [NumberOfPeopleCountType!]!
  bookingStatuses: BookingsStatusesCountType!
  bookingSources: BookingsSourcesCountType!
}

type NumberOfPeopleCountType {
  numberOfBookings: Int!
  numberOfPeopleRange: [Int!]!
}

type BookingDashboardType {
  bookingsCount: BookingsCountType!
}

type POSCategoryPaginateType {
  count: Int
  isLast: Boolean
  objects: [POSCategoryType!]!
}

type POSServicesPaginateType {
  count: Int
  isLast: Boolean
  objects: [POSServicesType!]!
}

type POSComissionType {
  id: ID!
  pos: PointOfSaleType
  walletComission: String
  marketplaceComission: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSContactRequestType {
  id: ID!
  pos: PointOfSaleType
  firstName: String!
  lastName: String!
  email: String!
  phoneNumber: String
  companyName: String
  subject: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CorporateUserType {
  id: ID!
  email: String
  picture: PictureType
  pictures: [PictureType!]
  covers: [PictureType!]
  roles: [UserRole!]
  username: String
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  apps: [App!]
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [LanguageType!]
  education: [UserEducationType!]
  work: [UserWorkType!]
  lived: [StateType!]
  hobbies: [String!]
  interests: [String!]
  isMailValid: Boolean
  plugged: Boolean
  hasAutoGeneratedEmail: Boolean
  dateOfBirth: DateTime
  phoneNumber: String
  phone: PhoneType
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  socialLoginData: SocialLoginDataType
  nationality: CountryType
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressType!]
  shippingAddress: [FullAddressType!]
  billingAddress: [FullAddressType!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType
}

type CorporateUserExistType {
  exist: Boolean!
  user: CorporateUserType
}

type CorporateUserPaginateType {
  count: Int
  isLast: Boolean
  objects: [CorporateUserType!]!
}

type LoyaltyProgramPaginateType {
  count: Int
  isLast: Boolean
  objects: [LoyaltyProgramType!]!
}

type CorporateRatingDefinitionType {
  id: ID
  reviewType: String
}

type CorporateRatingDefinitionPaginateType {
  count: Int
  isLast: Boolean
  objects: [CorporateRatingDefinitionType!]!
}

type CorporateRatingType {
  id: ID!
  mark: Int!
  comment: String
  product: InternalProductType
  user: UserType!
  reviewType: CorporateRatingDefinitionType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CorporateRatingPaginateType {
  count: Int
  isLast: Boolean
  objects: [CorporateRatingType!]!
}

type CorporateRatingWithStatsPaginatedType {
  count: Int
  isLast: Boolean
  objects: [CorporateRatingType!]!
  stats: [ByMarkRatingType!]
}

type CorporateRatingAssignmentType {
  id: ID
  active: Boolean
  target: TargetType
  reviewDefinition: CorporateRatingDefinitionType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CorporateRatingAssignmentPaginateType {
  count: Int
  isLast: Boolean
  objects: [CorporateRatingAssignmentType!]!
}

type PromotionProductsType {
  barcode: BarcodeType!
  discount: DiscountDtoType!
}

type PromotionProductsWithInternalProductType {
  barcode: BarcodeBaseRawType!
  discount: DiscountDtoType!
  internalProduct: InternalProductType!
}

type PromotionType {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  status: PromotionStatusEnum!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  promotion: [PromotionProductsType!]!
}

enum PromotionStatusEnum {
  DRAFT
  ONGOING
  EXPIRED
}

type PromotionWithInternalProductType {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  status: PromotionStatusEnum!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  promotion: [PromotionProductsWithInternalProductType!]!
}

type PromotionPaginateType {
  count: Int
  isLast: Boolean
  objects: [PromotionType!]!
}

type PromotionWithInternalProductPaginateType {
  count: Int
  isLast: Boolean
  objects: [PromotionWithInternalProductType!]!
}

type BarcodeFilterResponseType {
  createdAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of catalogueCategories
  catalogueCategories: [FilterNameFieldType!]
}

type InternalProductFilterType {
  createdAtRange: DateRangeType
  updatedAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of brands
  brands: [FilterNameFieldType!]

  # list of catalogueCategories
  catalogueCategories: [FilterNameFieldType!]

  # list of AttributeValues
  productAttributesValues: [AttributeWithValueFilterType!]
  targets: TargetsType
}

type InternalProductPaginateType {
  count: Int
  isLast: Boolean
  objects: [InternalProductType!]!
}

type InternalProductWithFavoriteStatusPaginateType {
  count: Int
  isLast: Boolean
  objects: [InternalProductWithFavoriteStatusType!]!
}

type RecentlyViewedInternalProductWithFavoriteStatusPaginateType {
  count: Int
  isLast: Boolean
  objects: [RecentlyViewedInternalProductWithFavoriteStatusType!]!
}

type InternalProductWithBarcodesWithPublicPricePaginateType {
  count: Int
  isLast: Boolean
  objects: [InternalProductWithBarcodesWithPublicPriceType!]!
}

type BarcodesPaginatedWithFilterType {
  count: Int
  isLast: Boolean
  filter: BarcodeFilterResponseType
  objects: [BarcodeType!]!
}

type InternalProductPaginateWithFilterType {
  count: Int
  isLast: Boolean
  filter: InternalProductFilterType
  objects: [InternalProductType!]!
}

type InternalProductWithRatingsPaginateWithFilterType {
  count: Int
  isLast: Boolean
  filter: InternalProductFilterType
  objects: [InternalProductWithRatingsType!]!
}

type InternalProductWithRatingsPaginateWithFavoriteStatusWithFilterType {
  count: Int
  isLast: Boolean
  filter: InternalProductFilterType
  objects: [InternalProductWithRatingsWithFavoriteStatusType!]!
}

type RecentlyViewedType {
  id: ID!
  user: UserType!
  product: InternalProductType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CompareProductType {
  id: ID!
  user: UserType!
  products: InternalProductType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FavoriteInternalProductType {
  id: ID!
  user: UserType
  products: [InternalProductType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type IsFavoriteInternalProductType {
  isFavorite: Boolean!
}

type FeaturedCorporateType {
  id: ID!
  rank: Int!
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FeaturedCorporatePaginateType {
  count: Int
  isLast: Boolean
  objects: [FeaturedCorporateType!]!
}

type CatalogueCategoryPaginateType {
  count: Int
  isLast: Boolean
  objects: [CatalogueCategoryType!]!
}

type CorporateUserCardType {
  id: ID!
  user: UserType!
  target: TargetType!
  identifier: String!
  cardType: CardTypeEnum!
  validUntil: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CardTypeEnum {
  PHYSICAL
  VIRTUAL
}

type GenerateUserCardType {
  virtualCard: CorporateUserCardType
  physicalCard: CorporateUserCardType
}

type CorporateUserCardFullPaginatedType {
  count: Int
  isLast: Boolean
  objects: [CorporateUserCardType!]!
}

type MarketPlaceProductType {
  id: ID!
  product: ProductType!
  internalProducts: [InternalProductType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MarketPlaceProductFilterType {
  createdAtRange: DateRangeType
  updatedAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of brands
  brands: [BrandType!]

  # list of inventoryCategories
  categories: [InventoryCategoryType!]
  targets: TargetsType
}

type AdhocCorporateNotificationType {
  title: String
  executed: Boolean
  executedAt: DateTime
  description: String
  picture: PictureType
}

type CorporateNotificationOnsiteConverterType {
  qualitativeAmountPushed: String
  quantitativeAmountPushed: String
}

type CorporateActionType {
  reputationLoss: Float
  internalProduct: String
  onsite: CorporateNotificationOnsiteConverterType
  adhocNotification: AdhocCorporateNotificationType
  booking: BookingType
  subscription: String
  order: String
  adhocOrder: String
  table: String
  quest: String
  activity: String
}

type CorporateNotificationType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  user: UserType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  action: CorporateActionType
}

type AdhocCorporateNotificationTestType {
  event: EventTypeEnum
  executed: Boolean
  executedAt: DateTime
  seen: Boolean
  action: CorporateActionType
}

type UnseenCorporateNotificationCountType {
  count: Int!
}

type CorporateNotificationFullType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  user: UserType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  action: CorporateActionType
}

type CorporateNotificationPaginateType {
  count: Int
  isLast: Boolean
  objects: [CorporateNotificationType!]!
}

type CorporateNotificationResponse {
  success: Boolean!
}

type GoogleMapsAuditDataOrderType {
  name: String
  url: String
}

type GoogleMapsAuditDataReviewsType {
  oneStar: Float
  twoStar: Float
  threeStar: Float
  fourStar: Float
  fiveStar: Float
}

type GoogleMapsAuditDataLocationType {
  lat: Float
  lng: Float
}

type GoogleMapsAuditDataType {
  title: String
  subTitle: String
  price: String
  menu: String
  categoryName: String
  address: String
  locatedIn: String
  neighborhood: String
  street: String
  city: String
  postalCode: String
  state: String
  countryCode: String
  plusCode: String
  website: String
  phone: String
  temporarilyClosed: Boolean
  location: GoogleMapsAuditDataLocationType
  permanentlyClosed: Boolean
  totalScore: String
  isAdvertisement: Boolean
  rank: Float
  placeId: String
  categories: [String!]
  cid: String
  url: String
  searchPageUrl: String
  searchString: String
  scrapedAt: DateTime
  reviewsCount: Float
  reviewsDistribution: GoogleMapsAuditDataReviewsType
  reviews: [String!]
  orderBy: GoogleMapsAuditDataOrderType
}

type GoogleMapsAuditType {
  id: ID
  data: [GoogleMapsAuditDataType!]!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AnalyticsStatsInfoType {
  value: Float!
  percentage: Float!
}

type AnalyticsStatsType {
  users: AnalyticsStatsInfoType
  sessions: AnalyticsStatsInfoType
  visitDuration: AnalyticsStatsInfoType
  bounceRate: AnalyticsStatsInfoType
}

type AnalyticsUsersByCountryLayersType {
  coordination: GoogleMapsAuditDataLocationType
  radius: Float
}

type AnalyticsUsersByCountrySegmentsType {
  duration: String
  sessions: Float
  views: Float
}

type AnalyticsUsersByCountryType {
  layers: [AnalyticsUsersByCountryLayersType!]
  segments: [AnalyticsUsersByCountrySegmentsType!]
}

type AnalyticsSessionsByCountriesType {
  country: CountryType
  value: Int
  color: String
}

type AnalyticsRateCompareType {
  rate: Float!
  compare: Float!
}

type AnalyticsAudienceMetricsChartType {
  last: [Float!]!
  current: [Float!]!
}

type AnalyticsAudienceMetricsType {
  avgSession: AnalyticsRateCompareType
  conversion: AnalyticsRateCompareType
  duration: AnalyticsRateCompareType
  chart: AnalyticsAudienceMetricsChartType
}

type AnalyticsAudienceSessionsByCountryChartDataType {
  week: String
  value: Int
}

type AnalyticsAudienceSessionsByCountryType {
  day: Days
  data: [AnalyticsAudienceSessionsByCountryChartDataType!]
}

type AnalyticsUsersByDeviceDeviceType {
  value: Int
  compare: Float
}

type AnalyticsUsersByDeviceType {
  desktop: AnalyticsUsersByDeviceDeviceType
  mobile: AnalyticsUsersByDeviceDeviceType
  tablet: AnalyticsUsersByDeviceDeviceType
}

type AnalyticsTopReferralPagesSegmentType {
  source: String
  color: String
  value: Float
}

type AnalyticsTopReferralPagesType {
  total: Int
  compare: Float
  segments: [AnalyticsTopReferralPagesSegmentType!]
}

type AnalyticsTopPagesType {
  page: String
  active: Int
  users: Float
}

type CrmAnalyticsStatsInfoType {
  sent: Float
  annualProfit: Float
  leadConversion: Float
  dailyIncome: Float
  annualDeals: Float
}

type CrmAnalyticsSalesForecastType {
  goal: Float
  pending: Float
  revenue: Float
}

type CrmAnalyticsDealTypeType {
  year: Float
  class: Float
  value: Float
}

type CrmAnalyticsBalanceOverviewChartType {
  kind: CrmKindEnum
  data: [Float!]
}

enum CrmKindEnum {
  REVENUE
  EXPENSE
}

type CrmAnalyticsBalanceOverviewType {
  revenue: Float
  expense: Float
  profit: Float
  chart: [CrmAnalyticsBalanceOverviewChartType!]
}

type SalesAnalyticsStatsType {
  totalEarnings: AnalyticsStatsInfoType
  orders: AnalyticsStatsInfoType
  customers: AnalyticsStatsInfoType
  balance: AnalyticsStatsInfoType
}

type SalesAnalyticsRevenueStatsChartType {
  orders: [Float!]
  earnings: [Float!]
  refunds: [Float!]
}

type SalesAnalyticsRevenueStatsType {
  orders: Float
  earnings: Float
  refunds: Float
  conversions: Float
  chart: SalesAnalyticsRevenueStatsChartType
}

type SalesAnalyticsSalesByCountrySegmentsType {
  country: CountryType
  value: Float
}

type SalesAnalyticsSalesByCountryType {
  layers: [AnalyticsUsersByCountryLayersType!]
  segments: [SalesAnalyticsSalesByCountrySegmentsType!]
}

type SalesAnalyticsTopCatalogueCategoriesType {
  category: CatalogueCategoryType
  value: Float
}

type CollaborationAnalyticsStatsType {
  activeProjects: AnalyticsStatsInfoType
  activeBoards: AnalyticsStatsInfoType
  totalHours: AnalyticsStatsInfoType
}

type CollaborationAnalyticsProjectsOverviewChartType {
  totalProjects: [Int!]
  activeProjects: [Int!]
  revenue: [Float!]
}

type CollaborationAnalyticsProjectsOverviewType {
  totalProjects: Int
  activeProjects: Int
  revenue: Float
  hours: Int
  chart: CollaborationAnalyticsProjectsOverviewChartType
}

type CollaborationAnalyticsProjectsStatusChartDetailType {
  count: Int
  hours: Int
}

type CollaborationAnalyticsProjectsStatusChartType {
  completed: CollaborationAnalyticsProjectsStatusChartDetailType
  inProgress: CollaborationAnalyticsProjectsStatusChartDetailType
  open: CollaborationAnalyticsProjectsStatusChartDetailType
  canceled: CollaborationAnalyticsProjectsStatusChartDetailType
}

type CollaborationAnalyticsProjectsStatusType {
  totalProjects: Int
  newProjects: Int
  chart: CollaborationAnalyticsProjectsStatusChartType
}

type SEOType {
  id: ID!
  target: TargetType!
  googleAnalyticsId: String
  titleTag: String
  metaDescriptionTag: String
  headerTags: [TagType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedSEOType {
  count: Int
  isLast: Boolean
  objects: [SEOType!]!
}

type SeoComponentType {
  metaTitle: String
  metaDesription: String
  metaKeywords: [TagType!]
}

type BlogType {
  id: ID!
  target: TargetType!
  author: UserType!
  status: String!
  title: String!
  url: String
  tags: [String!]
  seo: SeoComponentType
  pictures: [PictureType!]
  sectionData: [BlogDataType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BlogDataType {
  sectionReference: String
  sectionTitle: String
  sectionContent: String
  sectionPictures: [PictureType!]
}

type PaginatedBlogsType {
  count: Int
  isLast: Boolean
  objects: [BlogType!]!
}

type LandingPagesType {
  id: ID!
  target: TargetType!
  pageType: LandingPageTypeEnum!
  pageReference: String!
  pageTitle: String!
  status: String!
  pageDescription: String
  url: String
  tags: [String!]
  seo: SeoComponentType
  sectionData: [LandingPagesDataType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LandingPageTypeEnum {
  ABOUT
  CONTACT
  PRIVACY
  TERMS
  RETURN_EXCHANGE
  SHIPPING
  COPYRIGHT
  FAQ
  PROJECT
  CAREER
  PROJECTS
  BLOG
}

type LandingPagesDataType {
  sectionReference: String
  sectionTitle: String
  sectionContent: String
  sectionPictures: [PictureType!]
}

type PaginatedLandingPagesType {
  count: Int
  isLast: Boolean
  objects: [LandingPagesType!]!
}

type SlidesType {
  id: ID!
  target: TargetType!
  reference: String
  visualType: SlideVisualTypeEnum
  content: [SlidesContentType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum SlideVisualTypeEnum {
  PICTURE
  ICON
}

type SlidesContentType {
  image: PictureType
  icon: String
  title: String
  description: String
  calltoaction: String
}

type PaginatedSlidesType {
  count: Int
  isLast: Boolean
  objects: [SlidesType!]!
}

type VisualsFaviconType {
  size16: PictureType
  size32: PictureType
  size57: PictureType
  size60: PictureType
  size72: PictureType
  size76: PictureType
  size96: PictureType
  size114: PictureType
  size120: PictureType
  size144: PictureType
  size152: PictureType
  size180: PictureType
  size192: PictureType
}

type VisualsType {
  id: ID!
  target: TargetType!
  pageTitle: String
  logo: PictureType
  wide: PictureType
  square: PictureType
  favicon: VisualsFaviconType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedVisualsType {
  count: Int
  isLast: Boolean
  objects: [VisualsType!]!
}

type JobDescriptionType {
  description: String
  descriptionList: [String!]
}

type JobSpecsType {
  key: JobDefinitionSpecEnum
  value: String
}

enum JobDefinitionSpecEnum {
  SALARY
  PERKS
  HOLIDAYS
  SKILLS
  LOCATION
  HOMEOFFICE
}

type JobDefinitionBaseType {
  id: ID!
  title: String!
  status: JobDefinitionStatusEnum!
  department: DepartmentBaseType!
  specs: [JobSpecsType!]
  description: JobDescriptionType
  responsibility: JobDescriptionType
  offer: JobDescriptionType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum JobDefinitionStatusEnum {
  DRAFT
  ONGOING
  HIRED
  CANCELED
}

type JobDefinitionType {
  id: ID!
  title: String!
  status: JobDefinitionStatusEnum!
  specs: [JobSpecsType!]
  description: JobDescriptionType
  responsibility: JobDescriptionType
  offer: JobDescriptionType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  department: DepartmentType!
}

type JobDefinitionPaginatedType {
  count: Int
  isLast: Boolean
  objects: [JobDefinitionType!]!
}

type DocumentContentType {
  type: ContentTypeType
  base64: String
}

type DocumentType {
  id: ID!
  name: String!
  content: DocumentContentType
  size: Float
  owner: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DocumentPaginatedType {
  count: Int
  isLast: Boolean
  objects: [DocumentType!]!
}

type JobApplicationBaseType {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  message: String!
  cv: DocumentType
  cover: DocumentType
  status: JobApplicationStatusEnum!
  jobDefinition: JobDefinitionBaseType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum JobApplicationStatusEnum {
  NEW
  NOT_CONSIDERED
  SHORTLISTED
  HIRED
}

type JobApplicationType {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  message: String!
  cv: DocumentType
  cover: DocumentType
  status: JobApplicationStatusEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  jobDefinition: JobDefinitionType!
}

type JobApplicationPaginatedType {
  count: Int
  isLast: Boolean
  objects: [JobApplicationType!]!
}

type JobApplicationBasePaginatedType {
  count: Int
  isLast: Boolean
  objects: [JobApplicationBaseType!]!
}

type OrderShoppingCartAttributeType {
  label: String!
  externalId: String!
  isRequired: Boolean!
  isMultipleChoice: Boolean!
}

type OrderShoppingCartAttributesValuesType {
  label: String!
  externalId: String!
  attribute: OrderShoppingCartAttributeType!
}

type CouponType {
  id: ID!
  couponCode: String
  target: TargetType!
  user: UserType
  redeemed: Boolean
  discount: DiscountDtoType
  from: DateTime
  to: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type IsCouponValidType {
  isValid: Boolean!
  coupon: CouponType
}

type PaginatedCouponType {
  count: Int
  isLast: Boolean
  objects: [CouponType!]!
}

type PurchaseType {
  id: ID!
  reference: String!
  externalId: String!
  notes: String
  status: PurchaseStatusEnum!
  installments: [InstallmentType!]!
  user: UserType!
  supplier: SupplierType!
  attachments: [DocumentType!]
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PurchaseStatusEnum {
  OPEN
  CANCELED
  CONFIRMED
  DELIVERED
}

type PaginatedPurchaseType {
  count: Int
  isLast: Boolean
  objects: [PurchaseType!]!
}

type RentalNoteType {
  return: String
  delivery: String
}

type RentalRefType {
  id: ID!
  location: String
  description: String
  start: DateTime!
  end: DateTime!
  status: RentalStatusEnum
  note: RentalNoteType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum RentalStatusEnum {
  RETURNED
  DELIVERED
  RETURNING
  DELIVERING
  READY_FOR_PICKUP
}

type CartProductType {
  barcode: BarcodeType
  quantity: Int!
  rent: RentalRefType
  taxValue: TaxValueType!
  price: ProductPriceType!
  priceCredit: PriceCreditType
}

type CartProductForTargetType {
  barcode: BarcodeForTargetType
  quantity: Int!
  taxValue: TaxValueType!
  price: ProductPriceType!
  priceCredit: PriceCreditType
}

type ValidatedCartProductType {
  barcode: BarcodeType
  quantity: Int!
  rent: RentalRefType
  taxValue: TaxValueType!
  price: ProductPriceType!
  priceCredit: PriceCreditType
  deliveryFees: String!
  mobileDelivery: Boolean!
  portalDelivery: Boolean!
  inDeliveryZone: Boolean!
  activateDelivery: Boolean!
  facebookDelivery: Boolean!
  mobilePickup: Boolean!
  portalPickup: Boolean!
  activatePickup: Boolean!
  facebookPickup: Boolean!
}

type ShoppingCartType {
  id: ID!
  user: UserType
  products: [CartProductType!]
  taxValue: ReduciblePriceType
  price: PriceFullType
  discount: DiscountDtoType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CalculatedShoppingCartType {
  user: UserType
  products: [CartProductType!]
  taxValue: ReduciblePriceType
  price: PriceFullType
  discount: DiscountDtoType
  target: TargetType
}

type ShoppingCartsType {
  id: ID!
  user: UserType
  taxValue: ReduciblePriceType
  price: PriceFullType
  discount: DiscountDtoType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
  products: [CartProductForTargetType!]
}

type ShoppingCartsForTargetType {
  id: ID!
  user: UserType
  taxValue: ReduciblePriceType
  price: PriceFullType
  discount: DiscountDtoType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
  products: [CartProductForTargetType!]
}

type ShoppingCartsForTargetPaginatedType {
  count: Int
  isLast: Boolean
  objects: [ShoppingCartsForTargetType!]!
}

type OrderSettingsType {
  id: ID!
  pickup: Boolean
  delivery: Boolean
  showMenuInPortal: Boolean
  pickupTime: TimeFromToType
  mobilePickup: Boolean
  portalPickup: Boolean
  facebookPickup: Boolean
  deliveryTime: TimeFromToType
  mobileDelivery: Boolean
  portalDelivery: Boolean
  facebookDelivery: Boolean
  nonDeliveryDays: [MonthDaysType!]
  nonPickupDays: [MonthDaysType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type OrderSettingsFullType {
  id: ID!
  pickup: Boolean
  delivery: Boolean
  showMenuInPortal: Boolean
  pickupTime: TimeFromToType
  mobilePickup: Boolean
  portalPickup: Boolean
  facebookPickup: Boolean
  deliveryTime: TimeFromToType
  mobileDelivery: Boolean
  portalDelivery: Boolean
  facebookDelivery: Boolean
  nonDeliveryDays: [MonthDaysType!]
  nonPickupDays: [MonthDaysType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type InvoiceType {
  id: ID
  number: String
  order: MarketPlaceOrderDtoType!
  month: Int
  year: Int
  sequence: Int
  status: InvoiceStatus
  target: TargetType
  description: String
  dueDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum InvoiceStatus {
  DRAFT
  ISSUED
  CANCELED
}

type InvoicePaginateType {
  count: Int
  isLast: Boolean
  objects: [InvoiceType!]!
}

type MarketplaceOrdersTypesCountType {
  PICKUP: Int!
  DELIVERY: Int!
  IN_HOUSE: Int!
  ORDER_AHEAD: Int!
}

type MarketplacePaymentMethodsCountType {
  CASH: Int!
  APP_COINS: Int!
}

type MarketplaceOrderByProductsMarketplaceOrderByStatusCountType {
  OPEN: Int!
  CANCELED: Int!
  CONFIRMED: Int!
  DELIVERED: Int!
}

type MarketplaceOrderByProductsMarketplaceOrderByPaymentStatusCountType {
  OPEN: Int!
  PAID: Int!
  CANCELED: Int!
}

type MarketPlaceOrdersCountType {
  total: Int!
  totalProducts: Int!
  orderTypes: MarketplaceOrdersTypesCountType!
  paymentMethods: MarketplacePaymentMethodsCountType!
  productsMarketplaceOrderByStatus: MarketplaceOrderByProductsMarketplaceOrderByStatusCountType!
  productsMarketplaceOrderByPaymentStatus: MarketplaceOrderByProductsMarketplaceOrderByPaymentStatusCountType!
}

type MarketPlaceOrderDashboardType {
  marketPlaceOrdersCount: MarketPlaceOrdersCountType!
}

type MarketPlaceOrderPaginateType {
  count: Int
  isLast: Boolean
  objects: [MarketPlaceOrderDtoType!]!
}

type DateStatsType {
  current: String!
  previous: String!
  percentage: String!
}

type PurchasesStatusesFinanceDashboardDataType {
  OPEN: String
  ASSIGNED: String
  CANCELED: String
  CONFIRMED: String
  DELIVERED: String
  READY_FOR_PICKUP: String
}

type PaymentMethodsFinanceDashboardDataType {
  CASH: Int
  CHECK: Int
  APP_COINS: Int
  CREDIT_CARD: Int
  BANK_TRANSFER: Int
  MOBILE_PAYMENT: Int
  AUTOMATIC_DEBIT: Int
  BILL_OF_EXCHANGE: Int
}

type PaymentMethodsStatsType {
  current: PaymentMethodsFinanceDashboardDataType!
  previous: PaymentMethodsFinanceDashboardDataType!
  percentage: PaymentMethodsFinanceDashboardDataType!
}

type GetEcommerceFinanceDashboardDataType {
  profits: String
  ordersCount: DateStatsType
  totalRevenu: DateStatsType
  suppliersCount: Int
  customersCount: DateStatsType
  openInstallments: String
  paidInstallments: String
  totalSpendings: DateStatsType
  cancelledOrdersCount: DateStatsType
  openInstallmentsDaily: [PeriodStatsType!]
  totalSpendingsDaily: [PeriodStatsType!]
  paidInstallmentsDaily: [PeriodStatsType!]
  ordersWeeklyCount: [PeriodStatsType!]
  customersWeeklyCount: [PeriodStatsType!]
  cancelledOrdersWeeklyCount: [PeriodStatsType!]
  paymentMethods: PaymentMethodsStatsType
  purchasesStatuses: PurchasesStatusesFinanceDashboardDataType
}

type GetMenuBadgesType {
  targetOutOFStockItemsCount: Int
  unreadMessagesCount: Int
  unpaidInvoiceCount: Int
  uncompletedTasksCount: Int
  internalProductsCount: Int
  allCorporateUsersCount: Int
  onlineCorporateUsersCount: Int
}

type NewsletterType {
  id: ID!
  target: TargetType!
  email: String!
  user: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedNewslettersType {
  count: Int
  isLast: Boolean
  objects: [NewsletterType!]!
}

type TargetPluginType {
  id: ID!
  plugin: PluginType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LogisticTrackerType {
  status: LogisticStatus
  date: DateTime!
}

enum LogisticStatus {
  PLACED
  PACKED
  OUT_FOR_DELIVERY
  DELIVERED
}

type LogisticType {
  id: ID!
  identifier: String!
  company: CompanyType
  driver: UserType
  tracker: [LogisticTrackerType!]
  warehouse: WarehouseType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectMemberType {
  member: UserType
  role: ProjectRoleEnum
}

enum ProjectRoleEnum {
  LEAD
  MEMBER
}

type BoardCardsStatsType {
  total: Int!
  archived: Int!
}

type ProjectType {
  id: ID!
  name: String
  description: String
  media: MediaType
  privacy: ProjectPrivacyEnum
  tags: [String!]
  deadline: DateTime
  priority: ProjectPriorityEnum
  status: ProjectStatusEnum
  color: String
  picture: PictureType
  externalId: String
  members: [ProjectMemberType!]
  resources: [DocumentType!]
  attachments: [DocumentType!]
  target: TargetType
  boardCardsStats: BoardCardsStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProjectPrivacyEnum {
  PRIVATE
  PUBLIC
}

enum ProjectPriorityEnum {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum ProjectStatusEnum {
  ACTIVE
  DELIVERED
  BLOCKED
  CANCELLED
}

type ProjectPaginateType {
  count: Int
  isLast: Boolean
  objects: [ProjectType!]!
}

type KeyValueType {
  key: String
  value: String
}

type InvoicingProductsType {
  id: ID!
  article: BarcodeType
  label: String
  description: String
  price: String
  total: String
  taxes: [ProductTaxesType!]
  quantity: Int
  discount: DiscountDtoType
  rent: RentalRefType
}

type InvoicingProductsBundleType {
  product: InvoicingProductsType
  text: String
  value: String
  rank: String!
  kind: ProductKindEnum!
}

enum ProductKindEnum {
  PRODUCT
  TEXT
  SECTION
  SEPARATOR
  SUBTOTAL
}

type InvoicingAddressType {
  billing: FullAddressType
  shipping: FullAddressType
}

type InvoicingPriceType {
  net: String
  gross: String
}

type TotalPriceType {
  net: String
  gross: String
}

type InvoicingPricesCalculationType {
  totalPrice: TotalPriceType
  toPay: String
  totalTax: String
}

type taxRankType {
  tax: TaxType
  rank: String
}

type RentalInvoicingType {
  id: ID!
  number: String!
  description: String
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  toPay: String
  logistic: LogisticType
  project: ProjectType
  date: DateTime
}

enum GenericInvoicingStatusEnum {
  DRAFT
  OPEN
  ISSUED
  NEGOCIATION
  CONFIRMED
  DELIVERED
  CANCELED
}

type RentalInvoicingProductsType {
  id: ID!
  article: BarcodeType
  label: String
  description: String
  price: String
  total: String
  quantity: Int
  discount: DiscountDtoType
}

type RentalType {
  id: ID!
  location: String
  description: String
  start: DateTime!
  end: DateTime!
  status: RentalStatusEnum
  note: RentalNoteType
  createdAt: DateTime!
  updatedAt: DateTime!
  product: RentalInvoicingProductsType
  order: RentalInvoicingType
  invoice: RentalInvoicingType
  deliveryNote: RentalInvoicingType
}

type RentalPaginateType {
  count: Int
  isLast: Boolean
  objects: [RentalType!]!
}

type SaleCustomerType {
  customer: CompanyType
  details: [KeyValueType!]
}

type SaleDeliveryNoteOriginType {
  quotation: QuotationType
  order: SaleOrderType
}

type SaleDeliveryNoteType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  origin: SaleDeliveryNoteOriginType
  warehouse: WarehouseType
}

type SaleDeliveryNotePaginateType {
  count: Int
  isLast: Boolean
  objects: [SaleDeliveryNoteType!]!
}

type QuotationConversionType {
  order: SaleOrderType
  deliveryNote: SaleDeliveryNoteType
  invoice: SaleInvoiceType
}

type QuotationType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  conversion: QuotationConversionType
}

type QuotationPaginateType {
  count: Int
  isLast: Boolean
  objects: [QuotationType!]!
}

type QuotationsStatsType {
  OPEN: CurrentPreviousType!
  NEGOCIATION: CurrentPreviousType!
  CONFIRMED: CurrentPreviousType!
  CANCELED: CurrentPreviousType!
}

type SaleInvoiceOriginType {
  quotation: QuotationType
  order: SaleOrderType
}

type SaleInvoiceType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  origin: SaleInvoiceOriginType
}

type BarcodeStatsType {
  numberOfOrders: Int!
  totalRevenue: String!
}

type SaleInvoicePaginateType {
  count: Int
  isLast: Boolean
  objects: [SaleInvoiceType!]!
}

type SaleInvoicesStatsType {
  DRAFT: CurrentPreviousType!
  ISSUED: CurrentPreviousType!
  CANCELED: CurrentPreviousType!
  DELIVERED: CurrentPreviousType!
}

type SaleOrderConversionType {
  deliveryNote: SaleDeliveryNoteType
  invoice: SaleInvoiceType
}

type SaleOrderOriginType {
  quotation: QuotationType
}

type SaleOrderType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  conversion: SaleOrderConversionType
  origin: SaleOrderOriginType
}

type SaleOrderPaginateType {
  count: Int
  isLast: Boolean
  objects: [SaleOrderType!]!
}

type SaleOrdersStatsType {
  OPEN: CurrentPreviousType!
  DRAFT: CurrentPreviousType!
  CANCELED: CurrentPreviousType!
  CONFIRMED: CurrentPreviousType!
}

type SaleIssueNoteType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
}

type SaleIssueNotePaginateType {
  count: Int
  isLast: Boolean
  objects: [SaleIssueNoteType!]!
}

type SaleIssueNoteStatsType {
  OPEN: CurrentPreviousType!
  DRAFT: CurrentPreviousType!
  CANCELED: CurrentPreviousType!
  DELIVERED: CurrentPreviousType!
}

type PurchaseSupplierType {
  supplier: CompanyType
  details: [KeyValueType!]
}

type PurchaseDeliveryNoteOriginType {
  order: PurchaseOrderType
}

type PurchaseDeliveryNoteType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  supplier: PurchaseSupplierType
  origin: PurchaseDeliveryNoteOriginType
  warehouse: WarehouseType
}

type PurchaseDeliveryNotePaginateType {
  count: Int
  isLast: Boolean
  objects: [PurchaseDeliveryNoteType!]!
}

type PurchaseInvoiceOriginType {
  order: PurchaseOrderType
}

type PurchaseInvoiceType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  supplier: PurchaseSupplierType
  origin: PurchaseInvoiceOriginType
}

type PurchaseInvoicePaginateType {
  count: Int
  isLast: Boolean
  objects: [PurchaseInvoiceType!]!
}

type PurchaseOrderConversionType {
  deliveryNote: PurchaseDeliveryNoteType
  invoice: PurchaseInvoiceType
}

type PurchaseOrderType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  supplier: PurchaseSupplierType
  conversion: PurchaseOrderConversionType
}

type PurchaseOrderPaginateType {
  count: Int
  isLast: Boolean
  objects: [PurchaseOrderType!]!
}

type GoogleAuthRedirectType {
  url: String
}

type GoogleSuccessType {
  success: String!
}

type GoogleColorType {
  textColor: String!
  backgroundColor: String!
}

type GmailLabelType {
  id: String
  name: String
  messageListVisibility: MessageListVisibilityEnum
  labelListVisibility: LabelListVisibilityEnum
  messagesTotal: Int
  messagesUnread: Int
  threadsTotal: Int
  threadsUnread: Int
  color: GoogleColorType
}

enum MessageListVisibilityEnum {
  show
  hide
}

enum LabelListVisibilityEnum {
  labelShow
  labelShowIfUnread
  labelHide
}

type GmailHeaderType {
  name: String
  value: String
}

type GmailMessagePartBodyType {
  size: Int
  data: String
}

type GmailMessagePartType {
  partId: String
  mimeType: String
  filename: String
  headers: [GmailHeaderType!]
  body: GmailMessagePartBodyType
  parts: [GmailMessagePartType!]
}

type GmailMessageType {
  id: String
  threadId: String
  labelIds: [String!]
  snippet: String
  historyId: String
  internalDate: String
  payload: GmailMessagePartType
  sizeEstimate: Int
  raw: String
}

type GmailMessageListType {
  messages: [GmailMessageType!]
  nextPageToken: String
  resultSizeEstimate: Int
}

type GmailDraftType {
  id: String
  message: GmailMessageType
}

type GmailDraftListType {
  drafts: [GmailDraftType!]
  nextPageToken: String
  resultSizeEstimate: Int
}

type GmailThreadType {
  id: String
  snippet: String
  historyId: String
  messages: [GmailMessageType!]
}

type GmailThreadListType {
  threads: [GmailThreadType!]
  nextPageToken: String
  resultSizeEstimate: Int
}

type GmailProfileType {
  emailAddress: String
  messagesTotal: Int
  threadsTotal: Int
  historyId: String
}

type GoogleDriveAboutUserType {
  kind: String
  displayName: String
  photoLink: String
  me: Boolean
  permissionId: String
  emailAddress: String
}

type GoogleDriveAboutStorageQuotaType {
  limit: String
  usage: String
  usageInDrive: String
  usageInDriveTrash: String
}

type GoogleDriveAboutTeamDriveThemesType {
  id: String
  backgroundImageLink: String
  colorRgb: String
}

type GoogleDriveAboutType {
  kind: String!
  user: GoogleDriveAboutUserType
  storageQuota: GoogleDriveAboutStorageQuotaType
  maxUploadSize: String!
  appInstalled: Boolean!
  folderColorPalette: [String!]
  teamDriveThemes: [GoogleDriveAboutTeamDriveThemesType!]
  driveThemes: [GoogleDriveAboutTeamDriveThemesType!]
  canCreateTeamDrives: Boolean!
  canCreateDrives: Boolean!
}

type GoogleDriveAboutChangesTokenType {
  kind: String
  startPageToken: String
}

type GoogleDriveFileCapabilitiesType {
  canAddChildren: Boolean
  canAddFolderFromAnotherDrive: Boolean
  canAddMyDriveParent: Boolean
  canChangeCopyRequiresWriterPermission: Boolean
  canChangeSecurityUpdateEnabled: Boolean
  canChangeViewersCanCopyContent: Boolean
  canComment: Boolean
  canCopy: Boolean
  canDelete: Boolean
  canDeleteChildren: Boolean
  canDownload: Boolean
  canEdit: Boolean
  canListChildren: Boolean
  canModifyContent: Boolean
  canModifyContentRestriction: Boolean
  canMoveChildrenOutOfTeamDrive: Boolean
  canMoveChildrenOutOfDrive: Boolean
  canMoveChildrenWithinTeamDrive: Boolean
  canMoveChildrenWithinDrive: Boolean
  canMoveItemIntoTeamDrive: Boolean
  canMoveItemOutOfTeamDrive: Boolean
  canMoveItemOutOfDrive: Boolean
  canMoveItemWithinTeamDrive: Boolean
  canMoveItemWithinDrive: Boolean
  canMoveTeamDriveItem: Boolean
  canReadRevisions: Boolean
  canReadTeamDrive: Boolean
  canReadDrive: Boolean
  canRemoveChildren: Boolean
  canRemoveMyDriveParent: Boolean
  canRename: Boolean
  canShare: Boolean
  canTrash: Boolean
  canTrashChildren: Boolean
  canUntrash: Boolean
}

type GoogleDriveTeamDrivePermissionDetailsType {
  teamDrivePermissionType: String
  role: String
  inheritedFrom: String
  inherited: Boolean
}

type GoogleDriveThumbnailType {
  image: String
  mimeType: String
}

type GoogleDriveContentHintsType {
  thumbnail: GoogleDriveThumbnailType
  indexableText: String
}

type GoogleDriveLocationType {
  latitude: Float
  longitude: Float
  altitude: Float
}

type GoogleDriveShortcutDetailsType {
  targetId: String
  targetMimeType: String
  targetResourceKey: String
}

type GoogleDriveLinkShareMetadataType {
  securityUpdateEligible: Boolean
  securityUpdateEnabled: Boolean
}

type GoogleDriveContentRestrictionsType {
  readOnly: Boolean
  reason: String
  restrictingUser: GoogleDriveAboutUserType
  restrictionTime: String
  type: String
}

type GoogleDriveImageMediaMetaDataType {
  width: Int
  height: Int
  rotation: Int
  location: GoogleDriveLocationType
  time: String
  cameraMake: String
  cameraModel: String
  exposureTime: Float
  aperture: Float
  flashUsed: Boolean
  focalLength: Float
  isoSpeed: Int
  meteringMode: String
  sensor: String
  exposureMode: String
  colorSpace: String
  whiteBalance: String
  exposureBias: Float
  maxApertureValue: Float
  subjectDistance: Int
  lens: String
}

type GoogleDriveFilePermissionsType {
  kind: String
  id: String
  type: String
  emailAddress: String
  domain: String
  role: String
  view: String
  allowFileDiscovery: Boolean
  displayName: String
  photoLink: String
  expirationTime: String
  teamDrivePermissionDetails: [GoogleDriveTeamDrivePermissionDetailsType!]
  permissionDetails: [GoogleDriveTeamDrivePermissionDetailsType!]
  deleted: Boolean
}

type GoogleDriveFileResourceType {
  kind: String
  id: String
  name: String
  mimeType: String
  description: String
  starred: Boolean
  trashed: Boolean
  explicitlyTrashed: Boolean
  trashingUser: GoogleDriveAboutUserType
  trashedTime: String
  spaces: [String!]
  webContentLink: String
  webViewLink: String
  iconLink: String
  hasThumbnail: Boolean
  thumbnailLink: String
  viewedByMe: Boolean
  viewedByMeTime: String
  createdTime: String
  modifiedTime: String
  modifiedByMeTime: String
  modifiedByMe: Boolean
  sharedWithMeTime: String
  sharingUser: GoogleDriveAboutUserType
  owners: [GoogleDriveAboutUserType!]
  teamDriveId: String
  driveId: String
  lastModifyingUser: GoogleDriveAboutUserType
  shared: Boolean
  ownedByMe: Boolean
  capabilities: GoogleDriveFileCapabilitiesType
  viewersCanCopyContent: Boolean
  copyRequiresWriterPermission: Boolean
  writersCanShare: Boolean
  permissions: [GoogleDriveFilePermissionsType!]
  permissionIds: [String!]
  hasAugmentedPermissions: Boolean
  folderColorRgb: String
  originalFilename: String
  fullFileExtension: String
  fileExtension: String
  md5Checksum: String
  headRevisionId: String
  contentHints: GoogleDriveContentHintsType
  imageMediaMetadata: GoogleDriveImageMediaMetaDataType
  isAppAuthorized: Boolean
  shortcutDetails: GoogleDriveShortcutDetailsType
  contentRestrictions: [GoogleDriveContentRestrictionsType!]
  resourceKey: String
  linkShareMetadata: GoogleDriveLinkShareMetadataType
}

type GoogleDriveBackgroundImageFileType {
  id: String
  xCoordinate: Float
  yCoordinate: Float
  width: Float
}

type GoogleDriveRestrictionsType {
  adminManagedRestrictions: Boolean
  copyRequiresWriterPermission: Boolean
  domainUsersOnly: Boolean
  driveMembersOnly: Boolean
}

type GoogleDriveTeamDriveResourceType {
  kind: String
  id: String
  name: String
  themeId: String
  colorRgb: String
  backgroundImageFile: GoogleDriveBackgroundImageFileType
  capabilities: GoogleDriveFileCapabilitiesType
  createdTime: String
  hidden: Boolean
  restrictions: GoogleDriveRestrictionsType
}

type GoogleDriveAboutChangesResourceType {
  kind: String
  type: String
  changeType: String
  time: String
  removed: Boolean
  fileId: String
  file: GoogleDriveFileResourceType
  teamDriveId: String
  driveId: String
  teamDrive: GoogleDriveTeamDriveResourceType
  drive: GoogleDriveTeamDriveResourceType
}

type GoogleDriveChangesListType {
  kind: String
  nextPageToken: String
  newStartPageToken: String
  changes: [GoogleDriveAboutChangesResourceType!]
}

type GoogleCalendarDefaultReminderType {
  method: String!
  minutes: Int
}

type GoogleCalendarNotificationSettingsType {
  notifications: [GoogleCalendarNotificationSettingsNotificationType!]!
}

type GoogleCalendarNotificationSettingsNotificationType {
  type: String!
  method: String!
}

type GoogleCalendarConferencePropertiesType {
  allowedConferenceSolutionTypes: [String!]!
}

type GoogleCalendarListResourceType {
  kind: String!
  etag: String
  id: String
  summary: String
  description: String
  location: String
  timeZone: String
  summaryOverride: String
  colorId: String
  backgroundColor: String
  foregroundColor: String
  hidden: Boolean
  selected: Boolean
  accessRole: String
  defaultReminders: [GoogleCalendarDefaultReminderType!]
  notificationSettings: GoogleCalendarNotificationSettingsType
  primary: Boolean
  deleted: Boolean
  conferenceProperties: GoogleCalendarConferencePropertiesType
}

type GoogleCalendarListType {
  kind: String!
  etag: String
  nextPageToken: String
  nextSyncToken: String
  items: [GoogleCalendarListResourceType!]
}

type GoogleCalendarResourceType {
  kind: String!
  etag: String
  id: String
  summary: String
  description: String
  location: String
  timeZone: String
  conferenceProperties: GoogleCalendarConferencePropertiesType
}

type GoogleCalendarBackForType {
  background: String!
  foreground: String
}

type GoogleCalendarEventCreatorType {
  id: String
  email: String
  displayName: String
  self: Boolean
}

type GoogleCalendarEventStartEndType {
  date: String
  dateTime: String
  timeZone: String
}

type GoogleCalendarEventAttendeeType {
  id: String
  email: String
  displayName: String
  organizer: Boolean
  self: Boolean
  resource: Boolean
  optional: Boolean
  responseStatus: String
  comment: String
  additionalGuests: Int
}

type GoogleCalendarEventConferenceDataCreateRequestSolutionKeyType {
  type: String
}

type GoogleCalendarEventConferenceDataCreateRequesStatusType {
  statusCode: String
}

type GoogleCalendarEventConferenceDataCreateRequestType {
  requestId: String
  conferenceSolutionKey: GoogleCalendarEventConferenceDataCreateRequestSolutionKeyType
  status: GoogleCalendarEventConferenceDataCreateRequesStatusType
}

type GoogleCalendarEventConferenceDataEntryPointsType {
  entryPointType: String
  uri: String
  label: String
  pin: String
  accessCode: String
  meetingCode: String
  passcode: String
  password: String
}

type GoogleCalendarEventConferenceDataConferenceSolutionKeyType {
  type: String
}

type GoogleCalendarEventConferenceDataConferenceSolutionType {
  key: GoogleCalendarEventConferenceDataConferenceSolutionKeyType
  name: String
  iconUri: String
}

type GoogleCalendarEventConferenceDataType {
  createRequest: GoogleCalendarEventConferenceDataCreateRequestType
  entryPoints: [GoogleCalendarEventConferenceDataEntryPointsType!]
  conferenceSolution: GoogleCalendarEventConferenceDataConferenceSolutionType
  conferenceId: String
  signature: String
  notes: String
}

type GoogleCalendarEventGadgetType {
  type: String
  title: String
  link: String
  iconLink: String
  width: Int
  height: Int
  display: String
}

type GoogleCalendarEventReminderOverridesType {
  method: String
  minutes: Float
}

type GoogleCalendarEventReminderType {
  useDefault: Boolean
  overrides: GoogleCalendarEventReminderOverridesType
}

type GoogleCalendarEventSourceType {
  url: String
  title: String
}

type GoogleCalendarEventAttachmentType {
  fileUrl: String
  title: String
  mimeType: String
  iconLink: String
  fileId: String
}

type GoogleCalendarEventType {
  kind: String
  etag: String
  id: String
  status: String
  htmlLink: String
  created: String
  updated: String
  summary: String
  description: String
  location: String
  colorId: String
  creator: GoogleCalendarEventCreatorType
  organizer: GoogleCalendarEventCreatorType
  start: GoogleCalendarEventStartEndType
  end: GoogleCalendarEventStartEndType
  endTimeUnspecified: Boolean
  recurrence: [String!]
  recurringEventId: String
  originalStartTime: GoogleCalendarEventStartEndType
  transparency: String
  visibility: String
  iCalUID: String
  sequence: Int
  attendees: [GoogleCalendarEventAttendeeType!]
  attendeesOmitted: Boolean
  hangoutLink: String
  conferenceData: GoogleCalendarEventConferenceDataType
  gadget: GoogleCalendarEventGadgetType
  anyoneCanAddSelf: Boolean
  guestsCanInviteOthers: Boolean
  guestsCanModify: Boolean
  guestsCanSeeOtherGuests: Boolean
  privateCopy: Boolean
  locked: Boolean
  reminders: GoogleCalendarEventReminderType
  source: GoogleCalendarEventSourceType
  attachments: [GoogleCalendarEventAttachmentType!]
  eventType: String
}

type GoogleCalendarEventInstancesType {
  kind: String
  etag: String
  summary: String
  description: String
  updated: String
  timeZone: String
  accessRole: String
  defaultReminders: [GoogleCalendarDefaultReminderType!]
  nextPageToken: String
  nextSyncToken: String
  items: [GoogleCalendarEventType!]
}

type GoogleCalendarEventWatchType {
  kind: String
  id: String
  resourceId: String
  resourceUri: String
  token: String
  expiration: String
}

type GoogleCalendarFreeBusyType {
  kind: String
  timeMin: String
  timeMax: String
}

type GoogleCalendarSettingsType {
  kind: String
  etag: String
  id: String
  value: String
}

type SmsIntegrationType {
  messageId: String!
  statusMobile: String!
  statusMsg: String!
  statusCode: String!
}

type SmsLogType {
  id: ID!
  phone: IPhoneType
  validationNumber: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SEOAuditDataType {
  url: String
  title: String
  isLoaded: Boolean
  isGoogleAnalyticsObject: Boolean
  isGoogleAnalyticsFunc: Boolean
  isCharacterEncode: Boolean
  isMetaDescription: Boolean
  metaDescription: String
  isMetaDescriptionEnoughLong: Boolean
  isDoctype: Boolean
  isTitle: Boolean
  isTitleEnoughLong: Boolean
  isH1: Boolean
  h1: String
  isH1OnlyOne: Boolean
  isH2: Boolean
  linksCount: Int
  isTooEnoughLinks: Boolean
  internalNoFollowLinks: [String!]
  internalNoFollowLinksCount: Int
  notOptimizedImages: [String!]
  notOptimizedImagesCount: Int
  wordsCount: Int
  isContentEnoughLong: Boolean
  isViewport: Boolean
  isAmp: Boolean
  isNotIframe: Boolean
  pageIsBlocked: Boolean
  robotsFileExists: Boolean
  faviconExists: Boolean
  brokenLinksCount: Int
  brokenLinks: [String!]
  externalBrokenLinksCount: Int
  externalBrokenLinks: [String!]
  brokenImages: [String!]
  brokenImagesCount: Int
}

type SEOAuditType {
  id: ID
  data: [SEOAuditDataType!]!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InstagramProfileAuditDataLatestType {
  id: String
  type: String
  shortCode: String
  caption: String
  hashtags: [String!]
  mentions: [String!]
  url: String
  commentsCount: Float
  firstComment: String
  latestComments: [String!]
  dimensionsHeight: Float
  dimensionsWidth: Float
  displayUrl: String
  images: [String!]
  alt: String
  likesCount: Float
  timestamp: DateTime
  childPosts: [String!]
  ownerUsername: String
  ownerId: String
}

type InstagramProfileAuditDataIVGType {
  type: String
  shortCode: String
  title: String
  caption: String
  commentsCount: Float
  commentsDisabled: Boolean
  dimensionsHeight: Float
  dimensionsWidth: Float
  displayUrl: String
  likesCount: Float
  videoDuration: Float
  videoViewCount: Float
}

type InstagramProfileAuditDataType {
  id: String
  username: String
  fullName: String
  biography: String
  externalUrl: String
  externalUrlShimmed: String
  followersCount: Float
  followsCount: Float
  hasChannel: Boolean
  highlightReelCount: Float
  isBusinessAccount: Boolean
  joinedRecently: Boolean
  businessCategoryName: String
  private: Boolean
  verified: Boolean
  profilePicUrl: String
  profilePicUrlHD: String
  facebookPage: String
  igtvVideoCount: Float
  relatedProfiles: [String!]
  latestIgtvVideos: [InstagramProfileAuditDataIVGType!]
  postsCount: Float
  latestPosts: [InstagramProfileAuditDataLatestType!]
}

type InstagramProfileAuditType {
  id: ID
  data: [InstagramProfileAuditDataType!]!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FacebookProfileAuditMenuImagesPhotosOwnerType {
  id: String
  user_id: String
  additional_profile_has_taggable_products: Boolean
}

type FacebookProfileAuditMenuImagesPhotosImageType {
  uri: String
  width: Float
  height: Float
}

type FacebookProfileAuditMenuImagesPhotosType {
  id: String
  timestamp: Float
  ocrText: String
  image: FacebookProfileAuditMenuImagesPhotosImageType
  likes: Float
  isPlayable: Boolean
  owner: FacebookProfileAuditMenuImagesPhotosOwnerType
}

type FacebookProfileAuditMenuImagesType {
  id: String
  menu_image_title: String
  menu_photo: FacebookProfileAuditMenuImagesPhotosType
}

type FacebookProfileAuditMenuType {
  id: String
  share_page_menu_link: String
  structured_menu_program: String
  images: [FacebookProfileAuditMenuImagesType!]
}

type FacebookProfileAuditDeliverySettingsType {
  delivery_details: String
  id: String
}

type FacebookProfileAuditReviewUserType {
  id: String
  name: String
  profileUrl: String
  profilePic: String
}

type FacebookProfileAuditReviewType {
  id: String
  legacyId: String
  user: FacebookProfileAuditReviewUserType
  date: String
  url: String
  text: String
  likesCount: Float
  commentsCount: Float
}

type FacebookProfilePostsStatsType {
  likes: Float
  comments: Float
  shares: Float
}

type FacebookProfilePostsCommentsType {
  count: Float
}

type FacebookProfilePostsType {
  postDate: DateTime
  postText: String
  postsImages: [String!]
  postLinks: [String!]
  postUrl: String
  postStats: FacebookProfilePostsStatsType
  postComments: FacebookProfilePostsCommentsType
  postId: String
  timestamp: Float
  alt: String
}

type FacebookProfileAuditDataType {
  categories: [String!]
  info: [String!]
  likes: Float
  messenger: String
  posts: [FacebookProfilePostsType!]
  priceRange: String
  title: String
  pageUrl: String
  address: String
  payment: String
  pageId: String
  pageName: String
  phone: String
  email: String
  website: String
  services: String
  rating: String
  wifi: String
  reviews: [FacebookProfileAuditReviewType!]
  delivery_settings: FacebookProfileAuditDeliverySettingsType
  formatted_cuisines: String
  delivery_options: String
  menu: FacebookProfileAuditMenuType
  is_delegate_page_with_linked_profile: Boolean
  name: String
  impressum: [String!]
  instagram: String
  products: [String!]
  transit: String
  twitter: String
  youtube: String
  mission: [String!]
  overview: [String!]
  checkins: String
  verified: Boolean
}

type GoogleMapsAuditConfigType {
  id: ID
  searchStringsArray: [String!]
  countryCode: GoogleAuditCountryCodeEnum
  city: String
  language: GoogleAuditLanguageCodeEnum
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GoogleAuditCountryCodeEnum {
  af
  al
  dz
  as
  ad
  ao
  ai
  aq
  ag
  ar
  aw
  au
  at
  az
  bs
  bh
  bd
  bb
  by
  be
  bz
  bj
  bm
  bt
  bo
  ba
  bw
  bv
  br
  io
  bn
  bg
  bf
  bi
  kh
  cm
  ca
  cv
  ky
  cf
  td
  cl
  cn
  cx
  cc
  co
  km
  cg
  cd
  ck
  cr
  ci
  hr
  cu
  cy
  cz
  dk
  dj
  dm
  do
  ec
  eg
  sv
  gq
  er
  ee
  et
  fk
  fo
  fj
  fi
  fr
  gf
  pf
  tf
  ga
  gm
  ge
  de
  gh
  gi
  gr
  gl
  gd
  gp
  gu
  gt
  gn
  gw
  gy
  ht
  hm
  va
  hn
  hk
  hu
  is
  in
  id
  ir
  iq
  ie
  il
  it
  jm
  jp
  jo
  kz
  ke
  ki
  kp
  kr
  kw
  kg
  la
  lv
  lb
  ls
  lr
  ly
  li
  lt
  lu
  mo
  mk
  mg
  mw
  my
  mv
  ml
  mt
  mh
  mq
  mr
  mu
  yt
  mx
  fm
  md
  mc
  mn
  ms
  ma
  mz
  mm
  na
  nr
  np
  nl
  an
  nc
  nz
  ni
  ne
  ng
  nu
  nf
  mp
  no
  om
  pk
  pw
  ps
  pa
  pg
  py
  pe
  ph
  pn
  pl
  pt
  pr
  qa
  re
  ro
  ru
  rw
  sh
  kn
  lc
  pm
  vc
  ws
  sm
  st
  sa
  sn
  cs
  sc
  sl
  sg
  sk
  si
  sb
  so
  za
  gs
  es
  lk
  sd
  sr
  sj
  sz
  se
  ch
  sy
  tw
  tj
  tz
  th
  tl
  tg
  tk
  to
  tt
  TUNISIA
  tr
  tm
  tc
  tv
  ug
  ua
  ae
  gb
  us
  um
  uy
  uz
  vu
  ve
  vn
  vg
  vi
  wf
  eh
  ye
  zm
  zw
}

enum GoogleAuditLanguageCodeEnum {
  af
  sq
  sm
  ARABIC
  az
  eu
  be
  bn
  bh
  bs
  bg
  ca
  zhCN
  zhTW
  hr
  cs
  da
  nl
  ENGLISH
  eo
  et
  fo
  fi
  FRENCH
  fy
  gl
  ka
  GERMAN
  el
  gu
  iw
  hi
  hu
  is
  id
  ia
  ga
  ITALIAN
  ja
  jw
  kn
  ko
  la
  lv
  lt
  mk
  ms
  ml
  mt
  mr
  ne
  no
  nn
  oc
  fa
  pl
  ptBR
  ptPT
  pa
  ro
  ru
  gd
  sr
  si
  sk
  sl
  SPANISH
  su
  sw
  sv
  tl
  ta
  te
  th
  ti
  tr
  uk
  ur
  uz
  vi
  cy
  xh
  zu
}

type GoogleSearchAuditDataDebugType {
  requestId: String
  url: String
  method: String
  retryCount: Float
  errorMessages: [String!]
  statusCode: Float
  durationSecs: Float
}

type GoogleSearchAuditDataSearchQueryType {
  term: String
  device: String
  page: Float
  type: String
  domain: String
  countryCode: String
  languageCode: String
  locationUule: String
  resultsPerPage: String
}

type GoogleSearchAuditDataRelatedQueriesType {
  title: String
  url: String
}

type GoogleSearchAuditDataResultsProductType {
  price: String
  rating: Float
  numberOfReviews: Float
}

type GoogleSearchAuditDataSiteLinksType {
  title: String
  description: String
}

type GoogleSearchAuditDataResultsType {
  title: String
  url: String
  displayedUrl: String
  description: String
  emphasizedKeywords: [String!]
  siteLinks: [GoogleSearchAuditDataSiteLinksType!]
  productInfo: GoogleSearchAuditDataResultsProductType
}

type GoogleSearchAuditDataCustomDataType {
  pageTitle: String
}

type GoogleSearchAuditDataType {
  debug: GoogleSearchAuditDataDebugType
  error: Boolean
  searchQuery: GoogleSearchAuditDataSearchQueryType
  url: String
  hasNextPage: Boolean
  serpProviderCode: String
  resultsTotal: Float
  relatedQueries: [GoogleSearchAuditDataRelatedQueriesType!]
  paidResults: [GoogleSearchAuditDataResultsType!]
  paidProducts: [GoogleSearchAuditDataResultsType!]
  organicResults: [GoogleSearchAuditDataResultsType!]
  customData: GoogleSearchAuditDataCustomDataType
  htmlSnapshotUrl: String
}

type GoogleSearchAuditType {
  id: ID
  data: [GoogleSearchAuditDataType!]!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GoogleSearchAuditConfigType {
  id: ID
  queries: [String!]
  countryCode: GoogleAuditCountryCodeEnum
  languageCode: GoogleAuditLanguageCodeEnum
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GoogleAnalyticsEventType {
  event: GARecommendedEventsEnum!
  active: Boolean!
}

enum GARecommendedEventsEnum {
  LOGIN
  SIGN_UP
  SEARCH
  SHARE
  EARN_VIRTUAL_CURRENCY
  SPEND_VIRTUAL_CURRENCY
  ADD_PAYMENT_INFO
  ADD_SHIPPING_INFO
  ADD_TO_CART
  ADD_TO_WISHLIST
  BEGIN_CHECKOUT
  GENERATE_LEAD
  PURCHASE
  REFUND
  REMOVE_FROM_CART
  SELECT_ITEM
  SELECT_PROMOTION
  VIEW_CART
  VIEW_ITEM
  VIEW_PROMOTION
}

type GoogleAnalyticsType {
  id: ID!
  googleTagId: String!
  active: Boolean!
  events: [GoogleAnalyticsEventType!]!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FBPixelEventType {
  event: PixelRecommendedEventsEnum!
  active: Boolean!
}

enum PixelRecommendedEventsEnum {
  ADD_PAYMENT_INFO
  ADD_TO_CART
  ADD_TO_WISHLIST
  COMPLETE_REGISTRATION
  CONTACT
  FIND_LOCATION
  INITIATE_CHECKOUT
  LEAD
  PURCHASE
  SCHEDULE
  SEARCH
  START_TRIAL
  SUBSCRIBE
  VIEW_CONTENT
}

type FBPixelType {
  id: ID!
  pixelId: String!
  active: Boolean!
  events: [FBPixelEventType!]!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FBCatalogSyncAttributesType {
  active: Boolean!
  color: Boolean!
  gender: Boolean!
  size: Boolean!
  ageGroup: Boolean!
  material: Boolean!
  pattern: Boolean!
}

type FBCatalogSyncShippingType {
  active: Boolean!
  country: CountryType
  service: String
  price: String
}

type FBCatalogSyncType {
  id: ID!
  sell: Boolean
  googleCategory: Boolean
  fbCategory: Boolean
  sale: Boolean
  attributes: FBCatalogSyncAttributesType
  shipping: FBCatalogSyncShippingType
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FigamyIntegrationAuthType {
  publicKey: String
  secretKey: String
}

type FigamyIntegrationAuthenticationLoginType {
  active: Boolean!
}

type FigamyIntegrationAuthenticationType {
  active: Boolean!
  appAuth: FigamyIntegrationAuthType
  figamyAuth: FigamyIntegrationAuthType
  login: FigamyIntegrationAuthenticationLoginType
}

type FigamyIntegrationWalletReputationType {
  active: Boolean!
  inactivityCycle: Boolean!
  lossAmount: Boolean!
  perks: Boolean!
}

type FigamyIntegrationWalletType {
  active: Boolean!
  quantitative: FigamyIntegrationAuthenticationLoginType
  qualitative: FigamyIntegrationAuthenticationLoginType
  reputation: FigamyIntegrationWalletReputationType
}

type FigamyIntegrationCatalogType {
  active: Boolean!
  auth: FigamyIntegrationAuthType
  syncTime: RecurrenceType
  sell: Boolean!
  sale: Boolean!
  shipping: Boolean!
}

type FigamyIntegrationDealsType {
  active: Boolean!
  monthlyAmount: String
  selfManaging: Boolean!
}

type FigamyIntegratioConverterType {
  active: Boolean!
  rate: String
}

type FigamyIntegratioMarketplaceType {
  active: Boolean
  paymentCycle: RecurrenceType
  comission: String
}

type FigamyIntegrationType {
  id: ID!
  authentication: FigamyIntegrationAuthenticationType
  wallet: FigamyIntegrationWalletType
  catalog: FigamyIntegrationCatalogType
  deals: FigamyIntegrationDealsType
  converter: FigamyIntegratioConverterType
  marketplace: FigamyIntegratioMarketplaceType
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TopChartCategoryItemType {
  key: String!
  value: String!
  cron: Boolean!
}

type TopChartGenreType {
  id: ID!
  platform: ChartPlatformEnum!
  category: TopChartCategoryItemType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ChartPlatformEnum {
  IPHONE
  IPAD
  IOS
  ANDROID
  AMAZON
}

type AppFollowTopChartType {
  id: ID!
  date: DateTime
  country: String!
  genre: TopChartGenreType
  leaderboard: [TopChartLeaderboardType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TopChartLeaderboardType {
  pos_diff: Float
  device: String
  genre_id: String
  icon: String
  country: String
  rating_avg: String
  feed_type: String
  price: String
  ext_id: String
  pos_curr: Float
  pos: Float
  url: String
  artist_name: String
  title: String
}

type AppTweakTopChartType {
  id: ID!
  date: DateTime
  country: CountryType!
  appType: ChartAppTypeEnum!
  genre: TopChartGenreType
  leaderboard: [AppTweakTopChartLeaderboardType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ChartAppTypeEnum {
  FREE
  PAID
  GROSSING
}

type AppTweakTopChartLeaderboardType {
  id: String
  title: String
  icon: String
  developer: String
  price: String
  genres: [String!]
  devices: [String!]
  slug: String
  rating: Float
  in_apps: Boolean
  ratings_count: Int
  power: Float
}

type ErpIntegrationEventType {
  event: ErpElementsEnum!
  active: Boolean!
}

enum ErpElementsEnum {
  PRODUCTS
  SERVICES
  EQUIPMENTS
  CUSTOMERS
  CONTACTS
  SUPPLIERS
  QUOTATIONS
  SALE_ORDERS
  SALE_INVOICES
  SALE_DELIVERY_NOTES
  SALE_ISSUE_NOTES
  PURCHASE_INVOICES
  PURCHASE_DELIVERY_NOTES
  PURCHASE_ORDERS
}

type ErpIntegrationType {
  id: ID!
  url: String!
  username: String
  password: String
  recurrence: ErpIntegrationCycleEnum!
  active: Boolean!
  vendor: ErpVendorEnum!
  events: [ErpIntegrationEventType!]!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ErpIntegrationCycleEnum {
  DAILY
  MONTHLY
  HOURLY
  WEEKLY
}

enum ErpVendorEnum {
  SAGE
  SAP
  ODOO
}

type WidgetIntegrationActionsType {
  definition: ActivityTypeType
  recurrence: QuestActionsRecurrenceType
  remuneration: [RemunerationDtoType!]
}

type WidgetIntegrationContentType {
  profile: Boolean
  notification: Boolean
  quantitative: Boolean
  qualitative: Boolean
  chat: Boolean
  campaigns: Boolean
  pages: [LandingPageTypeEnum!]
}

type WidgetIntegrationType {
  id: ID!
  theme: String
  picture: PictureType
  icon: String
  active: Boolean
  content: WidgetIntegrationContentType
  actions: [WidgetIntegrationActionsType!]
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestsCountType {
  total: Int!
  DRAFT: Int!
  ONGOING: Int!
  FINISHED: Int!
}

type QuestActionsCountType {
  total: Int!
  EXPIRED: Int!
  PERFORMED: Int!
  IN_PROGRESS: Int!
}

type QuestActivitiesCountType {
  total: Int!
}

type QuestTypeType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  activityTypes: [ActivityTypeType!]
  maxActivities: Int
  rewardPoints: String
  minCoins: String
  fees: String
  score: Boolean
  profile: Boolean
  admin: Boolean
  transition: Boolean
  condition: Boolean
  enable: Boolean
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestTypePaginateType {
  count: Int
  isLast: Boolean
  objects: [QuestTypeType!]!
}

type OwnerDtoType {
  pos: PointOfSaleType
  user: UserType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type PocketWithoutTargetType {
  id: ID!
  usage: PocketUsageType!
  pocketType: PocketTypeEnum!
  amount: String
  challenge: ChallengeType
}

enum PocketUsageType {
  MAIN
  BONUS
}

type PocketType {
  id: ID!
  usage: PocketUsageType!
  pocketType: PocketTypeEnum!
  amount: String
  challenge: ChallengeType
  target: TargetType
}

type PocketWithReputationsType {
  id: ID!
  usage: PocketUsageType!
  pocketType: PocketTypeEnum!
  amount: String
  challenge: ChallengeType
  target: TargetType
  reputationLevels: [ReputationType!]
}

type WalletDtoType {
  id: ID!
  owner: OwnerDtoType
  createdAt: DateTime!
  updatedAt: DateTime!
  pockets: [PocketType!]
}

type WalletWithReputationDtoType {
  id: ID!
  owner: OwnerDtoType
  createdAt: DateTime!
  updatedAt: DateTime!
  pockets: [PocketWithReputationsType!]
}

type IsWalletAndCardInititalizedDtoType {
  isUserCardCreated: Boolean!
  isQuantitativeWalletCreated: Boolean!
}

type WalletOwnerHasEnoughBalanceType {
  hasEnoughBalance: Boolean!
}

type OwnerLessWalletOnePocketDtoType {
  id: ID!
  pocket: PocketType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSWithWalletType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currencies: [TargetCurrencyType!]
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
  wallet: OwnerLessWalletOnePocketDtoType
}

type POSWithWalletPaginateType {
  count: Int
  isLast: Boolean
  objects: [POSWithWalletType!]!
}

type WalletOnePocketDtoType {
  id: ID!
  pocket: PocketType
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: OwnerDtoType
}

type WalletOnePocketWithoutTargetDtoType {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: OwnerDtoType
  pocket: PocketWithoutTargetType
}

type WalletPaginateType {
  count: Int
  isLast: Boolean
  objects: [WalletDtoType!]!
}

type WalletLeaderboardType {
  user: UserType!
  rank: Int!
  amount: String!
  reputationLevel: ReputationType
}

type IsFollowedType {
  isFollowed: Boolean!
}

type FollowerType {
  id: ID!
  target: TargetType
  user: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PointOfSaleWithFollowShipStatusType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currencies: [TargetCurrencyType!]
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
}

type FollowerPaginateType {
  count: Int
  isLast: Boolean
  objects: [FollowerType!]!
}

type PointOfSaleWithFollowShipStatusPaginateType {
  count: Int
  isLast: Boolean
  objects: [PointOfSaleWithFollowShipStatusType!]!
}

type EffectiveDateType {
  end: String!
  start: String!
}

type LeaderboardBaseType {
  user: UserType
  target: TargetType
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: EffectiveDateType!
  cycle: LeaderboardCycleEnum!
  currentReputationLevel: ReputationWithoutTargetType
  nextReputationLevel: ReputationWithoutTargetType
}

enum LeaderboardCycleEnum {
  OVERALL
  DAILY
  WEEKLY
  MONTHLY
}

type LeaderboardType {
  user: UserType
  target: TargetType
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: EffectiveDateType!
  cycle: LeaderboardCycleEnum!
  currentReputationLevel: ReputationWithoutTargetType
  nextReputationLevel: ReputationWithoutTargetType
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LeaderboardPaginatedType {
  count: Int
  isLast: Boolean
  objects: [LeaderboardType!]!
}

type EffectiveDatePaginatedType {
  count: Int
  isLast: Boolean
  objects: [EffectiveDateType!]!
}

type LeaderboardBasePaginatedType {
  count: Int
  isLast: Boolean
  objects: [LeaderboardBaseType!]!
}

type IsUserSubscribedToTargetType {
  isSubscribed: Boolean!
  status: SubscriptionStatus
}

enum SubscriptionStatus {
  PENDING
  APPROVED
  REJECTED
}

type SubscribersFullType {
  id: ID!
  target: TargetType
  status: SubscriptionStatus
  createdAt: DateTime!
  updatedAt: DateTime!
  user: UserType
}

type SubscribersFullWithReputationType {
  id: ID!
  target: TargetType
  status: SubscriptionStatus
  createdAt: DateTime!
  updatedAt: DateTime!
  user: UserType
  wallet: WalletOnePocketWithoutTargetDtoType
  currentReputationLevel: ReputationWithoutTargetType
  nextReputationLevel: ReputationWithoutTargetType
}

type StatsType {
  numberOfProducts: Int!
  numberOfFollowers: Int!
  numberOfSubscribers: Int!
}

type SubscribersWithReputationsPaginateType {
  count: Int
  isLast: Boolean
  objects: [SubscribersFullWithReputationType!]!
}

type ProductWalletTopupType {
  name: String
  price: String
  tax: String
}

type WalletTopupFullType {
  id: ID
  pos: PointOfSaleType
  createdAt: DateTime!
  updatedAt: DateTime!
  executor: UserType
}

type OnsiteConverterType {
  id: ID!
  target: TargetType!
  remunerations: [RemunerationWithReputationDtoType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PushAmountResponseType {
  source: TargetWithUserType!
  receiver: TargetWithUserType!
  qualitativeAmountPushed: String
  quantitativeAmountPushed: String!
}

type RemunerationAmountType {
  qualitativeAmountToPush: String!
  quantitativeAmountToPush: String!
}

type APICredentialsType {
  publicKey: String
  secretKey: String
}

type LoyaltySettingsOnsiteConverterIntgType {
  active: Boolean
  credentials: APICredentialsType
}

type LoyaltySettingsOnsiteConverterType {
  active: Boolean!
  onsiteConverter: OnsiteConverterType
  cashregisterIntegration: LoyaltySettingsOnsiteConverterIntgType
}

type LoyaltySettingsWalletType {
  active: Boolean!
  picture: PictureType
}

type LoyaltySettingsWalletCardType {
  digital: Boolean!
  physical: Boolean!
  validity: Int!
}

type LoyaltySettingsWalletLeaderboardType {
  active: Boolean!
  overall: Boolean!
  monthly: Boolean!
  weekly: Boolean!
}

type LoyaltySettingsWalletSubscribersType {
  verification: Boolean!
}

type LoyaltySettingsType {
  id: ID!
  qualitative: LoyaltySettingsWalletType
  quantitative: LoyaltySettingsWalletType
  onsiteConverter: LoyaltySettingsOnsiteConverterType
  loyaltyCard: LoyaltySettingsWalletCardType
  leaderboard: LoyaltySettingsWalletLeaderboardType
  subscribers: LoyaltySettingsWalletSubscribersType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChallengeActionType {
  id: ID!
  reward: Int!
  response: ResponseDtoType!
  jockers: [JockerType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LabelType {
  id: ID!
  name: String!
  category: LabelTypeEnum
  icon: String
  color: String
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LabelTypeEnum {
  NOTES
  SCRUM
}

type NotesTaskType {
  title: String!
  done: Boolean
}

type NotesType {
  id: ID!
  title: String!
  isArchived: Boolean!
  description: String
  picture: PictureType
  tasks: [NotesTaskType!]
  labels: [LabelType!]!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BoardCardProcedureType {
  title: String
  task: BoardCardProcedureEnum
  time: DateTime
}

enum BoardCardProcedureEnum {
  MEETING
  CALL
  CONFERENCE
  DEMO
  CHAT
}

type BoardCardTasksType {
  task: String
  done: Boolean
}

type TasksStatsType {
  total: Int!
  done: Int!
}

type BoardCardForListType {
  id: ID!
  title: String!
  description: String
  dueDate: DateTime
  archived: Boolean
  priority: BoardCardPriorityEnum
  tags: [String!]
  pictures: [PictureType!]
  barcode: BarcodeType
  project: ProjectType
  tasks: [BoardCardTasksType!]
  labels: [LabelType!]
  rank: Int
  assignedTo: [UserType!]
  budget: String
  customer: CompanyType
  procedure: [BoardCardProcedureType!]
  attachments: [DocumentType!]
  tasksStats: TasksStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BoardCardPriorityEnum {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

type BoardCardType {
  id: ID!
  title: String!
  description: String
  dueDate: DateTime
  archived: Boolean
  priority: BoardCardPriorityEnum
  tags: [String!]
  pictures: [PictureType!]
  barcode: BarcodeType
  project: ProjectType
  tasks: [BoardCardTasksType!]
  labels: [LabelType!]
  rank: Int
  assignedTo: [UserType!]
  budget: String
  customer: CompanyType
  procedure: [BoardCardProcedureType!]
  attachments: [DocumentType!]
  tasksStats: TasksStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
  boardList: BoardListType!
}

type BoardCardPaginateType {
  count: Int
  isLast: Boolean
  objects: [BoardCardType!]!
}

type BoardCardsStatsResponseType {
  LOW: CurrentPreviousType!
  NORMAL: CurrentPreviousType!
  HIGH: CurrentPreviousType!
  CRITICAL: CurrentPreviousType!
}

type BoardListType {
  id: ID!
  name: String!
  rank: Int
  theme: String
  identifier: MaintenanceBoardListEnum
  board: BoardType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum MaintenanceBoardListEnum {
  NEW_REQUEST
  IN_PROGRESS
  REPLACED
  SCRAP
}

type ListWithCardsType {
  id: ID!
  name: String!
  rank: Int
  theme: String
  identifier: MaintenanceBoardListEnum
  createdAt: DateTime!
  updatedAt: DateTime!
  boardCards: [BoardCardForListType!]
}

type BoardType {
  id: ID!
  title: String!
  description: String
  category: BoardCategoryEnum
  icon: String
  members: [UserType!]
  projects: [ProjectType!]
  target: TargetType!
  boardCardsStats: BoardCardsStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BoardCategoryEnum {
  PROJECTS
  MAINTENANCE
  CRM
}

type BoardPaginateType {
  count: Int
  isLast: Boolean
  objects: [BoardType!]!
}

type BoardWithListsAndCardsType {
  id: ID!
  title: String!
  description: String
  category: BoardCategoryEnum
  icon: String
  members: [UserType!]
  projects: [ProjectType!]
  target: TargetType!
  boardCardsStats: BoardCardsStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
  boardLists: [ListWithCardsType!]
}

type TimeEntryType {
  id: ID!
  member: UserType!
  card: BoardCardType!
  start: DateTime!
  end: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GenericTaskType {
  id: ID!
  title: String!
  description: String
  tags: [String!]
  priority: TaskPriorityEnum!
  dueDate: DateTime
  completed: Boolean!
  archived: Boolean!
  rank: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TaskPriorityEnum {
  HIGH
  NORMAL
  LOW
}

type TaskSectionType {
  id: ID!
  title: String!
  description: String
  tags: [String!]
  priority: TaskPriorityEnum!
  dueDate: DateTime
  completed: Boolean!
  archived: Boolean!
  rank: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type TaskSectionPaginatedType {
  count: Int
  isLast: Boolean
  objects: [TaskSectionType!]!
}

type TaskSectionWithTasksType {
  id: ID!
  title: String!
  description: String
  tags: [String!]
  priority: TaskPriorityEnum!
  dueDate: DateTime
  completed: Boolean!
  archived: Boolean!
  rank: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  tasks: [GenericTaskType!]!
}

type TaskType {
  id: ID!
  title: String!
  description: String
  tags: [String!]
  priority: TaskPriorityEnum!
  dueDate: DateTime
  completed: Boolean!
  archived: Boolean!
  rank: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  taskSection: TaskSectionType!
}

type TicketType {
  id: ID!
  identifier: String!
  name: String
  description: String
  media: MediaType
  tags: [String!]
  deadline: DateTime
  priority: TicketPriorityEnum
  status: TicketStatusEnum
  color: String
  assignedTo: [UserType!]
  customer: CompanyType
  project: ProjectType
  attachments: [DocumentType!]
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TicketPriorityEnum {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum TicketStatusEnum {
  OPEN
  IN_PROGRESS
  RESOLVED
  BLOCKED
  ON_HOLD
}

type TicketStatsType {
  OPEN: CurrentPreviousType!
  IN_PROGRESS: CurrentPreviousType!
  BLOCKED: CurrentPreviousType!
  RESOLVED: CurrentPreviousType!
}

type TicketsPaginateType {
  count: Int
  isLast: Boolean
  objects: [TicketType!]!
}

type CommentHolderType {
  project: ProjectType
  card: BoardCardType
  ticket: TicketType
  quotation: QuotationType
  saleOrder: SaleOrderType
  saleIssueNote: SaleIssueNoteType
  saleInvoice: SaleInvoiceType
  saleDeliveryNote: SaleDeliveryNoteType
  purchaseDeliveryNote: PurchaseDeliveryNoteType
  purchaseInvoice: PurchaseInvoiceType
  purchaseOrder: PurchaseOrderType
}

type CommentBaseType {
  id: ID!
  user: UserType
  comment: String
  attachments: [DocumentType!]
  holder: CommentHolderType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FirstReplyType {
  reply: CommentBaseType
  hasMoreReplies: Boolean!
}

type CommentType {
  id: ID!
  user: UserType
  comment: String
  attachments: [DocumentType!]
  holder: CommentHolderType
  createdAt: DateTime!
  updatedAt: DateTime!
  firstReply: FirstReplyType
}

type CommentPaginateType {
  count: Int
  isLast: Boolean
  objects: [CommentType!]!
}

type TimeTrackOnType {
  project: ProjectType
  card: BoardCardType
  ticket: TicketType
}

type TimeTrackType {
  id: ID!
  user: UserType
  title: String
  start: DateTime
  end: DateTime
  idle: String
  holder: TimeTrackOnType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TimeTrackPaginateType {
  count: Int
  isLast: Boolean
  objects: [TimeTrackType!]!
}

type a {
  value: String
}

type u {
  id: ID!
  label: String
  externalId: String
  value: a
  product: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Query {
  sendEmail(input: EmailTempInput!): MailResponseDto!
  getEmailTemplate: [EmailTemplateType!]!
  emailTemplate(id: ID!): CorporateEmailTemplateType!
  findEmailTemplateByName(name: EmailTemplateTypeEnum!): EmailTemplateType!
  sendCorporateEmail(input: CorporateEmailTempInput!): MailResponseDto!
  getCorporateEmailTemplate: [CorporateEmailTemplateType!]!
  findCorporateEmailTemplateByName(
    name: EmailTemplateTypeEnum!
  ): CorporateEmailTemplateType!
  getCorporateEmailsByTargetPaginated(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CorporateEmailTemplatePaginateType!
  loginForApp(input: LoginInput!): LoginType!
  login(input: LoginInput!): LoginType!
  loginWithFacebook(token: String!): LoginType!
  loginWithGoogle(token: String!): LoginType!
  loginWithApple(authorizationData: AuthorizationDataInput!): LoginType!
  loginForTarget(
    target: TargetACIInput!

    # new password.
    password: String!

    # Login phone number/username or email.
    login: String

    # quantity of products to add/remove to/from stock.
    phone: IPhoneInput
  ): LoginType!
  isLoginForTargetExist(
    input: IsLoginForTargetExistInput!
  ): CorporateUserExistType!
  searchCorporateUsersByTarget(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    status: [UserStatus!]
    searchString: String
    sortingField: String
  ): CorporateUserPaginateType!
  getCorporateUsersByTarget(target: TargetACIInput!): [CorporateUserType!]!
  getCorporateUsersByExcel(
    path: String
    sortingField: String
    searchString: String
    status: [UserStatus!]
    target: TargetACIInput!
  ): InvoicePDFType!
  sendCorporateUsersBymail(
    subject: String!
    emails: [String!]
    sortingField: String
    searchString: String
    status: [UserStatus!]
    target: TargetACIInput
  ): MailResponseDto!
  getUsersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): UserPaginateType!
  getRoles: StringListType!
  getGenders: StringListType!
  getMaritalStatuses: StringListType!
  getUsers: [UserType!]!
  getUsersPaginated(
    status: [UserStatus!]
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): UserPaginateType!
  user(id: String!): UserType!
  currentUser: UserType!
  userByEmail(email: String!): UserType!
  searchUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): UserPaginateType!
  isLoggedIn: IsLoggedInType!
  isLoginExist(input: IsLoginExistInput!): UserExistType!
  isEmailExist(email: String!): UserExistType!
  getVapidKey(userId: String): VapidKeyType!
  validateRegisterPhoneNumber(smsNumber: Int!, phone: IPhoneInput!): SmsLogType!
  sendSms(
    time: String!
    date: String!
    smsContent: String!
    phoneNumber: String!
  ): SmsIntegrationType!
  getOrigins: [OriginType!]!
  getMediaOfMessageGroupPagination(
    messageGroup: ID!
    mediaType: MediaTypeEnum!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): MessageMediaPaginateType!
  getMessagesByMessageGroupPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    messageGroup: ID!
  ): MessagePaginateType!
  getMessagesByMember(
    target: TargetACIInput!
    type: MessageGroupTypeEnum!
    memberId: ID!
  ): [MessageType!]!
  getMessagesByMemberPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    type: MessageGroupTypeEnum!
    memberId: ID!
  ): MessagePaginateType!
  countUnseenMessages: UnseenMessagesCountType!
  searchMessageByMessageGroupPagination(
    messageGroup: ID!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): MessagePaginateType!
  getMessageGroupsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): MessageGroupPaginateType!
  getDirectMessageGroup(
    target: TargetACIInput!
    receiverId: ID!
  ): MessageGroupType!
  getArchivedMessageGroupsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): MessageGroupPaginateType!
  getMessageGroup(id: ID!): MessageGroupType!
  searchMessageGroup(
    status: MessageGroupStatusEnum
    target: TargetACIInput
    type: MessageGroupTypeEnum!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): MessageGroupPaginateType!
  searchSupportMessageGroup(
    status: MessageGroupStatusEnum
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): MessageGroupPaginateType!
  searchInternalMessageGroup(
    status: MessageGroupStatusEnum
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): MessageGroupPaginateType!
  getMessageGroupMembers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    id: ID!
  ): UserPaginateType!
  getMessageGroupByMember(
    target: TargetACIInput
    memberId: ID!
  ): MessageGroupType!
  getVersions: [VersionType!]!
  getVersion(id: String!): VersionType!
  getByVersion(version: String!): VersionType!
  getLastVersion: VersionType!
  getLastVersionByPlatform(platform: PlatformEnum!): VersionType!
  getVersionsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): VersionsPaginateType!
  generateCloudinarySignature(
    public_id: String
    folder: String!
  ): CloudinarySignatureType!
  getImagesFromFolder(path: String!): [CloudinaryResourceType!]!
  getGuidanceTypes: StringListType!
  getCurrencies: [CurrencyType!]!
  getApps: StringListType!
  getBrandColors: [KeyValueListType!]!
  getOrderStatuses: StringListType!
  getDiscountTypes: StringListType!
  getChatContacts: StringListType!
  getSocialMedias: StringListType!
  uploadImage(remotePath: String!, localPath: String!): PictureType!
  getStaticData: [StaticDataType!]!
  getStaticDataByKey(key: String!): StaticDataType!
  getPartnerReferrals: [PartnerReferralType!]!
  partnerReferral(id: String!): PartnerReferralType!
  getPartnerReferralsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PartnerReferralPaginateType!
  getBarcodesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BarcodePaginateType!
  getBarcodes: [BarcodeType!]!
  barcode(id: String!): BarcodeType!
  getBarcodeWithStock(id: String!): BarcodeWithStockType!
  getBarcodeByProductAndAttributes(input: BarcodeFindInput!): BarcodeType!
  getProductBarcodes(productId: String!): [BarcodeType!]!
  getCompaniesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CompanyPaginateType!
  getCompanies: [CompanyType!]!
  company(id: ID!): CompanyType!
  searchCompany(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): CompanyPaginateType!
  searchCustomersByTargetAndPhase(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    phase: CustomerPhaseEnum!
    target: TargetACIInput!
  ): CompanyPaginateType!
  searchSuppliersByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    kinds: [SupplierTypeEnum!]
    target: TargetACIInput!
  ): CompanyPaginateType!
  searchLogisticCompaniesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): CompanyPaginateType!
  getCustomers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    phase: CustomerPhaseEnum!
    target: TargetACIInput!
  ): CompanyPaginateType!
  getCompaniesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): CompanyPaginateType!
  getLoyaltyProgramsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LoyaltyProgramPaginateType!
  loyaltyProgram(id: String!): LoyaltyProgramType!
  searchLoyaltyProgram(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): LoyaltyProgramPaginateType!
  getManufacturersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ManufacturerPaginateType!
  manufacturer(id: String!): ManufacturerType!
  searchManufacturer(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ManufacturerPaginateType!
  getOpeningStatuses: StringListType!
  getSpecialOffersTypes: StringListType!
  getPointOfSalesPagination(
    posCategory: ID
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PointOfSalePaginateType!
  pointOfSale(id: ID!): PointOfSaleType!
  pointOfSaleByOrigin(website: String): PointOfSaleType!
  searchPos(
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): PointOfSalePaginateType!
  findPOSNearbyPagination(
    categoryId: ID
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSalePaginateType!
  searchPOSNearbyPagination(
    categoryId: ID
    published: Boolean
    searchString: String!
    pagination: PaginationInput = { page: 0, limit: 20 }
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSalePaginateType!
  getPOSWithFollowersPagination(
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PointOfSaleWithFollowShipStatusPaginateType!
  findPOSNearbyWithFollowersPagination(
    categoryId: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSaleWithFollowShipStatusPaginateType!
  isUserNearPOS(posId: ID!, lat: Float!, lon: Float!): IsUserNearPOSDtoType!
  getAccounts(
    target: TargetACIInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AccountPaginateType!
  getWaitersByPoss(
    pagination: PaginationInput = { page: 0, limit: 20 }
    posId: String!
  ): AccountPaginateType!
  getDeliveryManByPos(
    pagination: PaginationInput = { page: 0, limit: 20 }
    posId: String!
  ): AccountPaginateType!
  getAccountsByTargetAndRoles(
    pagination: PaginationInput = { page: 0, limit: 20 }
    role: [UserRole!]!
    target: TargetACIInput!
  ): AccountPaginateType!
  account(id: String!): AccountType!
  accountByUserId(userId: String!): AccountType!
  currentAccount: AccountType!
  searchAccount(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AccountPaginateType!
  getPOSCategoriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): POSCategoryPaginateType!
  getPOSCategories: [POSCategoryType!]!
  posCategory(id: String!): POSCategoryType!
  searchPosCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): POSCategoryPaginateType!
  getCatalogueCategoriesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): CatalogueCategoryPaginateType!
  getCatalogueCategories(target: TargetACIInput!): [CatalogueCategoryType!]!
  getCatalogueCategoriesByTargetForPortal(
    target: TargetACIInput!
  ): [CatalogueCategoryType!]!
  getCatalogueCategoriesByLayerAndParentForPortal(
    parent: String
    target: TargetACIInput!
    layer: Int!
  ): [CatalogueCategoryType!]!
  getCatalogueCategoriesByLayerAndParent(
    parent: String
    variety: ProductVarietyEnum
    target: TargetACIInput!
    layer: Int!
  ): [CatalogueCategoryType!]!
  getCatalogueCategoriesByTargetAndUrlKey(
    urlKey: String
    target: TargetACIInput!
  ): CatalogueCategoryType!
  getCatalogueCategoryPath(id: ID!): [CatalogueCategoryType!]!
  catalogueCategory(id: ID!): CatalogueCategoryType!
  searchCatalogueCategories(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): CatalogueCategoryPaginateType!
  getCatalogueCategoriesByTargetWithChildren(
    target: TargetACIInput!
  ): [CatalogueCategoryWithChildrenType!]!
  findCatalogueCategoryByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): CatalogueCategoryType!
  getPOSServicesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): POSServicesPaginateType!
  getPOSservices: [POSServicesType!]!
  posServices(id: String!): POSServicesType!
  searchPosServices(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): POSServicesPaginateType!
  getWholesalersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): WholesalerPaginateType!
  getWholesalers: [WholesalerType!]!
  wholesaler(id: String!): WholesalerType!
  searchWholesaler(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): WholesalerPaginateType!
  getBrandsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BrandPaginateType!
  getBrands: [BrandType!]!
  getBrandsByTarget(target: TargetACIInput!): [BrandType!]!
  getBrandsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): BrandPaginateType!
  brand(id: String!): BrandType!
  searchBrand(
    target: TargetACIInput
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): BrandPaginateType!
  findBrandByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): BrandType!
  getInventoryCategoriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InventoryCategoryPaginateType!
  getInventoryCategories: [InventoryCategoryType!]!
  getInventoryCategoriesByLayerandParent(
    returnEmpty: Boolean
    parent: String
    layer: Int!
  ): [InventoryCategoryType!]!
  getInventoryCategoriesByParent(parent: String!): [InventoryCategoryType!]!
  inventoryCategory(id: String!): InventoryCategoryType!
  searchInventoryCategory(
    layer: Int
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InventoryCategoryPaginateType!
  getPriceTypes: StringListType!
  getProductsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductPaginateType!
  getProducts: [ProductType!]!
  getProductsByCategoryPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    category_ids: [String!]!
  ): ProductPaginateType!
  getProductsByClass(
    pagination: PaginationInput = { page: 0, limit: 20 }
    class: [ProductClassEnum!]!
  ): ProductPaginateType!
  product(id: String!): ProductType!
  findOneByEAN(ean: String!): ProductType!
  searchProduct(
    catId: String
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductPaginateType!
  getProductWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    sort: [ProductSortInput!]
    filter: ProductFilterInput
  ): ProductPaginateWithFilterType!
  getAttributesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AttributePaginateType!
  getAttributesTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): AttributePaginateType!
  getAttributes: [AttributeType!]!
  getAttributesByTarget(target: TargetACIInput!): [AttributeType!]!
  attribute(id: String!): AttributeType!
  searchAttribute(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AttributePaginateType!
  searchAttributeByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    variety: ProductVarietyEnum
    target: TargetACIInput!
    searchString: String
  ): AttributePaginateType!
  findAttributeByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): AttributeType!
  getAttributeValuesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AttributeValuePaginateType!
  getAttributeValuesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): AttributeValuePaginateType!
  getAttributeValues: [AttributeValueType!]!
  getAttributeValuesByTarget(target: TargetACIInput!): [AttributeValueType!]!
  getAttributeValuesByAttribute(attributId: ID!): [AttributeValueType!]!
  getAttributeValuesByAttributePaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    attributId: ID!
  ): AttributeValuePaginateType!
  attributeValue(id: ID!): AttributeValueType!
  searchAttributeValue(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AttributeValuePaginateType!
  searchAttributeValueByTarget(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AttributeValuePaginateType!
  findAttributeValueByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): AttributeValueType!
  getProductAttributesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductAttributePaginateType!
  getProductAttributesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): ProductAttributePaginateType!
  getProductAttributes: [ProductAttributeType!]!
  getProductAttributesByTarget(
    target: TargetACIInput!
  ): [ProductAttributeType!]!
  getProductAttributesByAttribute(attributId: String!): [ProductAttributeType!]!
  getProductAttributesByAttributeAndTarget(
    target: TargetACIInput!
    attributId: String!
  ): [ProductAttributeType!]!
  productAttribute(id: String!): ProductAttributeType!
  searchProductAttribute(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ProductAttributePaginateType!
  searchProductAttributeByTarget(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ProductAttributePaginateType!
  getInternalProductBarcodes(id: String!): [BarcodeType!]!
  getInternalProductBarcodesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    id: String!
  ): BarcodePaginateType!
  getBarcodesWithVarietyAndStructureWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: BarcodeWithVarietyAndStructureFilterInput!
    target: TargetACIInput!
  ): BarcodePaginateType!
  getSimpleProductWithFavoriteStatus(
    # Internal product id
    id: ID!
  ): InternalProductWithFavoriteStatusType!
  getSimpleProductWithFavoriteStatusByUrlKey(
    # Internal product seo urlKey.
    urlKey: String!
    target: TargetACIInput!
  ): InternalProductWithFavoriteStatusType!
  getSimpleProductsByTargetAndCatalogueCategoryUrlKeyWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    urlKey: String!
  ): InternalProductWithFavoriteStatusPaginateType!
  getSimpleProductsByCatalogueCategoryWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductWithFavoriteStatusPaginateType!
  getSimpleBarcodeByBarcodeAndTarget(
    target: TargetACIInput!
    barcode: String!
  ): BarcodeType!
  getSimpleProductWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductPaginateWithFilterType!
  searchSimpleEquipments(
    searchInput: SearchSimpleProductInput!
  ): InternalProductPaginateWithFilterType!
  searchSimpleServices(
    searchInput: SearchSimpleProductInput!
  ): BarcodePaginateType!
  getServiceProduct(target: TargetACIInput!): InternalProductType!
  searchSimpleBarcodesByTargetWithStock(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): BarcodeWithStockPaginatedType!
  getSimpleServicesWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: BarcodesFilterInput
    sort: [ProductSortInput!]
    target: TargetACIInput!
  ): BarcodesPaginatedWithFilterType!
  getSimpleProductsWithRatingsWithFavoriteStatusWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductWithRatingsPaginateWithFavoriteStatusWithFilterType!
  getSimpleBarcodesByBarcodesAndTarget(
    target: TargetACIInput!
    barcodes: [String!]!
  ): [BarcodeType!]!
  getSimpleProductsByTargetGroupedByClassWithFavoriteStatus(
    target: TargetACIInput!
  ): InternalProductByClassTypeWithFavoriteStatus!
  getInternalProducts(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput
  ): InternalProductPaginateType!
  findInternalProductByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): InternalProductType!
  getAllInternalProducts(target: TargetACIInput): [InternalProductType!]!
  getAllInternalProductsByTargetGroupedByClass(
    target: TargetACIInput!
  ): InternalProductByClassType!
  getAllInternalProductsByTargetGroupedByClassWithFavoriteStatus(
    target: TargetACIInput!
  ): InternalProductByClassTypeWithFavoriteStatus!
  getInternalProductsByCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    category: ID!
    target: TargetACIInput!
  ): InternalProductPaginateType!
  getInternalProductsByClass(
    pagination: PaginationInput = { page: 0, limit: 20 }
    class: [ProductClassEnum!]!
    target: TargetACIInput!
  ): InternalProductPaginateType!
  getInternalProductsByTargetAndCatalogueCategoryUrlKey(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    urlKey: String!
  ): InternalProductPaginateType!
  getInternalProductsByTargetAndCatalogueCategoryUrlKeyWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    urlKey: String!
  ): InternalProductWithFavoriteStatusPaginateType!
  getOneInternalProductByBarcodeAndTarget(
    target: TargetACIInput!
    barcode: ID!
  ): InternalProductType!
  getInternalProductsByTargetAndCatalogueCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    category: ID!
  ): InternalProductPaginateType!
  getInternalProductsByCatalogueCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductPaginateType!
  getInternalProductsByCatalogueCategoryWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductWithFavoriteStatusPaginateType!
  getInternalProductsByCatalogueCategoryForPortal(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductPaginateType!
  getInternalProductsByProduct(
    pagination: PaginationInput = { page: 0, limit: 20 }
    productId: ID!
  ): InternalProductPaginateType!
  getInternalProduct(id: ID!): InternalProductType!
  getInternalProductWithStock(id: ID!): InternalProductWithStockType!
  getInternalProductWithFavoriteStatus(
    id: ID!
  ): InternalProductWithFavoriteStatusType!
  searchInternalProduct(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): InternalProductPaginateType!
  searchInternalProductByCatalogueCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryId: ID!
    searchString: String
  ): InternalProductPaginateType!
  searchInternalProductByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): InternalProductPaginateType!
  searchBarcodesByTargetAndSupplier(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    supplier: ID!
    searchString: String
  ): BarcodePaginateType!
  getBarcodesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): BarcodePaginateType!
  getBarcodesByTargetWithInternalProductPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BarcodePaginateType!
  getInternalProductWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductPaginateWithFilterType!
  getInternalProductsWithRatingsWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductWithRatingsPaginateWithFilterType!
  getInternalProductsWithRatingsWithFavoriteStatusWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductWithRatingsPaginateWithFavoriteStatusWithFilterType!
  getBarcodeByBarcodeAndTarget(
    target: TargetACIInput!
    barcode: String!
  ): BarcodeType!
  getBarcodesByBarcodesAndTarget(
    target: TargetACIInput!
    barcodes: [String!]!
  ): [BarcodeType!]!
  getBarcodesWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: BarcodeFilterInput!
    target: TargetACIInput!
  ): BarcodePaginateType!
  searchBarcodesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BarcodePaginateType!
  searchBarcodesByTargetWithStock(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BarcodeWithStockPaginatedType!
  getTargetFollowersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FollowerPaginateType!
  getFollowedTargetsByUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FollowerPaginateType!
  getFollowersWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    input: FollowerFilterInput!
  ): FollowerPaginateType!
  getFollowersByTargetPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): FollowerPaginateType!
  isTargetFollowedByUser(target: TargetACIInput!): IsFollowedType!
  searchFollowers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): FollowerPaginateType!
  searchFollowedTargetsByUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): FollowerPaginateType!
  getLocations: [LocationType!]!
  location(id: ID!): LocationType!
  getLocationsByCompany(company: ID!): [LocationType!]!
  getLocationsByCompanyPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    filter: LocationFilterInput
    company: ID!
  ): LocationPaginateType!
  getTaxes: [TaxType!]!
  tax(id: ID!): TaxType!
  getTaxesByCompany(company: ID!): [TaxType!]!
  getGlobalSalesTaxesByCompany(company: ID!): [TaxType!]!
  getGlobalPurchasesTaxesByCompany(company: ID!): [TaxType!]!
  getProductSalesTaxesByCompany(company: ID!): [TaxType!]!
  getProductPurchasesTaxesByCompany(company: ID!): [TaxType!]!
  getTaxesByCompanyPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    company: ID!
  ): TaxPaginateType!
  getPrices: [PriceType!]!
  price(id: ID!): PriceType!
  getEnabledPricesByCompany(company: ID!): [PriceType!]!
  getPricesByCompanyPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    company: ID!
  ): PricePaginateType!
  getRequests: [RequestType!]!
  getRequest(id: ID!): RequestType!
  getRequestsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): RequestPaginateType!
  getRequestsByTypePaginated(
    type: RequestTypeEnum!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): RequestPaginateType!
  getRequestsByTypeAndTargetPaginated(
    target: TargetACIInput!
    type: RequestTypeEnum
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): RequestPaginateType!
  getRequestsByExcel(
    path: String
    searchString: String
    type: RequestTypeEnum
    target: TargetACIInput!
  ): InvoicePDFType!
  sendRequestsBymail(
    subject: String!
    emails: [String!]
    searchString: String
    type: RequestTypeEnum
    target: TargetACIInput
  ): MailResponseDto!
  getModuleDefinitions: [ModulesDefinitionType!]!
  moduleDefinition(id: String!): ModulesDefinitionType!
  findModuleDefinitionsByTarget(
    target: TargetTypeEnum!
  ): [ModulesDefinitionType!]!
  getModulesAssignment: [ModulesAssignmentType!]!
  moduleAssignment(id: String!): ModulesAssignmentType!
  getModuleAssignmentsByAssignee(
    assignee: AssigneeInput!
  ): [ModulesAssignmentType!]!
  findModuleAssignmentsByOrigin: [ModulesAssignmentType!]!
  findModuleAssignmentsforFrame(posId: String!): [ModulesAssignmentType!]!
  getFavoriteProduct: [FavoriteProductType!]!
  favoriteProduct(id: String!): FavoriteProductType!
  findFavoriteProductByCurrentUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductPaginateType!
  searchFavoriteProduct(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductPaginateType!
  isFavoriteProduct(productId: String!): IsFavoriteProductType!
  getBookingTypePagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BookingTypePaginateType!
  getBookingType: [BookingTypeType!]!
  bookingType(id: String!): BookingTypeType!
  searchBookingType(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): BookingTypePaginateType!
  getBookingSettings: [BookingSettingsType!]!
  bookingSettings(id: String!): BookingSettingsType!
  getBookingSettingsByPOS(posId: String!): BookingSettingsFullType!
  getBookings: [BookingType!]!
  bookingByNumber(bookingNumber: Float!): BookingType!
  findBookingsByPOS(
    status: [BookingStatusEnum!]
    pagination: PaginationInput = { page: 0, limit: 20 }
    pos: String!
  ): BookingPaginateType!
  getBookingsWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    bookingFilterInput: BookingFilterInput!
  ): BookingPaginateType!
  booking(id: String!): BookingType!
  getBookingsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BookingPaginateType!
  exportBookingsWithFilter(
    bookingFilterInput: BookingFilterInput!
  ): DocumentResultType!
  exportBookingsWithFilterByMail(
    subject: String!
    emails: [String!]
    bookingFilterInput: BookingFilterInput!
  ): MailResponseDto!
  countUnseenNotificationsByPOS(posId: String!): UnseenNotificationCountType!
  countUnseenNotificationsByUser: UnseenNotificationCountType!
  sendAdhocNotificationTest(
    picture: PictureInput!
    description: String!
    userId: String!
    title: String!
  ): AdhocNotificationTestType!
  sendUserAdhocNotification(
    executedAt: DateTime
    picture: PictureInput!
    description: String!
    userId: String!
    title: String!
  ): AdhocNotificationTestType!
  sendAdhocNotificationToTopicTest(
    picture: PictureInput!
    description: String!
    topic: String!
    title: String!
  ): AdhocNotificationTestType!
  getComplaints: [ComplaintType!]!
  getLastComplaintByTarget(target: ComplaintTargetInput!): ComplaintType!
  getComplaintsByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: ComplaintTargetInput!
  ): ComplaintPaginateType!
  getLastComplaintByReporter(reporter: String!): ComplaintType!
  getComplaintsByReporter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    reporter: String!
  ): ComplaintPaginateType!
  getBookingAttributesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BookingAttributePaginateType!
  getBookingAttributes: [BookingAttributeType!]!
  bookingAttribute(id: String!): BookingAttributeType!
  searchBookingAttribute(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): BookingAttributePaginateType!
  getStocks: [StockType!]!
  getStock(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID
  ): StockType!
  getStockByTargetAndBarcode(
    target: TargetACIInput!
    barcode: String!
  ): StockType!
  getStocksByTarget(
    outOfStock: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): StockPaginateType!
  getStocksByTargetInAllWarehouses(
    outOfStock: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): BarcodeWithStockDataPaginatedType!
  searchStocksByTarget(
    searchString: String
    target: TargetACIInput!

    # The field to sort the result by (default updatedAt).
    sortingField: String = "updatedAt"

    # The sorting order of the result 1 for ascending and -1 for descending by (default -1 => descending).
    sortingOrder: Float = -1

    # search in out of stock products if true and in instock products if false, in both if not passed.
    outOfStock: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    warehouses: [ID!]
  ): StockPaginateType!
  searchSimpleStocksByTarget(
    searchString: String
    target: TargetACIInput!

    # The field to sort the result by (default updatedAt).
    sortingField: String = "updatedAt"

    # The sorting order of the result 1 for ascending and -1 for descending by (default -1 => descending).
    sortingOrder: Float = -1

    # search in out of stock products if true and in instock products if false, in both if not passed.
    outOfStock: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    warehouses: [ID!]
  ): StockPaginateType!
  getWarehouses: [WarehouseType!]!
  warehouse(id: ID!): WarehouseType!
  getWarehousesByCompany(company: ID!): [WarehouseType!]!
  getWarehousesByCompanyPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    company: ID!
  ): WarehousePaginateType!
  findWarehousesByLocation(location: ID!): [WarehouseType!]!
  findWarehousesByLocationPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    location: ID!
  ): WarehousePaginateType!
  getStories(filter: StoriesFilterInput!): [StoriesType!]!
  getStoriesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetWithGroupInput!
  ): StoriesPaginatedType!
  getStory(id: ID!): [StoriesType!]!
  getStoriesViewsStatus(
    filter: StoriesViewsStatusFilterInput!
  ): [StoriesViewsStatusType!]!
  getProductRatings(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductRatingPaginateType!
  getAllProductRatings: [ProductRatingType!]!
  getProductRatingsByProduct(
    pagination: PaginationInput = { page: 0, limit: 20 }

    # The product id.
    productId: ID!
  ): ProductRatingPaginateType!
  getProductRatingsByProductWithStats(
    pagination: PaginationInput = { page: 0, limit: 20 }

    # The product id.
    productId: ID!
  ): ProductRatingWithStatsPaginatedType!
  getAverageProductRatingsByProduct(
    # The product id.
    productId: ID!
  ): AverageRatingType!
  productRating(
    # The product id.
    id: ID!
  ): ProductRatingType!
  getProductRatingDefinitions(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductRatingDefinitionPaginateType!
  getAllProductRatingDefinitions: [ProductRatingDefinitionType!]!
  productRatingDefinition(id: String!): ProductRatingDefinitionType!
  getProductRatingDefinitionByReviewType(
    reviewType: String!
  ): ProductRatingDefinitionType!
  getCorporateRatings(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CorporateRatingPaginateType!
  getAllCorporateRatings: [CorporateRatingType!]!
  getCorporateRatingsBytarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): CorporateRatingPaginateType!
  getCorporateRatingsByProduct(
    pagination: PaginationInput = { page: 0, limit: 20 }

    # The internal product id.
    productId: ID!
  ): CorporateRatingPaginateType!
  getCurrentUserCorporateRatingsByProduct(
    # The internal product id.
    productId: ID!
  ): CorporateRatingType!
  getCorporateRatingsByProductWithStats(
    pagination: PaginationInput = { page: 0, limit: 20 }

    # The internal product id.
    productId: ID!
  ): CorporateRatingWithStatsPaginatedType!
  getAverageCorporateProductRatingsByProduct(
    # The product id.
    productId: ID!
  ): AverageRatingType!
  corporateRating(id: ID!): CorporateRatingType!
  getCorporateRatingAssignments(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CorporateRatingAssignmentPaginateType!
  getAllCorporateRatingAssignments: [CorporateRatingAssignmentType!]!
  corporateRatingAssignment(id: ID!): CorporateRatingAssignmentType!
  getCorporateRatingAssignmentByTarget(
    target: TargetACIInput!
  ): [CorporateRatingAssignmentType!]!
  getCorporateRatingDefinitions(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CorporateRatingDefinitionPaginateType!
  getAllCorporateRatingDefinitions: [CorporateRatingDefinitionType!]!
  corporateRatingDefinition(id: String!): CorporateRatingDefinitionType!
  getCorporateRatingDefinitionByReviewType(
    reviewType: String!
  ): CorporateRatingDefinitionType!
  getFeaturedCorporates: [FeaturedCorporateType!]!
  getFeaturedCorporatesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: FeaturedCorporateTargetEnum!
  ): FeaturedCorporatePaginateType!
  getGeneralSEO(target: TargetACIInput!): ContentType!
  getGeneralSEOJSON(target: TargetACIInput!): ContentJSONType!
  getMainPageSEO(target: TargetACIInput!): ContentType!
  getMainPageSEOJSON(target: TargetACIInput!): ContentJSONType!
  getMainCategorySEO(categoryId: ID!): ContentType!
  getMainCategorySEOJSON(categoryId: ID!): ContentJSONType!
  getSubCategorySEO(categoryId: ID!): ContentType!
  getSubCategorySEOJSON(categoryId: ID!): ContentJSONType!
  getProductSEO(barcodeId: ID!, target: TargetACIInput!): ContentType!
  getProductSEOJSON(barcodeId: ID!, target: TargetACIInput!): ContentJSONType!
  getSimpleProductSEOJSON(
    barcodeId: ID!
    target: TargetACIInput!
  ): ContentJSONType!
  getPagesSEO(pageId: ID!): ContentType!
  getPagesSEOJSON(pageId: ID!): ContentJSONType!
  getSEOs: [SEOType!]!
  getSEO(id: ID!): SEOType!
  getSEOPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedSEOType!
  findSEOByTarget(target: TargetACIInput!): SEOType!
  findSEOByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): PaginatedSEOType!
  getVisuals: [VisualsType!]!
  visuals(id: ID!): VisualsType!
  getPaginatedVisuals(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedVisualsType!
  findVisualsByTarget(target: TargetACIInput!): VisualsType!
  findVisualsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): PaginatedVisualsType!
  getLandingPages: [LandingPagesType!]!
  getLandingPagesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedLandingPagesType!
  landingPage(id: String!): LandingPagesType!
  findLandingPagesByTarget(target: TargetACIInput!): [LandingPagesType!]!
  findLandingPagesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): PaginatedLandingPagesType!
  findLandingPagesByTargetAndTypePaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    pageType: [LandingPageTypeEnum!]!
    target: TargetACIInput!
  ): PaginatedLandingPagesType!
  findLandingPagesByTargetAndTypeAndStatusPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    pageType: [LandingPageTypeEnum!]
    status: [VisibilityStatusEnum!]
    searchString: String
    target: TargetACIInput!
  ): PaginatedLandingPagesType!
  findLandingPagesByUrl(
    target: TargetACIInput!
    url: String!
  ): LandingPagesType!
  searchLandingPages(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): PaginatedLandingPagesType!
  getSlides: [SlidesType!]!
  getSlidesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedSlidesType!
  slide(id: String!): SlidesType!
  findSlidesByTarget(target: TargetACIInput!): [SlidesType!]!
  findSlideByTargetAndReference(
    reference: String!
    target: TargetACIInput!
  ): SlidesType!
  findSlidesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): PaginatedSlidesType!
  searchSlides(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): PaginatedSlidesType!
  getSubscribersToNewsletter(target: TargetACIInput!): [NewsletterType!]!
  getSubscribersToNewsletterPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): PaginatedNewslettersType!
  getNewslettersByExcel(
    path: String
    searchString: String
    target: TargetACIInput!
  ): InvoicePDFType!
  sendNewslettersBymail(
    subject: String!
    emails: [String!]
    searchString: String
    target: TargetACIInput
  ): MailResponseDto!
  getBlogs: [BlogType!]!
  getPaginatedBlogs(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedBlogsType!
  blog(id: String!): BlogType!
  findBlogsByTarget(target: TargetACIInput!): [BlogType!]!
  findBlogsByTargetAndUrl(url: String!, target: TargetACIInput!): BlogType!
  findBlogsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    status: [VisibilityStatusEnum!]
    target: TargetACIInput!
  ): PaginatedBlogsType!
  findBlogsByAuthor(author: String!): [BlogType!]!
  findBlogsByAuthorPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    author: String!
  ): PaginatedBlogsType!
  searchBlogs(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): PaginatedBlogsType!
  getCoupons: [CouponType!]!
  coupon(id: ID!): CouponType!
  findCouponByTargetAndCode(
    target: TargetACIInput!
    couponCode: String!
  ): CouponType!
  isCouponValid(
    target: TargetACIInput!
    couponCode: String!
  ): IsCouponValidType!
  getPaginatedCoupons(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedCouponType!
  findCouponsByTarget(target: TargetACIInput!): [CouponType!]!
  findCouponsByTargetWithFilterPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: CouponFilterInput
    searchString: String
    target: TargetACIInput!
  ): PaginatedCouponType!
  getCouponsByExcel(
    filter: CouponFilterInput
    path: String
    searchString: String
    target: TargetACIInput!
  ): InvoicePDFType!
  sendCouponsBymail(
    filter: CouponFilterInput
    subject: String!
    emails: [String!]
    searchString: String
    target: TargetACIInput
  ): MailResponseDto!
  getCorporateUserCards: [CorporateUserCardType!]!
  corporateUserCard(id: ID!): CorporateUserCardType!
  findCurrentCorporateUserCards: [CorporateUserCardType!]!
  findCurrentCorporateUserCardsByTarget(
    target: TargetACIInput!
  ): [CorporateUserCardType!]!
  corporateUserCardByIdentifier(identifier: String!): CorporateUserCardType!
  getCorporateUserCardsByUser(userId: ID!): [CorporateUserCardType!]!
  getCorporateUserCardsByTarget(
    target: TargetACIInput!
  ): [CorporateUserCardType!]!
  getCorporateUserCardsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    cardType: CardTypeEnum
    target: TargetACIInput!
  ): CorporateUserCardFullPaginatedType!
  getCorporateUserCardByUserAndTarget(
    target: TargetACIInput!
    userId: ID!
  ): [CorporateUserCardType!]!
  getOrderSettings: [OrderSettingsType!]!
  findOrderSettingsByQuery(query: String!): [OrderSettingsType!]!
  orderSettings(id: String!): OrderSettingsType!
  getOrderSettingsByTarget(target: TargetACIInput!): OrderSettingsFullType!
  getDeliveryZones: [DeliveryZonesType!]!
  getDeliveryZone(id: String!): DeliveryZonesType!
  findDeliveryZonesByTarget(target: TargetACIInput!): [DeliveryZonesType!]!
  getPurchases: [PurchaseType!]!
  getPaginatedPurchases(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedPurchaseType!
  purchase(id: ID!): PurchaseType!
  findPurchasesByTarget(target: TargetACIInput!): [PurchaseType!]!
  findPurchasesByTargetPaginated(
    target: TargetACIInput!
    reference: [String!]
    externalId: [String!]
    status: [PurchaseStatusEnum!]
    supplier: [ID!]
    user: [ID!]
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedPurchaseType!
  getSuppliers: [SupplierType!]!
  supplier(id: String!): SupplierType!
  getPaginatedSuppliers(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedSupplierType!
  findSuppliersByTarget(target: TargetACIInput!): [SupplierType!]!
  findSuppliersByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): PaginatedSupplierType!
  searchSupplierPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): PaginatedSupplierType!
  findBankById(id: ID!): BankType!
  getBanks: [BankType!]!
  findBanksPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BankPaginatedType!
  findBankDetailsById(id: ID!): BankDetailsType!
  findBanksDetailsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BankDetailsPaginatedType!
  countUnseenCorporateNotificationsByTarget(
    target: TargetACIInput!
  ): UnseenCorporateNotificationCountType!
  getCorporateNotificationsByUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): CorporateNotificationPaginateType!
  sendAdhocCorporateNotificationTest(
    input: CorporateNotificationInput!
  ): AdhocCorporateNotificationTestType!
  getFavoriteInternalProduct: [FavoriteInternalProductType!]!
  favoriteInternalProduct(id: String!): FavoriteInternalProductType!
  findFavoriteInternalProductByCurrentUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InternalProductPaginateType!
  getFavoriteSimpleProductByCurrentUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InternalProductWithBarcodesWithPublicPricePaginateType!
  searchFavoriteInternalProduct(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InternalProductPaginateType!
  isFavoriteInternalProduct(productId: String!): IsFavoriteInternalProductType!
  getRecentlyViewedProductsByUserPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): RecentlyViewedInternalProductWithFavoriteStatusPaginateType!
  getDepartments: [DepartmentType!]!
  department(id: ID!): DepartmentType!
  getDepartmentsByTarget(target: TargetACIInput!): [DepartmentType!]!
  searchDepartmentsByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): DepartmentPaginatedType!
  getJobDefinitions: [JobDefinitionType!]!
  jobDefinition(id: ID!): JobDefinitionType!
  getJobDefinitionsByTarget(target: TargetACIInput!): [JobDefinitionType!]!
  getJobDefinitionsByTargetPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): JobDefinitionPaginatedType!
  searchJobDefinitionsByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    status: [JobDefinitionStatusEnum!]
    target: TargetACIInput!
    searchString: String
  ): JobDefinitionPaginatedType!
  getJobDefinitionsByTargetAndStatusPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    status: JobDefinitionStatusEnum!
    target: TargetACIInput!
  ): JobDefinitionPaginatedType!
  getJobDefinitionsByExcel(
    path: String
    searchString: String
    status: [JobDefinitionStatusEnum!]
    target: TargetACIInput!
  ): InvoicePDFType!
  sendJobDefinitionsBymail(
    subject: String!
    emails: [String!]
    searchString: String
    status: [JobDefinitionStatusEnum!]
    target: TargetACIInput
  ): MailResponseDto!
  getJobApplications: [JobApplicationType!]!
  jobApplication(id: ID!): JobApplicationType!
  getJobApplicationsByTarget(target: TargetACIInput!): [JobApplicationType!]!
  getJobApplicationsByTargetPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): JobApplicationBasePaginatedType!
  getJobApplicationsByTargetAndStatusPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    status: JobApplicationStatusEnum!
    target: TargetACIInput!
  ): JobApplicationPaginatedType!
  getJobApplicationsByJobDefinition(
    pagination: PaginationInput = { page: 0, limit: 20 }
    jobDefinition: ID!
  ): JobApplicationPaginatedType!
  getJobApplicationsByTargetWithFilterPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: JobApplicationFilterInput!
    target: TargetACIInput!
    searchString: String
  ): JobApplicationBasePaginatedType!
  getJobApplicationsByExcel(
    path: String
    searchString: String
    filter: JobApplicationFilterInput
    target: TargetACIInput!
  ): InvoicePDFType!
  sendJobApplicationsByMail(
    subject: String!
    emails: [String!]
    searchString: String
    filter: JobApplicationFilterInput
    target: TargetACIInput
  ): MailResponseDto!
  getPromotions: [PromotionType!]!
  promotion(id: ID!): PromotionType!
  getPromotionsByTarget(target: TargetACIInput!): [PromotionType!]!
  getPromotionsByTargetPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: PromotionFilterBaseInput!
    searchString: String
    target: TargetACIInput!
  ): PromotionPaginateType!
  getFuturePromotionsByTargetPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): PromotionPaginateType!
  getOngoingPromotionsByTargetPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: PromotionFilterInput
    searchString: String
    target: TargetACIInput!
  ): PromotionWithInternalProductPaginateType!
  getSimpleOngoingPromotionsByTargetPaginate(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: PromotionFilterInput
    searchString: String
    target: TargetACIInput!
  ): PromotionPaginateType!
  findProductsToCompareByUserPaginate(
    user: ID
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InternalProductPaginateType!
  getWalletsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): WalletPaginateType!
  wallet(id: String!): WalletDtoType!
  walletByOwner(
    pos: ID
    user: ID
    wholesaler: ID
    manufacturer: ID
  ): WalletDtoType!
  isWalletAndCardInitialized(
    userId: String
  ): IsWalletAndCardInititalizedDtoType!
  getCurrentUserQuantitativeWallet: WalletOnePocketDtoType!
  getCurrentUserQualitativeWallet(
    target: TargetACIInput!
  ): WalletOnePocketDtoType!
  getTargetWallet(target: TargetACIInput!): WalletDtoType!
  getPointOfSalesWithWalletsForModule(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    moduleName: String!
  ): POSWithWalletPaginateType!
  walletOwnerHasEnoughBalance(
    pos: ID
    user: ID
    wholesaler: ID
    manufacturer: ID
    amount: Float!
    usage: PocketUsageType!
  ): WalletOwnerHasEnoughBalanceType!
  getTargetSubscribersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    status: [SubscriptionStatus!]!
  ): SubscribersWithReputationsPaginateType!
  searchTargetSubscribers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
    statuses: [SubscriptionStatus!]
  ): SubscribersWithReputationsPaginateType!
  getTargetSubscribersByExcel(
    path: String
    searchString: String
    statuses: [SubscriptionStatus!]
    target: TargetACIInput!
  ): InvoicePDFType!
  sendTargetSubscribersBymail(
    subject: String!
    emails: [String!]
    searchString: String
    statuses: [SubscriptionStatus!]
    target: TargetACIInput
  ): MailResponseDto!
  searchUserTargetSubscriptions(
    statuses: [SubscriptionStatus!]
    target: TargetACIInput!
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TargetPaginateType!
  getUserSubscribedTargets(
    statuses: [SubscriptionStatus!]
    userId: String
  ): [TargetType!]!
  getTargetStats(target: TargetACIInput!): StatsType!
  isUserSubscribedToTarget(
    target: TargetACIInput!
  ): IsUserSubscribedToTargetType!
  getQuests: [QuestType!]!
  quest(id: ID!): QuestType!
  getQuestsByTarget(target: TargetACIInput!): [QuestType!]!
  getQuestsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): QuestPaginateType!
  getQuestsByTargetAndCreatorPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): QuestPaginateType!
  findQuestsByCategoryAndTarget(target: TargetACIInput!): [QuestType!]!
  findPredefinedQuestsByTarget(
    target: TargetACIInput!
    filter: QuestsFilterInput
    searchString: String
  ): [QuestType!]!
  getQuestsByTargetAndUserAudiencePaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): QuestPaginateType!
  getQuestActions: [QuestActionType!]!
  getQuestActionsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): QuestActionPaginateType!
  getAvailableQuests(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): QuestPaginateType!
  getQuestsSuggestions(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): QuestPaginateType!
  getQuestReccurencyStatus(quest: ID!): QuestRecurrencyStatusType!
  getQuestActivities: [QuestActivityType!]!
  getQuestActivitiesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): QuestActivityPaginateType!
  getQuestActivitiesByQuestPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    quest: ID!
  ): QuestActivityPaginateType!
  getQuestActivitiesByQuest(quest: ID!): [QuestActivityType!]!
  questActivity(id: String!): QuestActivityType!
  getQuestActionDefinitions: [QuestActionDefinitionType!]!
  getQuestActionDefinitionsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): QuestActionDefinitionPaginateType!
  questActionDefinition(id: String!): QuestActionDefinitionType!
  getQuestTypes: [QuestTypeType!]!
  getQuestTypesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): QuestTypePaginateType!
  getQuestTypesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): QuestTypePaginateType!
  searchQuestTypesByTargetWithFilterPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    filter: QuestTypesFilterInput!
    target: TargetACIInput!
  ): QuestTypePaginateType!
  questType(id: ID!): QuestTypeType!
  getActivityTypes: [ActivityTypeType!]!
  activityType(id: ID!): ActivityTypeType!
  getActivityTypesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ActivityTypePaginateType!
  getPredefinedActivityTypesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ActivityTypePaginateType!
  getActivityLogs: [ActivityLogType!]!
  ActivityLog(id: String!): ActivityLogType!
  getPosTransactions(
    pagination: PaginationInput = { page: 0, limit: 20 }
    activityType: [ActivityLogTypeEnum!]
    posId: String!
  ): ActivityLogPaginateType!
  getTargetTransactions(
    pagination: PaginationInput = { page: 0, limit: 20 }
    activityType: [ActivityLogTypeEnum!]
    user: ID
    searchString: String
    target: TargetACIInput!
  ): ActivityLogPaginateType!
  getTargetTransactionsByExcel(
    path: String
    activityType: [ActivityLogTypeEnum!]
    user: ID
    searchString: String
    target: TargetACIInput!
  ): InvoicePDFType!
  sendTargetTransactionsBymail(
    activityType: [ActivityLogTypeEnum!]
    subject: String!
    emails: [String!]
    searchString: String
    target: TargetACIInput
  ): MailResponseDto!
  getActivityLogsPagination(
    status: [ActivityLogTypeEnum!]
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ActivityLogPaginateType!
  getReputationsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ReputationPaginateType!
  getReputations: [ReputationType!]!
  getReputationsByTarget(target: TargetACIInput!): [ReputationType!]!
  reputation(id: String!): ReputationType!
  getUserWalletWithReputations: WalletWithReputationDtoType!
  getOnsiteConverters: [OnsiteConverterType!]!
  getOnsiteConverterByTarget(target: TargetACIInput!): OnsiteConverterType!
  getOnsiteConverterAmount(
    target: TargetACIInput!
    reputationLevelId: String!
    amount: Float!
  ): RemunerationAmountType!
  getLiveLeaderboardByCyclePaginated(
    input: LeaderboardWithRequiredCycleInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeaderboardBasePaginatedType!
  getLiveLeaderboardByCycleByExcel(
    path: String
    input: LeaderboardWithRequiredCycleInput
  ): InvoicePDFType!
  sendLiveLeaderboardByCycleBymail(
    input: LeaderboardWithRequiredCycleInput
    subject: String!
    emails: [String!]
  ): MailResponseDto!
  getLeaderboardByCyclePaginated(
    input: LeaderboardWithRequiredCycleInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeaderboardPaginatedType!
  getLeaderboardDatesByCyclePaginated(
    input: LeaderboardWithOptionalCycleInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): EffectiveDatePaginatedType!
  getLeaderboardByDatesAndCyclePaginated(
    input: GetLeaderboardByDatesAndCycleInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeaderboardPaginatedType!
  getLeaderboard(id: ID!): LeaderboardType!
  getAudiences: [AudienceType!]!
  getAudiencesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AudiencePaginateType!
  getAudiencesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): AudienceReachPaginateType!
  audience(id: String!): AudienceType!
  getAudienceReach(
    segments: [AudienceSegmentInput!]!
    target: TargetACIInput!
  ): AudienceReachType!
  getAudienceUsersPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    id: String!
  ): CorporateUserPaginateType!
  getAudienceCriterias: [AudienceCriteriaType!]!
  getAudienceCriteriasPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AudienceCriteriaPaginateType!
  audienceCriteria(id: String!): AudienceCriteriaType!
  runSEOAudit(target: TargetACIInput!, startUrl: String!): SEOAuditType!
  runGoogleSearchAudit(target: TargetACIInput!): [GoogleSearchAuditType!]!
  getGoogleSearchAuditConfig: [GoogleSearchAuditConfigType!]!
  googleSearchAuditConfig(id: ID!): GoogleSearchAuditConfigType!
  getGoogleSearchAuditConfigByTarget(
    target: TargetACIInput!
  ): [GoogleSearchAuditConfigType!]!
  getGoogleMapsAuditConfig: [GoogleMapsAuditConfigType!]!
  googleMapsAuditConfig(id: ID!): GoogleMapsAuditConfigType!
  getGoogleMapsAuditConfigByTarget(
    target: TargetACIInput!
  ): [GoogleMapsAuditConfigType!]!
  runGoogleMapsAudit(target: TargetACIInput!): [GoogleMapsAuditType!]!
  runInstagramProfileAudit(
    target: TargetACIInput!
    usernames: [String!]!
  ): InstagramProfileAuditType!
  shoppingCart(id: ID!): ShoppingCartType!
  findShoppingCartByUser(id: ID): ShoppingCartType!
  findShoppingCartByUserAndTarget(
    target: TargetACIInput!
    id: ID
  ): ShoppingCartType!
  findTargetShoppingCarts(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): ShoppingCartsForTargetPaginatedType!
  validateShoppingCartByCurrentUser(
    location: LonLatInput
  ): [ValidatedCartProductType!]!
  calculateShoppingCart(
    products: [CartProductInput!]!
  ): CalculatedShoppingCartType!
  getMarketPlaceDashboardData(
    to: DateTime
    from: DateTime
  ): MarketPlaceOrderDashboardType!
  getEcommerceFinanceDashboardData(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetEcommerceFinanceDashboardDataType!
  getMenuBadges(user: ID, target: TargetACIInput!): GetMenuBadgesType!
  findTargetOrders(
    input: MarketPlaceOrderFilterInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): MarketPlaceOrderPaginateType!
  getTargetOrdersByExcel(
    path: String
    input: MarketPlaceOrderFilterInput!
  ): InvoicePDFType!
  sendTargetOrdersBymail(
    subject: String!
    emails: [String!]
    input: MarketPlaceOrderFilterInput!
  ): MailResponseDto!
  findTargetOrdersByCurrentUser(
    input: MarketPlaceOrderFilterConsumerInput
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): MarketPlaceOrderPaginateType!
  getDeliveryTargetOrders(
    open: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): MarketPlaceOrderPaginateType!
  getTargetOrderInvoice(orderId: ID!): InvoicePDFType!
  getMarketPlaceOrders: [MarketPlaceOrderDtoType!]!
  findMarketPlaceOrdersByUser(
    input: MarketPlaceOrderFilterConsumerInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): MarketPlaceOrderPaginateType!
  getOrderInstallment(installmentId: ID!, orderId: ID!): InstallmentType!
  exportMarketPlaceOrdersWithFilter(
    input: MarketPlaceOrderFilterInput!
  ): DocumentResultType!
  exportMarketPlaceOrdersWithFilterByMail(
    input: MarketPlaceOrderFilterInput!
    brand: EmailTempVariablesBrandInput!
    subject: String!
    emails: [String!]!
  ): MailResponseDto!
  getInvoiceStatuses: StringListType!
  getInvoicesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InvoicePaginateType!
  getInvoices: [InvoiceType!]!
  invoice(id: ID!): InvoiceType!
  findInvoiceByOrder(id: ID!): InvoiceType!
  searchInvoice(
    page: Int = 0
    limit: Int = 20
    searchString: String
    target: TargetACIInput
    statuses: [InvoiceStatus!]
  ): InvoicePaginateType!
  createPDFInvoice(watermark: Boolean!, id: String!): InvoicePDFType!
  sendPDFInvoiceBymail(
    watermark: Boolean!
    brand: EmailTempVariablesBrandInput!
    subject: String!
    email: String!
    id: String!
  ): MailResponseDto!
  getShortcutsByUserPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    userId: String!
  ): ShortcutPaginateType!
  getLabels: [LabelType!]!
  label(id: ID!): LabelType!
  getLabelsByTarget(target: TargetACIInput!): [LabelType!]!
  findLabelsByCategoryAndTarget(
    category: LabelTypeEnum!
    target: TargetACIInput!
  ): [LabelType!]!
  getNotes: [NotesType!]!
  getNote(id: ID!): NotesType!
  getNotesByTarget(target: TargetACIInput!): [NotesType!]!
  findNotesByLabelAndTarget(target: TargetACIInput!, label: ID!): [NotesType!]!
  getBoards: [BoardType!]!
  getBoard(id: ID!): BoardType!
  getBoardWithListsAndCards(id: ID!): BoardWithListsAndCardsType!
  getArchivedBoardCardsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    boardId: ID!
  ): BoardCardPaginateType!
  getBoardsByTarget(target: TargetACIInput!): [BoardType!]!
  getBoardsByTargetPaginated(
    filter: BoardsFilterInput
    category: BoardCategoryEnum!
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BoardPaginateType!
  getBoardsByMemberAndTarget(
    target: TargetACIInput!
    member: ID!
  ): [BoardType!]!
  getBoardsByMemberAndTargetPaginated(
    category: BoardCategoryEnum
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    member: ID!
  ): BoardPaginateType!
  getBoardLists: [BoardListType!]!
  getBoardList(id: ID!): BoardListType!
  getCRMBoard(target: TargetACIInput!): BoardWithListsAndCardsType!
  getMaintenanceBoard(target: TargetACIInput!): BoardWithListsAndCardsType!
  getBoardListByBoard(boardId: ID!): [BoardListType!]!
  getBoardCards: [BoardCardType!]!
  getBoardCardsByBoardList(boardList: ID!): [BoardCardType!]!
  getBoardCardsByBoardWithFilterPaginated(
    filter: BoardCardFilterInput
    board: ID!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): BoardCardPaginateType!
  getBoardCard(id: ID!): BoardCardType!
  getBoardCardsStatsWithFilter(
    filter: BoardCardStatsFilterInput!
    target: TargetACIInput!
  ): BoardCardsStatsResponseType!
  getTaskSections(target: TargetACIInput!): [TaskSectionType!]!
  getTaskSectionsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): TaskSectionPaginatedType!
  getTaskSectionsWithTasks(
    target: TargetACIInput!
    searchString: String
  ): [TaskSectionWithTasksType!]!
  getTaskSection(id: ID!): TaskSectionType!
  getTasks: [TaskType!]!
  getTask(id: ID!): TaskType!
  getTasksBySection(taskSection: ID!): [TaskType!]!
  getProjects: [ProjectType!]!
  project(id: ID!): ProjectType!
  getProjectsByTarget(target: TargetACIInput!): [ProjectType!]!
  getProjectsByTargetWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: ProjectFilterInput
    target: TargetACIInput!
    searchString: String
  ): ProjectPaginateType!
  getProjectsByExcel(
    path: String
    searchString: String
    filter: ProjectFilterInput
    target: TargetACIInput!
  ): InvoicePDFType!
  sendProjectsBymail(
    subject: String!
    emails: [String!]
    searchString: String
    filter: ProjectFilterInput
    target: TargetACIInput
  ): MailResponseDto!
  getProjectsTemplateByExcel(path: String): InvoicePDFType!
  sendProjectsTemplateBymail(
    emails: [String!]
    subject: String!
  ): MailResponseDto!
  getTickets: [TicketType!]!
  ticket(id: ID!): TicketType!
  getTicketsByTarget(target: TargetACIInput!): [TicketType!]!
  getTicketsByTargetWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: TicketsFilterInput!
    target: TargetACIInput!
    searchString: String
  ): TicketsPaginateType!
  getTicketsStatsWithFilter(
    filter: TicketsStatsFilterInput!
    target: TargetACIInput!
  ): TicketStatsType!
  getTicketsByExcel(
    path: String
    searchString: String
    filter: TicketsFilterInput
    target: TargetACIInput!
  ): InvoicePDFType!
  sendTicketsBymail(
    subject: String!
    emails: [String!]
    searchString: String
    filter: TicketsFilterInput
    target: TargetACIInput
  ): MailResponseDto!
  getComments: [CommentType!]!
  comment(id: ID!): CommentType!
  getCommentsByHolder(holder: CommentHolderInput!): [CommentType!]!
  getCommentsReplies(
    pagination: PaginationInput = { page: 0, limit: 20 }
    id: ID!
  ): CommentPaginateType!
  getCommentsByHolderPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    holder: CommentHolderInput!
  ): CommentPaginateType!
  getTimeTracks: [TimeTrackType!]!
  timetrack(id: ID!): TimeTrackType!
  getTimeTracksByHolder(holder: TimeTrackOnInput!): [TimeTrackType!]!
  getTimeTracksByHolderPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    holder: TimeTrackOnInput!
  ): TimeTrackPaginateType!
  findLoyaltySettingsByTarget(target: TargetACIInput!): LoyaltySettingsType!
  getGoogleAnalytics: [GoogleAnalyticsType!]!
  googleAnalytics(id: ID!): GoogleAnalyticsType!
  getGoogleAnalyticsByTarget(target: TargetACIInput!): GoogleAnalyticsType!
  getGoogleTagsSourceForEvent(
    input: GoogleAnalyticsEventDataInput!
    event: GARecommendedEventsEnum!
    target: TargetACIInput!
  ): ContentType!
  getFBPixel: [FBPixelType!]!
  fbPixel(id: ID!): FBPixelType!
  getFBPixelByTarget(target: TargetACIInput!): FBPixelType!
  getFacebookPixelSourceForEvent(
    input: FBPixelEventDataInput
    event: PixelRecommendedEventsEnum!
    target: TargetACIInput!
  ): ContentType!
  getFBCatalogSync: [FBCatalogSyncType!]!
  fbCatalog(id: ID!): FBCatalogSyncType!
  getFBCatalogSyncByTarget(target: TargetACIInput!): FBCatalogSyncType!
  findPluginById(id: ID!): PluginType!
  findPluginByURL(url: String!): PluginType!
  findPluginsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PluginPaginatedType!
  getTargetPlugins: [TargetPluginType!]!
  targetPlugin(id: ID!): TargetPluginType!
  findPluginByTargetAndPlugin(
    target: TargetACIInput!
    id: ID!
  ): TargetPluginType!
  getTargetPluginsByTarget(target: TargetACIInput!): [TargetPluginType!]!
  getFigamyIntegrations: [FigamyIntegrationType!]!
  getFigamyIntegration(id: ID!): FigamyIntegrationType!
  getFigamyIntegrationByTarget(target: TargetACIInput!): FigamyIntegrationType!
  getErpIntegration: [ErpIntegrationType!]!
  erpIntegration(id: ID!): ErpIntegrationType!
  getErpIntegrationByTarget(target: TargetACIInput!): ErpIntegrationType!
  getWidgetIntegration: [WidgetIntegrationType!]!
  widgetIntegration(id: ID!): WidgetIntegrationType!
  getWidgetIntegrationByTarget(target: TargetACIInput!): WidgetIntegrationType!
  findCounteryById(id: ID!): CountryType!
  getCountries: [CountryType!]!
  findCountriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CountryPaginatedType!
  findCurrencyById(id: ID!): CurrencyType!
  findCurrenciesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CurrencyPaginatedType!
  findStateById(id: ID!): StateType!
  getStates: [StateType!]!
  findStatesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): StatePaginatedType!
  findStatesByCountryPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    country: ID!
  ): StatePaginatedType!
  findLanguageById(id: ID!): LanguageType!
  getLanguages: [LanguageType!]!
  findlanguagesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LanguagePaginatedType!
  findSocialById(id: ID!): SocialType!
  findSocialByCode(code: String!): SocialType!
  findSocialsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): SocialPaginatedType!
  findPaymentById(id: ID!): PaymentType!
  findPaymentsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaymentPaginatedType!
  findPayments: [PaymentType!]!
  findBrowserById(id: ID!): BrowserType!
  findBrowsersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BrowserPaginatedType!
  findTechDeviceById(id: ID!): TechDeviceType!
  findTechDevicesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TechDevicePaginatedType!
  findTechDeviceBrandById(id: ID!): TechDeviceBrandType!
  findTechDeviceBrandsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TechDeviceBrandPaginatedType!
  findDeviceTypeById(id: ID!): TechDeviceTypeType!
  findDeviceTypesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TechDeviceTypePaginatedType!
  findOperatingSystemById(id: ID!): OperatingSystemType!
  findOperatingSystemsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): OperatingSystemPaginatedType!
  getCorporateTemplate: [CorporateTemplateType!]!
  template(id: ID!): CorporateTemplateType!
  findCorporateTemplateByName(
    name: CorporateTemplateTypeEnum!
  ): CorporateTemplateType!
  findCorporateTemplateByNameAndTarget(
    target: TargetACIInput!
    name: CorporateTemplateTypeEnum!
  ): CorporateTemplateType!
  getPricesCalculations(
    input: CalculationsInput!
  ): InvoicingPricesCalculationType!
  createInvoicingPDFDocument(
    document: EmailTempVariablesDocumentInput!
  ): InvoicePDFType!
  sendInvoicingPDFDocumentByEmail(
    document: EmailTempVariablesDocumentInput!
    subject: String!
    emails: [String!]
  ): MailResponseDto!
  getInvoicingByExcel(
    path: String
    filter: InvoicingFilterInput
    category: SequenceCategoryEnum!
    target: TargetACIInput!
  ): InvoicePDFType!
  sendInvoicingBymail(
    subject: String!
    emails: [String!]
    filter: InvoicingFilterInput
    category: SequenceCategoryEnum!
    target: TargetACIInput
  ): MailResponseDto!
  getRentalsInPeriod(input: RentalFilterInput!): [RentalType!]!
  getRentalsInPeriodPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    input: RentalFilterInput
  ): RentalPaginateType!
  getInvoicingTemplateByExcel(path: String): InvoicePDFType!
  sendInvoicingTemplateBymail(
    emails: [String!]
    subject: String!
  ): MailResponseDto!
  getQuotations: [QuotationType!]!
  quotation(id: ID!): QuotationType!
  getQuotationsByTarget(
    filter: InvoicingFilterInput
    target: TargetACIInput!
  ): [QuotationType!]!
  getQuotationsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InvoicingFilterInput
    target: TargetACIInput!
    searchString: String
  ): QuotationPaginateType!
  getQuotationsStatsWithFilter(
    filter: InvoicingStatsFilterInput
    target: TargetACIInput!
  ): QuotationsStatsType!
  getSaleOrders: [SaleOrderType!]!
  saleOrder(id: ID!): SaleOrderType!
  getSaleOrderesByTarget(target: TargetACIInput!): [SaleOrderType!]!
  getSaleOrdersByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InvoicingFilterInput
    target: TargetACIInput!
    searchString: String
  ): SaleOrderPaginateType!
  getSaleOrdersStatsWithFilter(
    filter: InvoicingStatsFilterInput
    target: TargetACIInput!
  ): SaleOrdersStatsType!
  getSaleIssueNotes: [SaleIssueNoteType!]!
  saleIssueNote(id: ID!): SaleIssueNoteType!
  getSaleIssueNotesByTarget(target: TargetACIInput!): [SaleIssueNoteType!]!
  getSaleIssueNotesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InvoicingFilterInput
    target: TargetACIInput!
    searchString: String
  ): SaleIssueNotePaginateType!
  getSaleIssueNotesStatsWithFilter(
    filter: InvoicingStatsFilterInput
    target: TargetACIInput!
  ): SaleIssueNoteStatsType!
  getSaleInvoices: [SaleInvoiceType!]!
  saleInvoice(id: ID!): SaleInvoiceType!
  getSaleInvoicesByTarget(target: TargetACIInput!): [SaleInvoiceType!]!
  getSaleInvoicesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InvoicingFilterInput
    target: TargetACIInput!
    searchString: String
  ): SaleInvoicePaginateType!
  getBarcodeStats(barcodeId: ID!): BarcodeStatsType!
  getInternalProductStats(internalProductId: ID!): BarcodeStatsType!
  getSaleInvoicesStatsWithFilter(
    filter: InvoicingStatsFilterInput
    target: TargetACIInput!
  ): SaleInvoicesStatsType!
  getSaleDeliveryNotes: [SaleDeliveryNoteType!]!
  saledeliverynote(id: ID!): SaleDeliveryNoteType!
  getSaleDeliveryNotesByTarget(
    target: TargetACIInput!
  ): [SaleDeliveryNoteType!]!
  getSaleDeliveryNotesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InvoicingFilterInput
    target: TargetACIInput!
    searchString: String
  ): SaleDeliveryNotePaginateType!
  getSaleDeliveryNoteStatsWithFilter(
    filter: InvoicingStatsFilterInput
    target: TargetACIInput!
  ): SaleInvoicesStatsType!
  getPurchaseOrders: [PurchaseOrderType!]!
  purchaseOrder(id: ID!): PurchaseOrderType!
  getPurchaseOrderesByTarget(target: TargetACIInput!): [PurchaseOrderType!]!
  getPurchaseOrdersByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InvoicingFilterInput
    target: TargetACIInput!
    searchString: String
  ): PurchaseOrderPaginateType!
  getPurchaseOrdersStatsWithFilter(
    filter: InvoicingStatsFilterInput
    target: TargetACIInput!
  ): SaleOrdersStatsType!
  getPurchaseInvoices: [PurchaseInvoiceType!]!
  purchaseInvoice(id: ID!): PurchaseInvoiceType!
  getPurchaseInvoicesByTarget(target: TargetACIInput!): [PurchaseInvoiceType!]!
  getPurchaseInvoicesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InvoicingFilterInput
    target: TargetACIInput!
    searchString: String
  ): PurchaseInvoicePaginateType!
  getPurchaseInvoicesStatsWithFilter(
    filter: InvoicingStatsFilterInput
    target: TargetACIInput!
  ): SaleInvoicesStatsType!
  getPurchaseDeliveryNotes: [PurchaseDeliveryNoteType!]!
  purchasedeliverynote(id: ID!): PurchaseDeliveryNoteType!
  getPurchaseDeliveryNotesByTarget(
    target: TargetACIInput!
  ): [PurchaseDeliveryNoteType!]!
  getPurchaseDeliveryNotesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InvoicingFilterInput
    target: TargetACIInput!
    searchString: String
  ): PurchaseDeliveryNotePaginateType!
  getPurchaseDeliveryNoteStatsWithFilter(
    filter: InvoicingStatsFilterInput
    target: TargetACIInput!
  ): SaleInvoicesStatsType!
  getLogistics: [LogisticType!]!
  logistic(id: ID!): LogisticType!
  getRentals: [RentalRefType!]!
  getRental(id: ID!): RentalRefType!
  getCompanyContacts: [CompanyContactType!]!
  companyContact(id: ID!): CompanyContactType!
  getCompanyContactsByCompany(company: ID!): [CompanyContactType!]!
  getCompanyContactsByCompanyPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    company: ID!
  ): CompanyContactPaginateType!
  getCompanyContactsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    phase: CustomerPhaseEnum!
    target: TargetACIInput!
  ): CompanyContactPaginateType!
  getCompanySettings: [CompanySettingsType!]!
  companySettings(id: ID!): CompanySettingsType!
  getCompanySettingsByCompany(company: ID!): CompanySettingsType!
  findDocumentById(id: ID!): DocumentType!
  getDocuments: [DocumentType!]!
  findDocumentsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): DocumentPaginatedType!
  findDocumentsByOwnerPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    owner: ID!
  ): DocumentPaginatedType!
  findContentTypeById(id: ID!): ContentTypeType!
  findContentTypeByName(name: String!): ContentTypeType!
  findContentTypeByType(type: String!): ContentTypeType!
  getContentTypes: [ContentTypeType!]!
  findContentTypesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ContentTypePaginatedType!
  findGlobalCategoryById(id: ID!): GlobalCategoryType!
  findGlobalCategoriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): GlobalCategoryPaginatedType!
  findGlobalCategoryByProviderAndIdentifier(
    identifier: Int!
    provider: GlobalCategoryProviderEnum!
  ): GlobalCategoryType!
  findGlobalCategoriesByProviderPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    provider: GlobalCategoryProviderEnum!
  ): GlobalCategoryPaginatedType!
  getGoogleAuthURL: GoogleAuthRedirectType!
  getNewToken(code: String!, userId: String!): GoogleSuccessType!
  getProfile(userId: String!): GmailProfileType!
  listDrafts(userId: String!): GmailDraftListType!
  getDraft(input: GmailGetDraftInput!, userId: String!): GmailDraftType!
  getGmailLabel(id: String!, userId: String!): GmailLabelType!
  listGmailLabels(userId: String!): [GmailLabelType!]!
  gmailMessageGet(
    input: GmailGetMessageInput!
    id: String!
    userId: String!
  ): GmailMessageType!
  gmailMessageImport(
    messageInput: GmailMessageInput!
    input: GmailImportMessageInput!
    userId: String!
  ): GmailMessageType!
  gmailMessageList(
    input: GmailListMessageInput!
    userId: String!
  ): GmailMessageListType!
  gmailMessageAttachments(
    id: String!
    messageId: String!
    userId: String!
  ): GmailMessagePartBodyType!
  getGmailThreads(
    input: GmailGetThreadsInput!
    id: String!
    userId: String!
  ): GmailThreadType!
  getGmailThreadsList(
    input: GmailListMessageInput!
    userId: String!
  ): GmailThreadListType!
  getGoogelDriveAbout(fields: String!, userId: String!): GoogleDriveAboutType!
  getGoogelDriveChangesToken(
    teamDriveId: String
    supportsTeamDrives: Boolean
    supportsAllDrives: Boolean
    fields: String
    driveId: String
    userId: String!
  ): GoogleDriveAboutChangesTokenType!
  getGoogelDriveChangesList(
    input: ListGoogleDriveChangesInput!
    userId: String!
  ): GoogleDriveChangesListType!
  listCalendarList(
    input: ListCalendarListInput!
    userId: String!
  ): GoogleCalendarListType!
  getCalendarList(
    calendarId: String!
    userId: String!
  ): GoogleCalendarListResourceType!
  watchCalendarList(
    input: WatchCalendarListInput!
    userId: String!
  ): GoogleCalendarListResourceType!
  getGoogleCalendar(
    calendarId: String!
    userId: String!
  ): GoogleCalendarResourceType!
  stopGoogleCalendarChannels(
    token: String!
    resourceId: String!
    id: String!
    userId: String!
  ): GoogleSuccessType!
  getGoogleCalendarColors(userId: String!): GoogleSuccessType!
  getGoogleCalendarEvent(
    timeZone: String
    maxAttendees: Int
    alwaysIncludeEmail: Boolean
    eventId: String!
    calendarId: String!
    userId: String!
  ): GoogleCalendarEventType!
  importGoogleCalendarEvent(
    input: GoogleCalendarEventInput!
    supportsAttachments: Boolean
    conferenceDataVersion: Int
    calendarId: String!
    userId: String!
  ): GoogleCalendarEventType!
  instancesGoogleCalendarEvent(
    input: GoogleCalendarInstancesInput!
    userId: String!
  ): GoogleCalendarEventInstancesType!
  listGoogleCalendarEvent(
    calendarId: String!
    userId: String!
  ): GoogleCalendarEventInstancesType!
  watchGoogleCalendarEvent(
    input: WatchCalendarListInput
    calendarId: String!
    userId: String!
  ): GoogleCalendarEventWatchType!
  freeBusyGoogleCalendar(
    input: FreeBusyCalendarInput!
    userId: String!
  ): GoogleCalendarFreeBusyType!
  getGoogleCalendarSettings(
    setting: String!
    userId: String!
  ): GoogleCalendarSettingsType!
  watchGoogleCalendarSettings(
    input: WatchCalendarListInput!
    userId: String!
  ): GoogleCalendarEventWatchType!
  validateCatalogueByExcel(
    path: String
    base64: String
  ): CatalogueImportValidationType!
  getPosTemplateByExcel(path: String): InvoicePDFType!
  sendPosTemplateBymail(emails: [String!], subject: String!): MailResponseDto!
  getCatalogueTemplateByExcel(path: String): InvoicePDFType!
  sendCatalogueTemplateBymail(
    emails: [String!]
    subject: String!
  ): MailResponseDto!
  getServicesCatalogueTemplateByExcel(path: String): InvoicePDFType!
  sendServicesCatalogueTemplateBymail(
    emails: [String!]
    subject: String!
  ): MailResponseDto!
  getFullCatalogueByExcel(
    path: String
    withStock: Boolean!
    target: TargetACIInput!
  ): InvoicePDFType!
  sendFullCatalogueBymail(
    subject: String!
    emails: [String!]
    withStock: Boolean!
    target: TargetACIInput
  ): MailResponseDto!
  getCustomersTemplateByExcel(path: String): InvoicePDFType!
  getSuppliersTemplateByExcel(path: String): InvoicePDFType!
  getAuthDashboardData(
    apps: [App!]
    to: DateTime
    from: DateTime
  ): AuthDashboardType!
  getAuthDashboardDataByApp(
    to: DateTime
    from: DateTime
  ): AuthDashboardByAppType!
  getCockpitDashboardPreviewByApp: AuthDashboardPreviewByAppType!
  getCockpitDashboardAnalyticsByApp: GetCockPitDashboardAnalyticsByAppType!
  getCockpitDashboardUsersAnalyticsByApp(
    to: DateTime!
    from: DateTime!
  ): GetCockPitDashboardUserAnalyticsByAppType!
  getCockpitDashboardSessionsAnalyticsByApp(
    to: DateTime!
    from: DateTime!
  ): [DurationsCountType!]!
  getCorporateDashboardData: CorporateDashboardType!
  getCorporateTargetDashboardData(
    target: TargetACIInput!
  ): CorporateTargetDashboardType!
  getCorporateUserAnalytics(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateUserAnalyticsType!
  getCorporateUserByDayInPeriodAnalytics(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateUserByDayInPeriodAnalyticsType!
  getCorporateUsersRequestsAnalytics(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateUsersRequestsAnalyticsType!
  getCorporateUsersDashboardData(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): CorporateUserDashboardType!
  getCorporateUsersTechnologiesDashboardData(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateUsersTechnologiesDashboardDataType!
  getCorporateWarehouseDashboardData(
    to: DateTime!
    from: DateTime!
    target: TargetACIInput!
  ): GetCorporateWarehouseDashboardDataType!
  getInventoryDashboardData: InventoryDashboardType!
  getBookingDashboardData(to: DateTime, from: DateTime): BookingDashboardType!
  getIntegrationSQL: u!
  getAnalyticsStats(input: AnalyticsDashboardInput!): AnalyticsStatsType!
  getAnalyticsUserByCountry(
    input: AnalyticsDashboardInput!
  ): AnalyticsUsersByCountryType!
  getAnalyticsSessionsByCountries(
    input: AnalyticsDashboardInput!
  ): [AnalyticsSessionsByCountriesType!]!
  getAnalyticsAudienceMetrics(
    input: AnalyticsDashboardInput!
  ): AnalyticsAudienceMetricsType!
  getAnalyticsAudienceSessionsByCountry(
    input: AnalyticsDashboardInput!
  ): [AnalyticsAudienceSessionsByCountryType!]!
  getAnalyticsUsersByDevice(
    input: AnalyticsDashboardInput!
  ): AnalyticsUsersByDeviceType!
  getAnalyticsTopReferralPages(
    input: AnalyticsDashboardInput!
  ): AnalyticsTopReferralPagesType!
  getAnalyticsTopPages(
    input: AnalyticsDashboardInput!
  ): [AnalyticsTopPagesType!]!
  getCollaborationAnalyticsStats(
    input: AnalyticsDashboardInput!
  ): CollaborationAnalyticsStatsType!
  getCollaborationProjectsOverview(
    input: AnalyticsDashboardInput!
  ): CollaborationAnalyticsProjectsOverviewType!
  getCollaborationProjectsStatus(
    input: AnalyticsDashboardInput!
  ): CollaborationAnalyticsProjectsStatusType!
  getCrmAnalyticsStats(
    input: AnalyticsDashboardInput!
  ): CrmAnalyticsStatsInfoType!
  getCrmAnalyticsSalesForecast(
    input: AnalyticsDashboardInput!
  ): CrmAnalyticsSalesForecastType!
  getCrmAnalyticsDealType(
    input: AnalyticsDashboardInput!
  ): [CrmAnalyticsDealTypeType!]!
  getCrmAnalyticsBalanceOverview(
    input: AnalyticsDashboardInput!
  ): CrmAnalyticsBalanceOverviewType!
  getEcommerceAnalyticsStats(
    input: AnalyticsDashboardInput!
  ): SalesAnalyticsStatsType!
  getEcommerceRevenueChartStats(
    input: AnalyticsDashboardInput!
  ): SalesAnalyticsRevenueStatsType!
  getEcommerceSalesByLocation(
    input: AnalyticsDashboardInput!
  ): SalesAnalyticsSalesByCountryType!
  getEcommerceTopCatalogueCategories(
    input: AnalyticsDashboardInput!
  ): [SalesAnalyticsTopCatalogueCategoriesType!]!
  getSalesAnalyticsStats(
    input: AnalyticsDashboardInput!
  ): SalesAnalyticsStatsType!
  getSalesRevenueChartStats(
    input: AnalyticsDashboardInput!
  ): SalesAnalyticsRevenueStatsType!
  getSalesByLocation(
    input: AnalyticsDashboardInput!
  ): SalesAnalyticsSalesByCountryType!
  getSalesTopCatalogueCategories(
    input: AnalyticsDashboardInput!
  ): [SalesAnalyticsTopCatalogueCategoriesType!]!
}

input EmailTempInput {
  to: [String!]!
  subject: String!
  template: EmailTemplateTypeEnum
  content: EmailContentInput
  variables: EmailTempVariablesInput
  attachments: [MailAttachmentInput!]
}

input EmailContentInput {
  base64: String
  path: String
}

input EmailTempVariablesInput {
  brand: EmailTempVariablesBrandInput
  user: EmailTempVariablesUserInput
  company: EmailTempVariablesCompanyInput
  actionUrl: String
  document: EmailTempVariablesDocumentInput
  variables: [String!]
}

input EmailTempVariablesBrandInput {
  logo: String
  website: String
  name: String
}

input EmailTempVariablesUserInput {
  firstName: String
  lastName: String
  email: String
}

input EmailTempVariablesCompanyInput {
  name: String
  website: String
  phone: String
  address: String
}

input EmailTempVariablesDocumentInput {
  category: SequenceCategoryEnum!
  id: ID!
  name: String!
}

enum SequenceCategoryEnum {
  QUOTATION
  SALE_ORDER
  SALE_INVOICE
  SALE_DELIVERY_NOTE
  SALE_ISSUE_NOTE
  PURCHASE_INVOICE
  PURCHASE_DELIVERY_NOTE
  PURCHASE_ORDER
}

input MailAttachmentInput {
  filename: String!
  content: String!
  encoding: String!
}

input CorporateEmailTempInput {
  to: [String!]!
  subject: String!
  template: EmailTemplateTypeEnum
  content: EmailContentInput
  variables: EmailTempVariablesInput
  attachments: [MailAttachmentInput!]
  target: TargetACIInput!
}

input TargetACIInput {
  # pos id
  pos: String

  # wholesaler id
  wholesaler: String

  # manufacturer id
  manufacturer: String

  # Commercial id
  user: String
}

input PaginationInput {
  page: Int = 0
  limit: Int = 20
}

input LoginInput {
  # Login email or username.
  login: String
  phone: IPhoneInput
  password: String!
}

input IPhoneInput {
  # Phone number
  number: String

  # Phone country code
  countryCode: String
}

input AuthorizationDataInput {
  email: String
  state: String
  givenName: String
  familyName: String
  identityToken: String!
  userIdentifier: String
  authorizationCode: String
}

input IsLoginForTargetExistInput {
  # Login email or username.
  login: String
  phone: IPhoneInput
  target: TargetACIInput!
}

input IsLoginExistInput {
  # Login email or username.
  login: String
  phone: IPhoneInput
}

enum MediaTypeEnum {
  VIDEO
  PICTURE
}

input BarcodeFindInput {
  product: ID
  internalProduct: ID
  productAttributesValues: [ID!]
}

input ProductSortInput {
  # 1 for sort by createdAt ascending and -1 for descending
  createdAt: Float

  # 1 for sort by updatedAt ascending and -1 for descending
  updatedAt: Float

  # 1 for sort by name ascending and -1 for descending
  name: Float

  # 1 for sort by price ascending and -1 for descending
  price: Float
}

input ProductFilterInput {
  fromPrice: String
  toPrice: String
  from: DateTime
  to: DateTime

  # list of productAttributes ids
  productAttributes: [String!]

  # list of barcodes ids
  barcodes: [ID!]

  # list of brands ids
  brand: [String!]

  # list of inventoryCategories ids
  category: [String!]
  class: [ProductClassEnum!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  rent: Boolean
}

input BarcodeWithVarietyAndStructureFilterInput {
  barcode: [String!]
  status: [ProductStatusEnum!]
  condition: [ProductConditionEnum!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  searchString: String
}

input InternalProductFilterInput {
  fromPrice: String
  toPrice: String
  from: DateTime
  to: DateTime

  # list of brands ids
  brand: [ID!]

  # list of inventoryCategories ids
  category: [ID!]
  target: TargetsInput
  attributesValues: [ID!]

  # list of catalogueCategories ids
  catalogueCategory: [ID!]

  # list of internalProduct classes
  class: [ProductClassEnum!]
  condition: [ProductConditionEnum!]
  status: [ProductStatusEnum!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  rent: Boolean
}

input TargetsInput {
  # list of pointOfSales ids
  pos: [ID!]

  # list of wholesalers ids
  wholesaler: [ID!]

  # list of manufacturers ids
  manufacturer: [ID!]
}

input SearchSimpleProductInput {
  target: TargetACIInput
  searchString: String
  status: [ProductStatusEnum!]
  pagination: PaginationInput = { page: 0, limit: 20 }
}

input BarcodesFilterInput {
  fromPrice: String
  toPrice: String
  from: DateTime
  to: DateTime

  # list of catalogueCategories ids
  catalogueCategory: [ID!]
}

input BarcodeFilterInput {
  barcode: [String!]
  status: [ProductStatusEnum!]
  condition: [ProductConditionEnum!]
}

input FollowerFilterInput {
  user: [String!]
  pos: [Float!]
  from: DateTime
  to: DateTime
}

input LocationFilterInput {
  locationType: [LocationTypeEnum!]
  from: DateTime
  to: DateTime
}

input AssigneeInput {
  user: String
  pos: String
  wholesaler: String
  manufacturer: String
}

input BookingFilterInput {
  user: [String!]
  pos: [String!]
  bookingNumber: [Float!]
  status: [BookingStatusEnum!]
  source: [BookingSourceEnum!]
  from: DateTime
  to: DateTime
}

enum BookingSourceEnum {
  APP
  PHONE
  EMAIL
  WEBSITE
  FACEBOOK
  INSTAGRAM
}

input PictureInput {
  width: Int
  height: Int
  x: Int
  y: Int
  alt: String
  baseUrl: String!
  path: String!
}

input ComplaintTargetInput {
  user: ID
  pos: ID
  wholesaler: ID
  manufacturer: ID
}

input StoriesFilterInput {
  forConsumer: Boolean = false

  # User id
  user: ID

  # Pos id
  pos: ID

  # wholesaler id
  wholesaler: ID

  # Manufacturer id
  manufacturer: ID

  # Group id
  group: ID
}

input TargetWithGroupInput {
  # pos id
  pos: ID

  # User id
  user: ID

  # Group id
  group: ID

  # wholesaler id
  wholesaler: ID

  # manufacturer id
  manufacturer: ID
}

input StoriesViewsStatusFilterInput {
  # User id
  user: [String!]

  # Pos id
  pos: [String!]

  # wholesaler id
  wholesaler: [String!]

  # manufacturer id
  manufacturer: [String!]

  # Group id
  group: ID
}

enum FeaturedCorporateTargetEnum {
  pos
  wholesaler
  manufacturer
}

enum VisibilityStatusEnum {
  DRAFT
  PUBLISHED
  DELETED
}

input CouponFilterInput {
  discountType: DiscountType
  expired: Boolean
  redeemed: Boolean
  couponCode: String
}

input CorporateNotificationInput {
  title: String
  userId: ID
  description: String
  picture: PictureInput
  target: TargetACIInput
  executedAt: DateTime
}

input JobApplicationFilterInput {
  jobDefinition: [String!]
  status: [JobApplicationStatusEnum!]
  from: DateTime
  to: DateTime
}

input PromotionFilterBaseInput {
  startDate: DateTime
  endDate: DateTime
  statuses: [PromotionStatusEnum!]
}

input PromotionFilterInput {
  startDate: DateTime
  endDate: DateTime
  statuses: [PromotionStatusEnum!]
  barcodes: [ID!]
}

input QuestsFilterInput {
  status: [QuestStatusEnum!]
}

input QuestTypesFilterInput {
  activityTypes: [ID!]
  maxActivities: NumberRangeInput
  rewardPoints: NumberRangeInput
  minCoins: NumberRangeInput
  fees: PriceRangeInput
  score: Boolean
  profile: Boolean
  admin: Boolean
  transition: Boolean
  condition: Boolean
  enable: Boolean
}

input NumberRangeInput {
  min: Float
  max: Float
}

input PriceRangeInput {
  min: String
  max: String
}

input LeaderboardWithRequiredCycleInput {
  cycle: LeaderboardCycleEnum!
  target: TargetACIInput
  searchString: String
}

input LeaderboardWithOptionalCycleInput {
  cycle: LeaderboardCycleEnum
  target: TargetACIInput
  searchString: String
}

input GetLeaderboardByDatesAndCycleInput {
  cycle: LeaderboardCycleEnum!
  target: TargetACIInput
  searchString: String
  end: String!
  start: String!
}

input AudienceSegmentInput {
  rank: Int
  criteria: ID
  filters: [AudienceSegmentFilterInput!]
}

input AudienceSegmentFilterInput {
  field: AudienceSegmentFilterFieldInput
  operator: OperatorEnum
  values: [AudienceSegmentFilterValuesInput!]
}

input AudienceSegmentFilterFieldInput {
  value: AudienceCriteriaFieldEnum
  action: ID
}

input AudienceSegmentFilterValuesInput {
  startDate: DateTime
  endDate: DateTime
  minValue: String
  maxValue: String
  values: [String!]
  value: String
  zone: AudienceSegmentFilterZoneInput
  languages: [ID!]
  reputations: [ID!]
  countries: [ID!]
  states: [ID!]
}

input AudienceSegmentFilterZoneInput {
  radius: Float
  type: ZoneTypesEnum
  paths: [DeliveryZonePathInput!]
}

input DeliveryZonePathInput {
  lng: Float!
  lat: Float!
  order: Float!
}

input LonLatInput {
  type: String!
  coordinates: [Float!]!
}

input CartProductInput {
  # barcode local db id
  barcode: ID!
  quantity: Int = 1
  rent: RentalRefInput
  priceCredit: PriceCreditInput
}

input RentalRefInput {
  location: String
  description: String
  status: RentalStatusEnum
  start: DateTime
  end: DateTime
  note: RentalNoteInput
}

input RentalNoteInput {
  return: String
  delivery: String
}

input PriceCreditInput {
  amount: String
  periodValue: Int
  periodCycle: RecurrenceType
}

input MarketPlaceOrderFilterInput {
  paymentMethod: [PaymentMethodsEnum!]
  orderType: [OrderTypeEnum!]
  orderStatus: [OrderStatus!]
  paymentStatus: [PaymentStatusEnum!]
  number: [String!]
  from: DateTime
  to: DateTime
  target: TargetACIInput
  user: [String!]
}

enum PaymentMethodsEnum {
  CASH
  CHECK
  APP_COINS
  CREDIT_CARD
  BANK_TRANSFER
  MOBILE_PAYMENT
  AUTOMATIC_DEBIT
  BILL_OF_EXCHANGE
}

input MarketPlaceOrderFilterConsumerInput {
  paymentMethod: [PaymentMethodsEnum!]
  orderType: [OrderTypeEnum!]
  orderStatus: [OrderStatus!]
  paymentStatus: [PaymentStatusEnum!]
  number: [String!]
  from: DateTime
  to: DateTime
}

input BoardsFilterInput {
  members: [ID!]
  projects: [ID!]
}

input BoardCardFilterInput {
  archived: Boolean
  boardList: [ID!]
  project: [ID!]
  barcode: [ID!]
  assignedTo: [ID!]
  customer: [ID!]
  procedure: [BoardCardProcedureEnum!]
  priority: [BoardCardPriorityEnum!]
}

input BoardCardStatsFilterInput {
  archived: Boolean
  boardList: [ID!]
  project: [ID!]
  barcode: [ID!]
  assignedTo: [ID!]
  customer: [ID!]
  procedure: [BoardCardProcedureEnum!]
  priority: [BoardCardPriorityEnum!]
  from: DateTime
  to: DateTime
}

input ProjectFilterInput {
  privacy: [ProjectPrivacyEnum!]
  status: [ProjectStatusEnum!]
  priority: [ProjectPriorityEnum!]
  members: [ID!]
  from: DateTime
  to: DateTime
}

input TicketsFilterInput {
  priority: [TicketPriorityEnum!]
  members: [ID!]
  attachments: [ID!]
  from: DateTime
  to: DateTime
  status: [TicketStatusEnum!]
}

input TicketsStatsFilterInput {
  priority: [TicketPriorityEnum!]
  members: [ID!]
  attachments: [ID!]
  from: DateTime
  to: DateTime
}

input CommentHolderInput {
  project: ID
  card: ID
  ticket: ID
  quotation: ID
  saleOrder: ID
  saleIssueNote: ID
  saleInvoice: ID
  saleDeliveryNote: ID
  purchaseDeliveryNote: ID
  purchaseInvoice: ID
  purchaseOrder: ID
}

input TimeTrackOnInput {
  project: ID
  card: ID
  ticket: ID
}

input GoogleAnalyticsEventDataInput {
  login: GoogleAnalyticsEventDataLoginInput
  signup: GoogleAnalyticsEventDataLoginInput
  search: GoogleAnalyticsEventDataSearchInput
  share: GoogleAnalyticsEventDataShareInput
  earn_virtual_currency: GoogleAnalyticsEventDataEarnVirtualCurrencyInput
  spend_virtual_currency: GoogleAnalyticsEventDataSpendVirtualCurrencyInput
  add_payment_info: GoogleAnalyticsEventDataAddPaymentInfoInput
  add_shipping_info: GoogleAnalyticsEventDataAddShippingInfoInput
  add_to_cart: GoogleAnalyticsEventDataAddToCartInput
  add_to_wishlist: GoogleAnalyticsEventDataWishlistInput
  begin_checkout: GoogleAnalyticsEventDataBeginCheckoutInput
  generate_lead: GoogleAnalyticsEventDataGenerateLeadInput
  purchase: GoogleAnalyticsEventDataPurchaseInput
  refund: GoogleAnalyticsEventDataRefundInput
  remove_from_cart: GoogleAnalyticsEventDataRemoveFromCartInput
  select_item: GoogleAnalyticsEventDataRemoveFromCartInput
  view_cart: GoogleAnalyticsEventDataViewCartInput
  view_item: GoogleAnalyticsEventDataSelectItemInput
}

input GoogleAnalyticsEventDataLoginInput {
  userId: ID!
  method: String!
}

input GoogleAnalyticsEventDataSearchInput {
  userId: String!
  query: String!
}

input GoogleAnalyticsEventDataShareInput {
  method: ShareMethodEnum!
  content_type: ShareContentTypeEnum!
  item_id: String!
}

enum ShareMethodEnum {
  REGULAR
  GOOGLE
  FACEBOOK
  APPLE
  TWITTER
}

enum ShareContentTypeEnum {
  PRODUCT
  CATEGORY
}

input GoogleAnalyticsEventDataEarnVirtualCurrencyInput {
  virtual_currency_name: PocketTypeEnum!
  value: Float!
}

input GoogleAnalyticsEventDataSpendVirtualCurrencyInput {
  virtual_currency_name: PocketTypeEnum!
  value: Float!
  item_name: String!
}

input GoogleAnalyticsEventDataAddPaymentInfoInput {
  payment: ID!
  coupon: ID!
  shoppingCart: ID!
}

input GoogleAnalyticsEventDataAddShippingInfoInput {
  shipping_tier: ShippingTierTypeEnum!
  coupon: ID!
  shoppingCart: ID!
}

enum ShippingTierTypeEnum {
  INTERNAL
  DPD
  GLS
  DHL
  POST
}

input GoogleAnalyticsEventDataAddToCartInput {
  coupon: ID!
  shoppingCart: ID!
}

input GoogleAnalyticsEventDataWishlistInput {
  product: ID!
}

input GoogleAnalyticsEventDataBeginCheckoutInput {
  coupon: ID!
  shoppingCart: ID!
}

input GoogleAnalyticsEventDataGenerateLeadInput {
  value: String!
}

input GoogleAnalyticsEventDataPurchaseInput {
  coupon: ID!
  order: ID!
}

input GoogleAnalyticsEventDataRefundInput {
  coupon: ID!
  product: ID!
  order: ID!
  quantity: Int!
}

input GoogleAnalyticsEventDataRemoveFromCartInput {
  product: ID!
  shoppingCart: ID!
  quantity: Int!
}

input GoogleAnalyticsEventDataViewCartInput {
  shoppingCart: ID!
}

input GoogleAnalyticsEventDataSelectItemInput {
  product: ID!
}

input FBPixelEventDataInput {
  AddPaymentInfo: FBPixelEventDataAddPaymentInfoInput
  AddToCart: FBPixelEventDataAddToCartInfoInput
  AddToWishlist: FBPixelEventDataAddToWishlistInfoInput
  CompleteRegistration: FBPixelEventDataCompleteRegistrationInfoInput
  InitiateCheckout: FBPixelEventDataInititeCheckoutInfoInput
  Lead: FBPixelEventDataLeadInfoInput
  Purchase: FBPixelEventDataInititeCheckoutInfoInput
  Search: FBPixelEventDataSearchInfoInput
  StartTrial: FBPixelEventDataTrialSubInfoInput
  Subscribe: FBPixelEventDataTrialSubInfoInput
  ViewContent: FBPixelEventDataViewContentInfoInput
}

input FBPixelEventDataAddPaymentInfoInput {
  shoppingCart: ID!
}

input FBPixelEventDataAddToCartInfoInput {
  product: ID!
  quantity: Int!
}

input FBPixelEventDataAddToWishlistInfoInput {
  product: ID!
}

input FBPixelEventDataCompleteRegistrationInfoInput {
  status: Boolean!
}

input FBPixelEventDataInititeCheckoutInfoInput {
  shoppingCart: ID!
}

input FBPixelEventDataLeadInfoInput {
  name: String!
}

input FBPixelEventDataSearchInfoInput {
  category: String!
  searchString: String!
}

input FBPixelEventDataTrialSubInfoInput {
  value: String!
  currency: String!
  predicted_ltv: String!
}

input FBPixelEventDataViewContentInfoInput {
  page: String
  product: String
}

input CalculationsInput {
  products: [InvoicingProductsInput!]!
  taxes: [ProductTaxesInput!]!
  discount: DiscountDtoInput
  isAvoir: Boolean = false
}

input InvoicingProductsInput {
  article: ID!
  label: String!
  description: String
  price: String!
  total: String!
  taxes: [ProductTaxesInput!]!
  quantity: Int!
  discount: DiscountDtoInput
  rent: RentalRefInput
}

input ProductTaxesInput {
  tax: ID!
  rank: Int!
}

input DiscountDtoInput {
  discountType: DiscountType!
  amount: String
}

input InvoicingFilterInput {
  number: [String!]
  status: [GenericInvoicingStatusEnum!]
  from: DateTime
  to: DateTime
}

input RentalFilterInput {
  from: DateTime!
  to: DateTime!
  target: TargetACIInput!
  projects: [ID!]
  origins: [RentalOriginEnum!]
}

enum RentalOriginEnum {
  ORDER
  INVOICE
  DELIVERY_NOTE
}

input InvoicingStatsFilterInput {
  number: [String!]
  from: DateTime
  to: DateTime
}

input GmailGetDraftInput {
  id: String
  format: GoogleGmailFormatEnum
}

enum GoogleGmailFormatEnum {
  minimal
  full
  raw
  metadata
}

input GmailGetMessageInput {
  format: GoogleGmailFormatEnum
  metadataHeaders: [String!]
}

input GmailMessageInput {
  raw: String
}

input GmailImportMessageInput {
  internalDateSource: InternalDateSourceEnum
  deleted: Boolean
  neverMarkSpam: Boolean
  processForCalendar: Boolean
}

enum InternalDateSourceEnum {
  receivedTime
  dateHeader
}

input GmailListMessageInput {
  maxResults: Int
  pageToken: String
  q: String
  labelIds: [String!]
  includeSpamTrash: Boolean
}

input GmailGetThreadsInput {
  format: GoogleGmailFormatThreadEnum
  metadataHeaders: [String!]
}

enum GoogleGmailFormatThreadEnum {
  minimal
  full
  metadata
}

input ListGoogleDriveChangesInput {
  pageToken: String!
}

input ListCalendarListInput {
  maxResults: Int
  minAccessRole: String
  pageToken: String
  showDeleted: Boolean
  showHidden: Boolean
  syncToken: String
}

input WatchCalendarListInput {
  id: String
  token: String
  type: String
  address: String
}

input GoogleCalendarEventInput {
  end: GoogleCalendarEventStartEndInput!
  start: GoogleCalendarEventStartEndInput!
  description: String
  summary: String
}

input GoogleCalendarEventStartEndInput {
  date: String
  dateTime: String
  timeZone: String
}

input GoogleCalendarInstancesInput {
  calendarId: String!
  eventId: String
  alwaysIncludeEmail: Boolean
  maxAttendees: Int
  maxResults: Int
  originalStart: String
  pageToken: String
  showDeleted: Boolean
  timeMax: String
  timeMin: String
  timeZone: String
}

input FreeBusyCalendarInput {
  timeMin: String
  timeMax: String
  timeZone: String
  groupExpansionMax: Int
  items: [CalendarIdInput!]
}

input CalendarIdInput {
  id: String
}

input AnalyticsDashboardInput {
  to: DateTime!
  from: DateTime!
  target: TargetACIInput
}

type Mutation {
  createEmailTemplate(input: EmailTemplateInput!): EmailTemplateType!
  updateEmailTemplate(input: EmailTemplateInput!, id: ID!): EmailTemplateType!
  deleteEmailTemplate(id: ID!): DeleteResponseDtoType!
  createCorporateEmailTemplate(
    input: CorporateEmailTemplateInput!
  ): CorporateEmailTemplateType!
  updateCorporateEmailTemplate(
    input: CorporateEmailTemplateInput!
    id: ID!
  ): CorporateEmailTemplateType!
  deleteCorporateEmailTemplate(id: ID!): DeleteResponseDtoType!
  register(
    brand: EmailTempVariablesBrandInput!
    subject: String!
    input: UserInput!
  ): LoginType!
  registerForApp(
    brand: EmailTempVariablesBrandInput!
    subject: String!
    input: UserInput!
  ): LoginType!
  registerForTarget(input: UserWithTargetInput!): LoginType!
  addUserForTarget(input: UserWithTargetInput!): CorporateUserType!
  processWelcomeMailForTarget(
    password: String
    token: String!
  ): CorporateUserType!
  sendForgotPasswordMailToTarget(
    email: String!
    subject: String
    target: TargetACIInput!
  ): MailResponseDto!
  resetPasswordForTarget(
    password: String!
    token: String!
    target: TargetACIInput!
  ): CorporateUserType!
  sendValidationEmailForTarget(
    subject: String!
    target: TargetACIInput!
    email: String!
  ): MailResponseDto!
  validateEmailForTarget(token: String!): CorporateUserType!
  saveCurrentCorporateUserStatus(
    target: TargetACIInput!
    status: UserStatus!
  ): UserType!
  updateVapidKey(input: VapidKeyInput!): VapidKeyType!
  createUser(
    variables: EmailTempVariablesInput
    subject: String!
    input: UserInput!
  ): UserType!
  createUserForApp(
    variables: EmailTempVariablesInput
    input: UserInput!
    subject: String!
  ): UserType!
  updateUser(input: UserUpdateInput!, id: ID!): UserType!
  updateCurrentUser(input: UserUpdateInput!): UserType!
  updateCurrentUserPassword(
    newPassword: String!
    oldPassword: String!
  ): UserType!
  updateCurrentUserPasswordForApp(
    newPassword: String!
    oldPassword: String!
  ): UserType!
  updateCurrentUserEmail(email: String!): LoginType!
  updateCurrentUserLogins(
    email: String
    username: String
    phone: IPhoneInput
  ): LoginType!
  updateUserPasswordForApp(newPassword: String!, id: ID!): UserType!
  updateCurrentUserApp(app: App!): UserType!
  updateUserApp(app: App!, id: String!): UserType!
  sendForgotPasswordMail(
    brand: EmailTempVariablesBrandInput
    subject: String!
    email: String!
  ): MailResponseDto!
  resetPassword(password: String!, token: String!): UserType!
  resetPasswordWithMailForApp(input: ResetPasswordForAppInput!): UserType!
  sendValidMail(
    subject: String!
    variables: EmailTempVariablesInput
  ): MailResponseDto!
  sendMergeAccountsEmail(
    app: App!
    ooredooId: String!
    email: String!
  ): MailResponseDto!
  validateMail(token: String!): UserType!
  validatePhoneNumber(smsNumber: Int!): UserType!
  processWelcomeMail(password: String, token: String!): UserType!
  mergeAccounts(token: String!): UserType!
  deleteUser(
    description: String
    reason: DeleteUserReasonEnum!
    id: ID!
    password: String!
  ): DeleteResponseDtoType!
  saveCurrentUserStatus(status: UserStatus!): UserType!
  sendRegistrationValidationSms(
    app: App!
    phone: IPhoneInput!
  ): SmsIntegrationType!
  sendValidSms(app: App!): SmsIntegrationType!
  resetPasswordWithSmsForApp(input: ResetPasswordForAppInput!): UserType!
  insertOrigin(url: String!): OriginType!
  createMessage(input: MessageInput!): MessageType!
  createDirectMessage(input: DirectMessageInput!): MessageType!
  sendMessageToTarget(input: SendMessageToTargetInput!): MessageType!
  markMessageAsSeen(id: ID!): MessageType!
  markAllMessageAsSeen(
    # message group Id.
    messageGroup: ID!
  ): DeleteResponseDtoType!
  markAllMessagesAsSeenForTarget(
    # message group Id.
    messageGroup: ID!
    target: TargetACIInput
  ): DeleteResponseDtoType!
  createMessageGroup(input: MessageGroupInput): MessageGroupType!
  archiveMessageGroup(id: ID!): MessageGroupType!
  unarchiveMessageGroup(id: ID!): MessageGroupType!
  muteMessageGroup(id: ID!): MessageGroupType!
  unmuteMessageGroup(id: ID!): MessageGroupType!
  addMemeberToMessageGroup(user: [ID!]!, id: ID!): MessageGroupType!
  removeMemberFromMessageGroup(user: [ID!]!, id: ID!): MessageGroupType!
  updateMessageGroup(input: MessageGroupUpdateInput!): MessageGroupType!
  createNewVersion(input: NewVersionInput!): VersionType!
  updateVersion(input: UpdateVersionInput!): VersionType!
  insertStaticData(input: StaticDataInput!): StaticDataType!
  createPartnerReferral(input: PartnerReferralInput!): PartnerReferralType!
  updatePartnerReferral(
    input: PartnerReferralInput!
    id: String!
  ): PartnerReferralType!
  deletePartnerReferral(id: ID!): PartnerReferralType!
  updateBarcode(input: BarcodeUpdateInput!): BarcodeType!
  bulkUpdateBarcodeMedia(input: [UpdateMediaInput!]!): [BarcodeType!]!
  createCompany(input: CompanyInput!): CompanyType!
  updateCompany(input: CompanyUpdateInput!, id: ID!): CompanyType!
  bulkUpdateCompanyMedia(input: [UpdateMediaInput!]!): [CompanyType!]!
  deleteCompany(id: ID!): DeleteResponseDtoType!
  createLoyaltyProgram(input: LoyaltyProgramInput!): LoyaltyProgramType!
  updateLoyaltyProgram(
    input: LoyaltyProgramInput!
    id: String!
  ): LoyaltyProgramType!
  deleteLoyaltyProgram(id: ID!): LoyaltyProgramType!
  createManufacturer(input: ManufacturerCreateInput!): ManufacturerType!
  updateManufacturer(input: ManufacturerUpdateInput!): ManufacturerType!
  deleteManufacturer(id: String!): ManufacturerType!
  createPointOfSale(input: PointOfSaleInput!): PointOfSaleType!
  updatePointOfSale(input: PointOfSaleInput!, id: ID!): PointOfSaleType!
  deletePointOfSale(id: ID!): PointOfSaleType!
  createAccount(input: AccountInput!): AccountType!
  addTargetsToAccount(
    targets: TargetsInput!
    roles: [UserPOSRoleEnum!]!
    userId: String!
  ): AccountType!
  updateAccount(expiresAt: DateTime!, accountId: String!): AccountType!
  updateAccountByAdmin(
    input: AccountUpdateInput!
    accountId: String!
  ): AccountType!
  deleteAccount(accountId: String!): DeleteResponseDtoType!
  createPOSCategory(input: POSCategoryInput!): POSCategoryType!
  updatePOSCategory(input: POSCategoryInput!, id: String!): POSCategoryType!
  deletePOSCategory(id: String!): POSCategoryType!
  createCatalogueCategory(
    input: CatalogueCategoryInput!
  ): CatalogueCategoryType!
  reorderCatalogueCategories(
    target: TargetACIInput!
    catalogCategoryId: String!
    newRank: Float!
  ): [CatalogueCategoryType!]!
  syncOneCategory(input: CatalogueCategoryBulkInput!): CatalogueCategoryType!
  updateCatalogueCategory(
    input: CatalogueCategoryUpdateInput!
  ): CatalogueCategoryType!
  deleteCatalogueCategory(id: ID!): DeleteResponseDtoType!
  createPOSServices(input: POSServicesInput!): POSServicesType!
  updatePOSServices(input: POSServicesInput!, id: String!): POSServicesType!
  deletePOSServices(id: String!): POSServicesType!
  createWholesaler(input: WholesalerCreateInput!): WholesalerType!
  updateWholesaler(input: WholesalerUpdateInput!): WholesalerType!
  deleteWholesaler(id: String!): WholesalerType!
  createBrand(input: BrandInput!): BrandType!
  syncOneBrand(input: BrandInput!): BrandType!
  updateBrand(input: BrandInput!, id: String!): BrandType!
  deleteBrand(id: String!): DeleteResponseDtoType!
  createInventoryCategory(
    input: InventoryCategoryInput!
  ): InventoryCategoryType!
  updateInventoryCategory(
    input: InventoryCategoryInput!
    id: String!
  ): InventoryCategoryType!
  deleteInventoryCategory(id: String!): InventoryCategoryType!
  createProduct(input: ProductInput!): ProductType!
  updateProduct(input: ProductUpdateInput!, id: String!): ProductType!
  deleteProduct(id: String!): ProductType!
  createAttribute(input: AttributeCreateInput!): AttributeType!
  updateAttribute(input: AttributeUpdateInput!): AttributeType!
  syncOneAttribute(input: AttributeCreateInput!): AttributeType!
  deleteAttribute(id: String!): DeleteResponseDtoType!
  createAttributeValue(input: AttributeValueInput!): AttributeValueType!
  updateAttributeValue(input: AttributeValueUpdateInput!): AttributeValueType!
  syncOneAttributeValue(input: AttributeValueInput!): AttributeValueType!
  deleteAttributeValue(id: ID!): DeleteResponseDtoType!
  createProductAttribute(input: ProductAttributeInput!): ProductAttributeType!
  updateProductAttribute(
    input: ProductAttributeUpdateInput!
  ): ProductAttributeType!
  deleteProductAttribute(id: String!): DeleteResponseDtoType!
  createServiceProduct(
    target: TargetACIInput
    input: BarcodeInput!
  ): BarcodeType!
  createSimpleProduct(input: CreateSimpleProductInput!): InternalProductType!
  updateSimpleProduct(input: UpdateSimpleProductInput!): InternalProductType!
  createInternalProduct(
    input: CreateInternalProductInput!
  ): InternalProductType!
  createCustomInternalProduct(
    input: CreateCustomInternalProductInput!
  ): InternalProductType!
  createInternalProductAndProduct(
    externalId: String
    tags: [String!]
    discount: DiscountDtoInput
    internalProductAttributes: InternalProductAttributeInput

    # list of barcodes ids
    barcodes: [ID!]

    # list of suppliers ids
    suppliers: [ID!]
    price: String
    target: TargetACIInput!
    catalogueCategory: [ID!]!
    globalCategory: GlobalCategoryInput
    name: String!
    sku: String
    condition: ProductConditionEnum
    status: ProductStatusEnum
    description: String
    descriptionList: [String!]
    specs: [ProductSpecsInput!]
    picture: PictureInput
    pictures: [PictureInput!]
    media: MediaInput
    ean: String
    weight: Int
    class: [ProductClassEnum!]
    wholesalerPrice: String
    factoryPrice: String
    tax: String!
    structure: ProductStructureEnum
    brand: ID
    category: [ID!]
  ): InternalProductType!
  updateInternalProductAndProduct(
    externalId: String
    tags: [String!]
    discount: DiscountDtoInput
    internalProductAttributes: InternalProductAttributeInput

    # list of barcodes ids
    barcodes: [ID!]

    # list of suppliers ids
    suppliers: [ID!]
    price: String
    catalogueCategory: [ID!]
    globalCategory: GlobalCategoryInput
    name: String
    sku: String
    condition: ProductConditionEnum
    status: ProductStatusEnum
    description: String
    descriptionList: [String!]
    specs: [ProductSpecsInput!]
    picture: PictureInput
    pictures: [PictureInput!]
    media: MediaInput
    ean: String
    weight: Int
    class: [ProductClassEnum!]
    wholesalerPrice: String
    factoryPrice: String
    tax: String
    structure: ProductStructureEnum
    brand: ID
    category: [ID!]
    id: ID!
  ): InternalProductType!
  updateInternalProduct(
    input: UpdateInternalProductInput!
  ): InternalProductType!
  addBarcodeToInternalProductAndProduct(
    barcodeId: ID!
    productId: ID!
    id: ID!
  ): InternalProductType!
  deleteInternalProduct(id: ID!): DeleteResponseDtoType!
  createBarcode(target: TargetACIInput, input: BarcodeInput!): BarcodeType!
  createBarcodeForTarget(
    target: TargetACIInput
    input: BarcodeInput!
  ): BarcodeType!
  deleteBarcode(id: String!): DeleteResponseDtoType!
  createFollower(input: FollowerInput!): FollowerType!
  unfollowTarget(target: TargetACIInput!): DeleteResponseDtoType!
  createLocation(input: LocationInput!): LocationType!
  updateLocation(input: LocationInput!, id: ID!): LocationType!
  deleteLocation(id: ID!): DeleteResponseDtoType!
  createTax(input: TaxInput!): TaxType!
  updateTax(input: TaxInput!, id: ID!): TaxType!
  deleteTax(id: ID!): DeleteResponseDtoType!
  createPrice(input: PriceInput!): PriceType!
  updatePrice(input: PriceInput!, id: ID!): PriceType!
  deletePrice(id: ID!): DeleteResponseDtoType!
  createRequest(input: RequestInput!): RequestType!
  updateRequestStatus(status: RequestStatusEnum!, id: ID!): RequestType!
  createModuleDefinition(input: ModulesDefinitionInput!): ModulesDefinitionType!
  updateModuleDefinition(
    input: ModulesDefinitionInput!
    id: String!
  ): ModulesDefinitionType!
  deleteModuleDefinition(id: ID!): ModulesDefinitionType!
  createModuleAssignment(input: ModulesAssignmentInput!): ModulesAssignmentType!
  updateModuleAssignment(
    input: ModulesAssignmentInput!
    id: String!
  ): ModulesAssignmentType!
  deleteModuleAssignment(id: String!): ModulesAssignmentType!
  markProductAsFavorite(productId: String!): ProductType!
  removeProductFromFavorites(productId: String!): ProductType!
  createOrUpdateFavoriteProducts(
    input: FavoriteProductInput!
  ): FavoriteProductType!
  createBookingType(input: BookingTypeInput!): BookingTypeType!
  updateBookingType(input: BookingTypeInput!, id: String!): BookingTypeType!
  deleteBookingType(id: ID!): BookingTypeType!
  createBookingSettings(input: BookingSettingsInput!): BookingSettingsFullType!
  updateBookingSettings(
    input: BookingSettingsUpdateInput!
    id: String!
  ): BookingSettingsFullType!
  createBooking(input: BookingInput!): BookingType!
  confirmBooking(id: String!): BookingType!
  closeBooking(id: String!): BookingType!
  cancelBookingByPos(id: String!): BookingType!
  cancelBookingByConsumer(id: String!): BookingType!
  markAllAsSeenForUser: NotificationResponse!
  markAllAsSeenForPOS(posId: String!): NotificationResponse!
  createAdhocNotification(
    executedAt: DateTime
    picture: PictureInput!
    description: String!
    title: String!
  ): NotificationFullType!
  createComplaint(input: ComplaintInput!): ComplaintType!
  updateComplaint(input: ComplaintUpdateInput!): ComplaintType!
  deleteComplaint(id: String!): DeleteResponseDtoType!
  createBookingAttribute(input: BookingAttributeInput!): BookingAttributeType!
  updateBookingAttribute(
    input: BookingAttributeInput!
    id: String!
  ): BookingAttributeType!
  deleteBookingAttribute(id: ID!): BookingAttributeType!
  initStock(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID
  ): StockType!
  addToStock(
    # stock id to add/remove to/from.
    id: ID!

    # quantity of products to add/remove to/from stock.
    quantity: Int!
    warehouse: ID
  ): StockType!
  addToStockCustom(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID

    # quantity of products to add/remove to/from stock.
    quantity: Int!
  ): StockType!
  removeFromStock(
    # stock id to add/remove to/from.
    id: ID!

    # quantity of products to add/remove to/from stock.
    quantity: Int!
    warehouse: ID
  ): StockType!
  removeFromStockCustom(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID

    # quantity of products to add/remove to/from stock.
    quantity: Int!
  ): StockType!
  removeAllFromStock(barcode: ID!): DeleteResponseDtoType!
  createStock(
    target: TargetACIInput!

    # barcodeId only provided if barcode is not.
    barcodeId: ID

    # barcode value only provided if barcodeId is not.
    barcode: String
    warehouse: ID
  ): StockType!
  updateStock(
    # stock id to update.
    id: ID!
    stockCapacity: Int
    minimumStockQuantity: Int
    pixel: StockPixelInput
    outOfStock: Boolean
    warehouse: ID
  ): StockType!
  resetStock(id: ID!): StockType!
  createBarcodeForTargetWithStock(
    target: TargetACIInput
    input: BarcodeInput!
  ): BarcodeType!
  deleteBarcodeWithstock(barcodeId: ID!): DeleteResponseDtoType!
  deleteStock(id: ID!): DeleteResponseDtoType!
  createWarehouse(input: WarehouseInput!): WarehouseType!
  updateWarehouse(input: WarehouseUpdateInput!, id: ID!): WarehouseType!
  bulkUpdateWarehouseMedia(input: [UpdateMediaInput!]!): [WarehouseType!]!
  deleteWarehouse(id: ID!): DeleteResponseDtoType!
  insertStory(input: StoriesInput!): StoriesType!
  markStoryAsSeen(id: ID!): StoriesType!
  deleteStory(id: ID!): DeleteResponseDtoType!
  createProductRating(input: ProductRatingInput!): ProductRatingType!
  updateProductRating(
    input: UpdateProductRatingInput!
    id: String!
  ): ProductRatingType!
  deleteProductRating(id: ID!): DeleteResponseDtoType!
  createProductRatingDefinition(
    input: ProductRatingDefinitionInput!
  ): ProductRatingDefinitionType!
  updateProductRatingDefinition(
    input: UpdateProductRatingDefinitionInput!
    id: String!
  ): ProductRatingDefinitionType!
  deleteProductRatingDefinition(id: ID!): DeleteResponseDtoType!
  createCorporateRating(input: CorporateRatingInput!): CorporateRatingType!
  updateCorporateRating(
    input: CorporateUpdateRatingInput!
    id: ID!
  ): CorporateRatingType!
  deleteCorporateRating(id: ID!): DeleteResponseDtoType!
  createCorporateRatingAssignment(
    input: CorporateRatingAssignmentInput!
  ): CorporateRatingAssignmentType!
  updateCorporateRatingAssignmentStatus(
    id: ID!
    active: Boolean!
  ): CorporateRatingAssignmentType!
  deleteCorporateRatingAssignment(id: ID!): DeleteResponseDtoType!
  createCorporateRatingDefinition(
    reviewType: String!
  ): CorporateRatingDefinitionType!
  updateCorporateRatingDefinition(
    reviewType: String!
    id: String!
  ): CorporateRatingDefinitionType!
  deleteCorporateRatingDefinition(id: ID!): DeleteResponseDtoType!
  createFeaturedCorporate(
    input: FeaturedCorporateInput!
  ): FeaturedCorporateType!
  updateFeaturedCorporateRank(rank: Float!, id: String!): FeaturedCorporateType!
  resetFeaturedCorporateRank: [FeaturedCorporateType!]!
  deleteFeaturedCorporate(id: String!): DeleteResponseDtoType!
  createSEO(input: SEOInput!): SEOType!
  updateSEO(input: UpdateSEOInput!, id: String!): SEOType!
  deleteSEO(id: ID!): DeleteResponseDtoType!
  createVisuals(input: VisualsInput!): VisualsType!
  updateVisuals(input: UpdateVisualsInput!, id: String!): VisualsType!
  deleteVisuals(id: ID!): DeleteResponseDtoType!
  createLandingPage(input: LandingPagesInput!): LandingPagesType!
  publishLandingPage(id: String!): LandingPagesType!
  updateLandingPage(
    input: UpdateLandingPagesInput!
    id: String!
  ): LandingPagesType!
  updateLandingPageStatus(
    status: VisibilityStatusEnum!
    id: String!
  ): LandingPagesType!
  deleteLandingPage(id: String!): LandingPagesType!
  createSlides(input: SlidesInput!): SlidesType!
  updateSlides(input: UpdateSlidesInput!, id: String!): SlidesType!
  deleteSlides(id: ID!): DeleteResponseDtoType!
  addUserToNewsLetter(target: TargetACIInput!, email: String!): NewsletterType!
  removeUserFromNewsLetter(
    target: TargetACIInput!
    email: String!
  ): DeleteResponseDtoType!
  createBlog(input: BlogInput!): BlogType!
  publishBlog(id: String!): BlogType!
  updateBlog(input: UpdateBlogInput!, id: String!): BlogType!
  deleteBlog(id: ID!): BlogType!
  generateEcomSitemapXml(target: TargetACIInput!): CorporateTemplateType!
  createCoupon(input: CouponInput!): CouponType!
  generateCoupons(input: CouponsInput!): [CouponType!]!
  updateCoupon(input: UpdateCouponInput!, id: ID!): CouponType!
  redeemCoupon(target: TargetACIInput!, couponCode: String!): CouponType!
  disableCoupon(id: String!): CouponType!
  generateCorporateUserCard(
    cardTypes: [CardTypeEnum!]
    target: TargetACIInput
    user: ID!
  ): GenerateUserCardType!
  updateCorporateUserCard(
    validUntil: DateTime!
    id: ID!
  ): CorporateUserCardType!
  expireCorporateUserCard(id: ID!): DeleteResponseDtoType!
  createOrderSettings(input: OrderSettingsInput!): OrderSettingsFullType!
  updateOrderSettings(
    input: OrderSettingsUpdateInput!
    id: String!
  ): OrderSettingsFullType!
  createDeliveryZone(input: DeliveryZonesInput!): DeliveryZonesType!
  updateDeliveryZone(
    input: OrderDeliveryZonesUpdateInput!
    id: String!
  ): DeliveryZonesType!
  reorderDeliveryZones(
    deliveryZoneId: String!
    target: TargetACIInput!
    newOrder: Float!
  ): [DeliveryZonesType!]!
  deleteDeliveryZone(id: ID!): DeleteResponseDtoType!
  createPurchase(input: PurchaseInput!): PurchaseType!
  updatePurchase(input: UpdatePurchaseInput!, id: ID!): PurchaseType!
  deletePurchase(id: ID!): DeleteResponseDtoType!
  createSupplier(input: SupplierInput!): SupplierType!
  updateSupplier(input: UpdateSupplierInput!, id: String!): SupplierType!
  deleteSupplier(id: String!): DeleteResponseDtoType!
  createBank(input: BankInput!): BankType!
  updateBank(input: BankInput!, id: ID!): BankType!
  deleteBank(id: ID!): DeleteResponseDtoType!
  createBankDetails(input: BankDetailsInput!): BankDetailsType!
  updateBankDetails(input: BankDetailsInput!, id: ID!): BankDetailsType!
  deleteBankDetails(id: ID!): DeleteResponseDtoType!
  markAllCorporateNotificationsAsSeenForUser(
    target: TargetACIInput!
  ): CorporateNotificationResponse!
  createAdhocCorporateNotification(
    input: CorporateNotificationInput!
  ): CorporateNotificationFullType!
  markInternalProductAsFavorite(productId: String!): InternalProductType!
  removeInternalProductFromFavorites(productId: String!): InternalProductType!
  markSimpleProductAsFavorite(productId: String!): InternalProductType!
  removeSimpleProductFromFavorites(productId: String!): InternalProductType!
  createOrUpdateFavoriteInternalProducts(
    input: FavoriteInternalProductInput!
  ): FavoriteInternalProductType!
  createRecentlyViewed(
    # product id.
    product: ID!
  ): SuccessResponseDtoType!
  createDepartment(input: DepartmentInput!): DepartmentType!
  updateDepartment(input: DepartmentInput!, id: ID!): DepartmentType!
  deleteDepartment(id: ID!): DeleteResponseDtoType!
  createJobDefinition(input: JobDefinitionInput!): JobDefinitionType!
  updateJobDefinition(
    input: JobDefinitionUpdateInput!
    id: ID!
  ): JobDefinitionType!
  deleteJobDefinition(id: ID!): DeleteResponseDtoType!
  createJobApplication(input: JobApplicationInput!): JobApplicationType!
  updateJobApplication(
    input: JobApplicationUpdateInput!
    id: ID!
  ): JobApplicationType!
  deleteJobApplication(id: ID!): DeleteResponseDtoType!
  createPromotion(input: PromotionInput!): PromotionType!
  updatePromotion(input: PromotionUpdateInput!, id: ID!): PromotionType!
  deletePromotion(id: ID!): DeleteResponseDtoType!
  addProductToComparator(input: CompareProductInput!): InternalProductType!
  removeProductCompareFromList(product: ID!): DeleteResponseDtoType!
  initQualitativeWallet(target: TargetACIInput!, user: String!): WalletDtoType!
  initTargetWallet(target: TargetACIInput!): WalletDtoType!
  initUserWallet: WalletDtoType!
  addUserWallet: WalletDtoType!
  increaseAmount(
    id: ID!
    amount: String!
    usage: PocketUsageType!
    pocketType: PocketTypeEnum!
    challenge: ID
    target: TargetACIInput
  ): WalletDtoType!
  deductAmount(
    id: ID!
    amount: String!
    usage: PocketUsageType!
    pocketType: PocketTypeEnum!
    challenge: ID
    target: TargetACIInput
  ): WalletDtoType!
  performTransaction(input: PerformTransactionInput!): DeleteResponseDtoType!
  requestSubscription(input: SubscribersInput!): SubscribersFullType!
  subscribeUserToTarget(
    target: TargetACIInput!
    user: String!
  ): SubscribersFullType!
  approveSubscription(
    # Subscription id.
    id: ID!
  ): SubscribersFullType!
  rejectSubscription(
    # Subscription id.
    id: ID!
  ): SubscribersFullType!
  cancelSubscription(userId: ID!, target: TargetACIInput!): SubscribersFullType!
  deleteSubscriber(
    # Subscription id.
    id: ID!
  ): DeleteResponseDtoType!
  createQuest(input: QuestInput!): QuestType!
  updateQuest(input: QuestInput!, id: ID!): QuestType!
  removeAudienceFromQuest(id: ID!): QuestType!
  deleteQuest(id: ID!): DeleteResponseDtoType!
  finishQuest(id: String!): QuestType!
  performQuestActivityByUser(id: String!): QuestActionType!
  createQuestActivity(input: QuestActivityInput!): QuestActivityType!
  updateQuestActivity(input: QuestActivityInput!, id: ID!): QuestActivityType!
  reorderQuestActivity(order: Int!, id: ID!): QuestActivityType!
  deleteQuestActivity(id: ID!): DeleteResponseDtoType!
  createQuestActionDefinition(
    input: QuestActionDefinitionInput!
  ): QuestActionDefinitionType!
  updateQuestActionDefinition(
    input: QuestActionDefinitionInput!
    id: ID!
  ): QuestActionDefinitionType!
  resetQuestActionDefinition(
    input: QuestActionDefinitionInput!
    id: ID!
  ): QuestActionDefinitionType!
  deleteQuestActionDefinition(id: ID!): DeleteResponseDtoType!
  createQuestType(input: QuestTypeInput!): QuestTypeType!
  updateQuestType(input: QuestTypeInput!, id: ID!): QuestTypeType!
  deleteQuestType(id: ID!): DeleteResponseDtoType!
  createActivityType(input: ActivityTypeInput!): ActivityTypeType!
  updateActivityType(
    input: ActivityTypeUpdateInput!
    id: ID!
  ): ActivityTypeType!
  deleteActivityType(id: ID!): DeleteResponseDtoType!
  initReputations(target: TargetACIInput!): [ReputationType!]!
  updateReputationLevelPoints(points: Float!, id: String!): [ReputationType!]!
  updateTargetReputation(input: UpdateReputationInput!): ReputationType!
  deleteTargetReputation(id: String!): DeleteResponseDtoType!
  createOrUpdateOnsiteConverter(
    input: OnsiteConverterInput!
    target: TargetACIInput!
  ): OnsiteConverterType!
  pushOnsiteConverterAmount(
    input: PushConverterInput!
    target: TargetACIInput!
  ): PushAmountResponseType!
  createAudience(input: AudienceInput!): AudienceType!
  updateAudience(input: AudienceInput!, id: ID!): AudienceType!
  deleteAudience(id: ID!): DeleteResponseDtoType!
  createAudienceCriteria(input: AudienceCriteriaInput!): AudienceCriteriaType!
  updateAudienceCriteria(
    input: AudienceCriteriaInput!
    id: ID!
  ): AudienceCriteriaType!
  deleteAudienceCriteria(id: ID!): DeleteResponseDtoType!
  createGoogleSearchAuditConfig(
    input: GoogleSearchAuditConfigInput!
  ): GoogleSearchAuditConfigType!
  updateGoogleSearchAuditConfig(
    input: GoogleSearchAuditConfigInput!
    id: ID!
  ): GoogleSearchAuditConfigType!
  deleteGoogleSearchAuditConfig(id: ID!): DeleteResponseDtoType!
  createGoogleMapsAuditConfig(
    input: GoogleMapsAuditConfigInput!
  ): GoogleMapsAuditConfigType!
  updateGoogleMapsAuditConfig(
    input: GoogleMapsAuditConfigInput!
    id: ID!
  ): GoogleMapsAuditConfigType!
  deleteGoogleMapsAuditConfig(id: ID!): DeleteResponseDtoType!
  addDiscoutToCart(input: DiscountDtoInput!, id: ID!): ShoppingCartType!
  addToCart(
    target: TargetACIInput
    product: CartProductInput!
  ): ShoppingCartType!
  updateProductCredit(
    productToAdd: CartProductUpdateCreditInput!
    productToRemove: CartProductInput!
  ): ShoppingCartType!
  removeFromCart(
    target: TargetACIInput
    product: CartProductInput!
  ): ShoppingCartType!
  emptyCart: ShoppingCartType!
  createTargetOrderByCart(
    subject: String!
    input: MarketPlaceOrderInput!
    target: TargetACIInput!
  ): [MarketPlaceOrderDtoType!]!
  createTargetOrderWithCart(
    input: MarketPlaceOrderWithCartInput!
  ): MarketPlaceOrderDtoType!
  createTargetOrderWithCartAndRegisterUser(
    input: MarketPlaceOrderWithCartAfterRegisterInput!
  ): MarketPlaceOrderWithLoginType!
  generateTargetOrderInvoice(
    description: String
    dueDate: DateTime!
    orderId: ID!
  ): InvoiceType!
  cancelProductByConsumer(
    input: MarketPlaceOrderProductInput!
  ): MarketPlaceOrderDtoType!
  cancelProductByTarget(
    input: MarketPlaceOrderProductInput!
    target: TargetACIInput
    subject: String!
  ): MarketPlaceOrderDtoType!
  payInstallments(input: InstallmentPaymentInput!): MarketPlaceOrderDtoType!
  updateProductStatus(
    input: MarketPlaceOrderStatusByPOSInput!
    target: TargetACIInput
    subject: String!
  ): MarketPlaceOrderDtoType!
  setProductReadyForPickup(
    input: MarketPlaceOrderProductInput!
  ): MarketPlaceOrderDtoType!
  acceptMarketplaceOrderDelivery(orderId: ID!): MarketPlaceOrderDtoType!
  cancelMarketplaceOrderDelivery(orderId: ID!): MarketPlaceOrderDtoType!
  cancelProductByDeliveryMan(
    input: MarketPlaceOrderProductInput!
  ): MarketPlaceOrderDtoType!
  createMarketPlaceOrder(
    input: MarketPlaceOrderInput!
  ): [MarketPlaceOrderDtoType!]!
  issueInvoice(id: String!): InvoiceType!
  cancelInvoice(id: String!): InvoiceType!
  getShortcutsByUser(userId: String!): [ShortcutType!]!
  insertShortcut(input: ShortcutInput!): ShortcutType!
  updateShortcut(input: ShortcutUpdateInput!, id: String!): ShortcutType!
  deleteShortcut(id: ID!): DeleteResponseDtoType!
  createLabel(
    name: String!
    category: LabelTypeEnum!
    icon: String
    color: String
    target: TargetACIInput!
  ): LabelType!
  updateLabel(
    name: String
    category: LabelTypeEnum
    icon: String
    color: String
    target: TargetACIInput
    id: ID!
  ): LabelType!
  deleteLabel(id: ID!): DeleteResponseDtoType!
  createNote(
    title: String!
    description: String
    picture: PictureInput
    tasks: [TaskInput!]
    labels: [ID!]!
    isArchived: Boolean
    target: TargetACIInput!
  ): NotesType!
  updateNote(
    title: String
    description: String
    picture: PictureInput
    tasks: [TaskInput!]
    labels: [ID!]
    isArchived: Boolean
    target: TargetACIInput
    id: ID!
  ): NotesType!
  deleteNote(id: ID!): DeleteResponseDtoType!
  createBoard(
    title: String!
    description: String
    category: BoardCategoryEnum
    icon: String
    members: [ID!]
    projects: [ID!]
    target: TargetACIInput!
  ): BoardType!
  updateBoard(
    title: String
    description: String
    category: BoardCategoryEnum
    icon: String
    members: [ID!]
    projects: [ID!]
    id: ID!
  ): BoardType!
  deleteBoard(id: ID!): DeleteResponseDtoType!
  createBoardList(
    name: String!
    rank: Int
    theme: String
    board: ID!
    identifier: MaintenanceBoardListEnum
  ): BoardListType!
  reorderBoardList(id: ID!, rank: Int!): [BoardListType!]!
  updateBoardList(
    name: String
    rank: Int
    theme: String
    board: ID
    identifier: MaintenanceBoardListEnum
    id: ID!
  ): BoardListType!
  deleteBoardList(id: ID!): DeleteResponseDtoType!
  createBoardCard(
    title: String!
    description: String
    dueDate: DateTime
    archived: Boolean
    priority: BoardCardPriorityEnum
    tags: [String!]
    pictures: [PictureInput!]
    boardList: ID
    project: ID
    barcode: ID
    tasks: [BoardCardTasksInput!]
    labels: [ID!]
    rank: Int
    assignedTo: [ID!]
    budget: String
    customer: ID
    procedure: [BoardCardProcedureInput!]
    attachments: [ID!]
  ): BoardCardType!
  createMaintenanceBoardCard(input: MaintenanceBoardCardInput!): BoardCardType!
  reorderBoardCards(id: ID!, rank: Int!): [BoardCardType!]!
  updateBoardCard(
    title: String
    description: String
    dueDate: DateTime
    archived: Boolean
    priority: BoardCardPriorityEnum
    tags: [String!]
    pictures: [PictureInput!]
    boardList: ID
    project: ID
    barcode: ID
    tasks: [BoardCardTasksInput!]
    labels: [ID!]
    rank: Int
    assignedTo: [ID!]
    budget: String
    customer: ID
    procedure: [BoardCardProcedureInput!]
    attachments: [ID!]
    id: ID!
  ): BoardCardType!
  updateBoardCardList(
    # board card id
    id: ID!

    # new board list id
    boardList: ID!

    # new rank in new list
    rank: Int!
  ): [BoardCardType!]!
  deleteBoardCard(id: ID!): DeleteResponseDtoType!
  createTaskSection(
    title: String!
    description: String
    tags: [String!]
    priority: TaskPriorityEnum!
    dueDate: DateTime
    completed: Boolean
    archived: Boolean
    rank: Int
    target: TargetACIInput!
  ): TaskSectionType!
  reorderTaskSections(id: ID!, rank: Int!): [TaskSectionType!]!
  updateTaskSection(
    title: String
    description: String
    tags: [String!]
    priority: TaskPriorityEnum
    dueDate: DateTime
    completed: Boolean
    archived: Boolean
    rank: Int
    id: ID!
  ): TaskSectionType!
  deleteTaskSection(id: ID!): DeleteResponseDtoType!
  createTask(
    title: String!
    description: String
    tags: [String!]
    priority: TaskPriorityEnum!
    dueDate: DateTime
    completed: Boolean
    archived: Boolean
    rank: Int
    taskSection: ID!
  ): TaskType!
  reorderTask(id: ID!, rank: Int!): [TaskType!]!
  updateTask(
    title: String
    description: String
    tags: [String!]
    priority: TaskPriorityEnum
    dueDate: DateTime
    completed: Boolean
    archived: Boolean
    rank: Int
    taskSection: ID
    id: ID!
  ): TaskType!
  deleteTask(id: ID!): DeleteResponseDtoType!
  createProject(input: ProjectInput!): ProjectType!
  updateProject(input: ProjectUpdateInput!): ProjectType!
  bulkUpdateProjectMedia(input: [UpdateMediaInput!]!): [ProjectType!]!
  importProjectsByExcel(
    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    target: TargetACIInput
  ): SuccessResponseDtoType!
  deleteProject(id: ID!): DeleteResponseDtoType!
  createTicket(input: TicketInput!): TicketType!
  updateTicket(input: TicketUpdateInput!): TicketType!
  bulkUpdateTicketMedia(input: [UpdateMediaInput!]!): [TicketType!]!
  deleteTicket(id: ID!): DeleteResponseDtoType!
  createComment(input: CommentInput!): CommentType!
  updateComment(input: CommentInput!, id: ID!): CommentType!
  deleteComment(id: ID!): DeleteResponseDtoType!
  createTimeTrack(input: TimeTrackInput!): TimeTrackType!
  updateTimeTrack(input: TimeTrackInput!, id: ID!): TimeTrackType!
  deleteTimeTrack(id: ID!): DeleteResponseDtoType!
  updateLoyaltySettings(
    input: LoyaltySettingsUpdateInput!
  ): LoyaltySettingsType!
  approveLoyaltySubscription(
    # Subscription id.
    id: ID!
  ): SubscribersFullType!
  onboardUserToTargetLoyalty(
    userId: ID!
    target: TargetACIInput!
  ): SuccessResponseDtoType!
  updateGoogleAnalytics(
    input: GoogleAnalyticsUpdateInput!
  ): GoogleAnalyticsType!
  updateGoogleAnalyticsEventStatus(
    event: GARecommendedEventsEnum!
    status: Boolean!
    id: ID!
  ): GoogleAnalyticsType!
  deleteGoogleAnalytics(id: ID!): DeleteResponseDtoType!
  updateFacebookPixel(input: FBPixelUpdateInput!): FBPixelType!
  updateFacebookPixelEventStatus(
    event: PixelRecommendedEventsEnum!
    status: Boolean!
    id: ID!
  ): FBPixelType!
  deleteFBPixel(id: ID!): DeleteResponseDtoType!
  updateFBCatalogSync(input: FBCatalogSyncUpdateInput!): FBCatalogSyncType!
  deleteFBCatalogSync(id: ID!): DeleteResponseDtoType!
  createPlugin(input: PluginInput!): PluginType!
  updatePlugin(input: PluginInput!, id: ID!): PluginType!
  deletePlugin(id: ID!): DeleteResponseDtoType!
  createTargetPlugin(input: TargetPluginInput!): TargetPluginType!
  updateTargetPlugin(input: TargetPluginUpdateInput!): TargetPluginType!
  deleteTargetPlugin(id: ID!): DeleteResponseDtoType!
  updateFigamyIntegration(
    input: FigamyIntegrationUpdateInput!
  ): FigamyIntegrationType!
  deleteFigamyIntegration(id: ID!): DeleteResponseDtoType!
  updateErpIntegration(input: ErpIntegrationUpdateInput!): ErpIntegrationType!
  updateErpIntegrationEventStatus(
    event: ErpElementsEnum!
    status: Boolean!
    id: ID!
  ): ErpIntegrationType!
  deleteErpIntegration(id: ID!): DeleteResponseDtoType!
  updateWidgetIntegration(
    input: WidgetIntegrationInput!
    id: ID!
  ): WidgetIntegrationType!
  activateWidgetIntegrationAction(
    input: WidgetIntegrationActionsInput!
    id: ID!
  ): WidgetIntegrationType!
  disableWidgetIntegrationAction(
    input: WidgetIntegrationActionsInput!
    id: ID!
  ): WidgetIntegrationType!
  deleteWidgetIntegration(id: ID!): DeleteResponseDtoType!
  createCountry(input: CountryInput!): CountryType!
  updateCountry(input: CountryInput!, id: ID!): CountryType!
  deleteCountry(id: ID!): DeleteResponseDtoType!
  createCurrency(input: CurrencyInput!): CurrencyType!
  updateCurrency(input: CurrencyInput!, id: ID!): CurrencyType!
  deleteCurrency(id: ID!): DeleteResponseDtoType!
  createState(input: StateInput!): StateType!
  updateState(input: StateInput!, id: ID!): StateType!
  deleteState(id: ID!): DeleteResponseDtoType!
  createLanguage(input: LanguageInput!): LanguageType!
  updateLanguage(input: LanguageInput!, id: ID!): LanguageType!
  deleteLanguage(id: ID!): DeleteResponseDtoType!
  createSocial(input: SocialInput!): SocialType!
  updateSocial(input: SocialInput!, id: ID!): SocialType!
  deleteSocial(id: ID!): DeleteResponseDtoType!
  createPayment(input: PaymentInput!): PaymentType!
  updatePayment(input: PaymentInput!, id: ID!): PaymentType!
  deletePayment(id: ID!): DeleteResponseDtoType!
  createBrowser(input: BrowserInput!): BrowserType!
  updateBrowser(input: BrowserInput!, id: ID!): BrowserType!
  deleteBrowser(id: ID!): DeleteResponseDtoType!
  createTechDevice(input: TechDeviceInput!): TechDeviceType!
  updateTechDevice(input: TechDeviceInput!, id: ID!): TechDeviceType!
  deleteTechDevice(id: ID!): DeleteResponseDtoType!
  createTechDeviceBrand(input: TechDeviceBrandInput!): TechDeviceBrandType!
  updateTechDeviceBrand(
    input: TechDeviceBrandInput!
    id: ID!
  ): TechDeviceBrandType!
  deleteTechDeviceBrand(id: ID!): DeleteResponseDtoType!
  createTechDeviceType(input: TechDeviceTypeInput!): TechDeviceTypeType!
  updateTechDeviceType(
    input: TechDeviceTypeInput!
    id: ID!
  ): TechDeviceTypeType!
  deleteTechDeviceType(id: ID!): DeleteResponseDtoType!
  createOperatingSystem(input: OperatingSystemInput!): OperatingSystemType!
  updateOperatingSystem(
    input: OperatingSystemInput!
    id: ID!
  ): OperatingSystemType!
  deleteOperatingSystem(id: ID!): DeleteResponseDtoType!
  createCorporateTemplate(
    input: CorporateTemplateInput!
  ): CorporateTemplateType!
  updateCorporateTemplate(
    input: CorporateTemplateInput!
    id: ID!
  ): CorporateTemplateType!
  refreshSitemapXml(
    target: TargetACIInput!
    urls: [String!]!
    hostname: String!
  ): CorporateTemplateType!
  deleteCorporateTemplate(id: ID!): DeleteResponseDtoType!
  importInvoicingByExcel(
    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    type: SequenceCategoryEnum
    target: TargetACIInput
  ): SuccessResponseDtoType!
  createQuotation(input: QuotationInput!): QuotationType!
  updateQuotation(input: QuotationUpdateInput!): QuotationType!
  deleteQuotation(id: ID!): DeleteResponseDtoType!
  createSaleOrder(input: SaleOrderInput!): SaleOrderType!
  updateSaleOrder(input: SaleOrderInput!, id: ID!): SaleOrderType!
  deleteSaleOrder(id: ID!): DeleteResponseDtoType!
  createSaleIssueNote(input: SaleIssueNoteInput!): SaleIssueNoteType!
  updateSaleIssueNote(input: SaleIssueNoteInput!, id: ID!): SaleIssueNoteType!
  deleteSaleIssueNote(id: ID!): DeleteResponseDtoType!
  createSaleInvoice(input: SaleInvoiceInput!): SaleInvoiceType!
  createSaleAvoir(input: SaleAvoirInput!): SaleInvoiceType!
  updateSaleInvoice(input: SaleInvoiceInput!, id: ID!): SaleInvoiceType!
  deleteSaleInvoice(id: ID!): DeleteResponseDtoType!
  createSaleDeliveryNote(input: SaleDeliveryNoteInput!): SaleDeliveryNoteType!
  updateSaleDeliveryNote(
    input: SaleDeliveryNoteInput!
    id: ID!
  ): SaleDeliveryNoteType!
  deleteSaleDeliveryNote(id: ID!): DeleteResponseDtoType!
  createPurchaseOrder(input: PurchaseOrderInput!): PurchaseOrderType!
  updatePurchaseOrder(input: PurchaseOrderInput!, id: ID!): PurchaseOrderType!
  deletePurchaseOrder(id: ID!): DeleteResponseDtoType!
  createPurchaseInvoice(input: PurchaseInvoiceInput!): PurchaseInvoiceType!
  updatePurchaseInvoice(
    input: PurchaseInvoiceInput!
    id: ID!
  ): PurchaseInvoiceType!
  deletePurchaseInvoice(id: ID!): DeleteResponseDtoType!
  createPurchaseDeliveryNote(
    input: PurchaseDeliveryNoteInput!
  ): PurchaseDeliveryNoteType!
  updatePurchaseDeliveryNote(
    input: PurchaseDeliveryNoteInput!
    id: ID!
  ): PurchaseDeliveryNoteType!
  deletePurchaseDeliveryNote(id: ID!): DeleteResponseDtoType!
  createLogistic(input: LogisticInput!): LogisticType!
  updateLogistic(input: LogisticInput!, id: ID!): LogisticType!
  deleteLogistic(id: ID!): DeleteResponseDtoType!
  updateRentalStatus(status: RentalStatusEnum!, id: ID!): RentalRefType!
  updateRentalDetails(input: RentalUpdateInput!, id: ID!): RentalRefType!
  createCompanyContact(input: CompanyContactInput!): CompanyContactType!
  updateCompanyContact(
    input: CompanyContactUpdateInput!
    id: ID!
  ): CompanyContactType!
  deleteCompanyContact(id: ID!): DeleteResponseDtoType!
  createCompanySettings(input: CompanySettingsInput!): CompanySettingsType!
  updateCompanySettings(
    input: CompanySettingsUpdateInput!
    id: ID!
  ): CompanySettingsType!
  deleteCompanySettings(id: ID!): DeleteResponseDtoType!
  createDocument(input: DocumentInput!): DocumentType!
  updateDocument(input: DocumentInput!, id: ID!): DocumentType!
  deleteDocument(id: ID!): DeleteResponseDtoType!
  createContentType(input: ContentTypeInput!): ContentTypeType!
  updateContentType(input: ContentTypeInput!, id: ID!): ContentTypeType!
  deleteContentType(id: ID!): DeleteResponseDtoType!
  createGlobalCategory(input: GlobalProviderCategoryInput!): GlobalCategoryType!
  updateGlobalCategory(
    input: GlobalProviderCategoryInput!
    id: ID!
  ): GlobalCategoryType!
  deleteGlobalCategory(id: ID!): DeleteResponseDtoType!
  createDraft(input: GmailDraftInput!, userId: String!): GmailDraftType!
  sendDraft(input: GmailDraftInput!, userId: String!): GmailDraftType!
  updateDraft(
    input: GmailDraftInput!
    id: String!
    userId: String!
  ): GmailDraftType!
  deleteDraft(id: String!, userId: String!): GoogleSuccessType!
  createGmailLabel(input: GmailLabelInput!, userId: String!): GmailLabelType!
  deleteGmailLabel(id: String!, userId: String!): GoogleSuccessType!
  patchLabel(
    input: GmailLabelInput!
    id: String!
    userId: String!
  ): GmailLabelType!
  updateGmailLabel(
    input: GmailLabelInput!
    id: String!
    userId: String!
  ): GmailLabelType!
  gmailMessageBatchDelete(ids: [String!]!, userId: String!): GoogleSuccessType!
  gmailMessageBatchModify(
    removeLabelIds: [String!]!
    addLabelIds: [String!]!
    ids: [String!]!
    userId: String!
  ): GoogleSuccessType!
  gmailMessageDelete(id: String!, userId: String!): GoogleSuccessType!
  gmailMessageInsert(
    messageInput: GmailMessageInput!
    input: GmailInsertMessageInput!
    userId: String!
  ): GmailMessageType!
  gmailMessageModify(
    input: GmailModifyMessageInput!
    id: String!
    userId: String!
  ): GmailMessageType!
  gmailMessageSend(
    input: GmailMessageInput!
    userId: String!
  ): GmailMessageType!
  gmailMessageTrash(id: String!, userId: String!): GmailMessageType!
  gmailMessageUntrash(id: String!, userId: String!): GmailMessageType!
  deleteGmailThreads(id: String!, userId: String!): GoogleSuccessType!
  modifyGmailThreads(
    input: GmailModifyMessageInput!
    id: String!
    userId: String!
  ): GmailThreadType!
  trashGmailThreads(id: String!, userId: String!): GmailThreadType!
  untrashGmailThreads(id: String!, userId: String!): GmailThreadType!
  deleteCalendarList(calendarId: String!, userId: String!): GoogleSuccessType!
  insertCalendarList(
    input: InsertCalendarListInput!
    colorRgbFormat: Boolean!
    userId: String!
  ): GoogleCalendarListResourceType!
  patchCalendarList(
    input: InsertCalendarListInput!
    colorRgbFormat: Boolean
    calendarId: String!
    userId: String!
  ): GoogleCalendarListResourceType!
  updateCalendarList(
    input: InsertCalendarListExtendInput!
    colorRgbFormat: Boolean
    calendarId: String!
    userId: String!
  ): GoogleCalendarListResourceType!
  clearGoogleCalendar(calendarId: String!, userId: String!): GoogleSuccessType!
  deleteGoogleCalendar(calendarId: String!, userId: String!): GoogleSuccessType!
  insertGoogleCalendar(
    input: InsertGoogleCalendarInput!
    userId: String!
  ): GoogleCalendarResourceType!
  patchGoogleCalendar(
    input: InsertGoogleCalendarInput!
    calendarId: String!
    userId: String!
  ): GoogleCalendarResourceType!
  updateGoogleCalendar(
    input: UpdateGoogleCalendarInput!
    calendarId: String!
    userId: String!
  ): GoogleCalendarResourceType!
  deleteGoogleCalendarEvent(
    sendUpdates: String!
    sendNotifications: Boolean!
    eventId: String!
    calendarId: String!
    userId: String!
  ): GoogleSuccessType!
  insertGoogleCalendarEvent(
    input: GoogleCalendarEventInput!
    supportsAttachments: Boolean
    sendUpdates: String
    sendNotifications: Boolean
    maxAttendees: Int
    conferenceDataVersion: Int
    calendarId: String!
    userId: String!
  ): GoogleCalendarEventType!
  moveGoogleCalendarEvent(
    sendUpdates: String
    sendNotifications: Boolean
    destination: String!
    eventId: String!
    calendarId: String!
    userId: String!
  ): GoogleCalendarEventType!
  patchGoogleCalendarEvent(
    input: GoogleCalendarPatchEventInput
    eventId: String!
    calendarId: String!
    userId: String!
  ): GoogleCalendarEventType!
  quickAddGoogleCalendarEvent(
    sendUpdates: String
    sendNotifications: Boolean
    text: String!
    calendarId: String!
    userId: String!
  ): GoogleCalendarEventType!
  updateGoogleCalendarEvent(
    input: GoogleCalendarPatchEventInput
    eventId: String!
    calendarId: String!
    userId: String!
  ): GoogleCalendarEventType!
  importPosByExcel(
    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
  ): SuccessResponseDtoType!
  importFullCorporateCatalogueByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  importSimpleFullCorporateCatalogueByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  importServicesCatalogueByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  importCustomersByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  importSuppliersByExcel(
    target: TargetACIInput!

    # base64 string from excel file.
    base64: String

    # path to excel file in server.
    path: String
    variety: ProductVarietyEnum
  ): SuccessResponseDtoType!
  createIntegrationSQL: u!
}

input EmailTemplateInput {
  name: EmailTemplateTypeEnum!
  content: String
  icon: String
  color: String
}

input CorporateEmailTemplateInput {
  name: EmailTemplateTypeEnum
  content: String
  icon: String
  color: String
  target: TargetACIInput
}

input UserInput {
  email: String
  username: String
  phone: IPhoneInput
  password: String!
  picture: PictureInput
  pictures: [PictureInput!]
  covers: [PictureInput!]
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [String!]
  education: [UserEducationInput!]
  work: [UserWorkInput!]
  lived: [ID!]
  hobbies: [String!]
  interests: [String!]
  isMailValid: Boolean
  plugged: Boolean
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  nationality: String
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressInput!]
  shippingAddress: [FullAddressInput!]
  billingAddress: [FullAddressInput!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  roles: [UserRole!]!
  apps: [App!]
  phoneNumber: String
}

input UserEducationInput {
  level: AcademicLevel
  name: String
  description: String
  tags: [String!]
  from: DateTime
  to: DateTime
  graduated: Boolean
}

input UserWorkInput {
  company: String
  position: String
  description: String
  city: ID
  tags: [String!]
  from: DateTime
  to: DateTime
  current: Boolean
}

input SocialValueInput {
  name: ID!
  value: String!
}

input FullAddressInput {
  owner: FullAddressOwnerInput
  address: String
  postCode: String
  city: String
  country: ID
  state: ID
  addressLine: String
  location: LonLatInput
}

input FullAddressOwnerInput {
  name: String
  phone: FullAddressOwnerPhoneInput
}

input FullAddressOwnerPhoneInput {
  number: String
  countryCode: String
}

input UserWithTargetInput {
  email: String
  username: String
  phone: IPhoneInput
  password: String!
  picture: PictureInput
  pictures: [PictureInput!]
  covers: [PictureInput!]
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [String!]
  education: [UserEducationInput!]
  work: [UserWorkInput!]
  lived: [ID!]
  hobbies: [String!]
  interests: [String!]
  isMailValid: Boolean
  plugged: Boolean
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  nationality: String
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressInput!]
  shippingAddress: [FullAddressInput!]
  billingAddress: [FullAddressInput!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  roles: [UserRole!]!
  apps: [App!]
  phoneNumber: String
  target: TargetACIInput!
  subject: String
}

input VapidKeyInput {
  vapidKey: String!
  userId: String!
}

input UserUpdateInput {
  password: String
  picture: PictureInput
  pictures: [PictureInput!]
  covers: [PictureInput!]
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [String!]
  education: [UserEducationInput!]
  work: [UserWorkInput!]
  lived: [ID!]
  hobbies: [String!]
  interests: [String!]
  isMailValid: Boolean
  plugged: Boolean
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  nationality: String
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressInput!]
  shippingAddress: [FullAddressInput!]
  billingAddress: [FullAddressInput!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  roles: [UserRole!]
  apps: [App!]
  phoneNumber: String
  email: String
  username: String
  phone: IPhoneInput
  vapidKey: String
}

input ResetPasswordForAppInput {
  password: String!
  token: String
  smsValidationCode: Int
  phone: IPhoneInput
}

enum DeleteUserReasonEnum {
  LACK_OF_CONTENT
  SOMETHING_IS_BROKEN
  SIZE_AND_COMPATIBILITY
}

input MessageInput {
  text: String
  gif: String
  sticker: String
  custom: CustomMessageInput
  media: MessageMediaInput
  location: LonLatInput
  messageGroup: ID!
  seenBy: [ID!]
}

input CustomMessageInput {
  id: String
  type: String
}

input MessageMediaInput {
  picture: [PictureInput!]
  video: [PictureInput!]
}

input DirectMessageInput {
  text: String
  gif: String
  sticker: String
  custom: CustomMessageInput
  media: MessageMediaInput
  location: LonLatInput
  seenBy: [ID!]
  receiver: ID!
  target: TargetACIInput
  type: MessageGroupTypeEnum
}

input SendMessageToTargetInput {
  text: String
  gif: String
  sticker: String
  custom: CustomMessageInput
  media: MessageMediaInput
  location: LonLatInput
  seenBy: [ID!]
  target: TargetACIInput!
}

input MessageGroupInput {
  name: String
  mute: Boolean
  creator: String
  profilePicture: PictureInput
  wallpaper: MessageGroupWallpaperInput
  sound: MessageSoundEnum
  status: MessageGroupStatusEnum
  target: TargetACIInput
  type: MessageGroupTypeEnum
  members: [String!]
}

input MessageGroupWallpaperInput {
  picture: PictureInput
  gradientColors: [String!]
  assetImage: String
}

input MessageGroupUpdateInput {
  name: String
  creator: String
  profilePicture: PictureInput
  wallpaper: MessageGroupWallpaperInput
  sound: MessageSoundEnum
  type: MessageGroupTypeEnum
  id: ID!
}

input NewVersionInput {
  platform: PlatformEnum
  requireUpdate: Boolean
  versionContent: [VersionContentInput!]
  version: String!
}

input VersionContentInput {
  contentType: VersionContentTypeEnum
  content: String
}

input UpdateVersionInput {
  platform: PlatformEnum
  requireUpdate: Boolean
  versionContent: [VersionContentInput!]
  id: ID!
  version: String
}

input StaticDataInput {
  key: String!
  value: String!
}

input PartnerReferralInput {
  posTitle: String
  picture: PictureInput
  address: FullAddressInput
  subject: String
  content: String
  app: App!
}

input BarcodeUpdateInput {
  product: ID
  internalProduct: ID
  productAttributesValues: [ID!]
  barcode: String
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditInput!]
  discount: DiscountDtoInput
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaInput
  catalogueCategory: [String!]
  maintenance: InternalProductMaintenanceInput
  pixel: PixelBarcodeInput
  priceList: [ProductPriceListInput!]
  taxes: [ProductTaxesInput!]
  supplier: ID
  id: ID!
}

input BarcodePeriodCreditInput {
  periodCycle: RecurrenceType!
  periodValue: Int!
  amount: String
}

input MediaInput {
  videos: [String!]
  pictures: [PictureInput!]
  deg360: [PictureInput!]
}

input InternalProductMaintenanceInput {
  active: Boolean
  owner: ID
  technician: ID
  prevMaintenanceDuration: Int
  maintenanceDuration: Int
  expectedMeantime: Int
}

input PixelBarcodeInput {
  include: Boolean
}

input ProductPriceListInput {
  price: ID!
  value: String
}

input UpdateMediaInput {
  id: ID!
  media: SingleMediaInput!
}

input SingleMediaInput {
  videos: String
  pictures: PictureInput
  deg360: PictureInput
}

input CompanyInput {
  name: String
  description: String
  tags: [String!]
  media: MediaInput
  address: FullAddressInput
  legal: CompanyLegalInput
  banks: [String!]
  contact: CompanyContactDetailsInput
  logistic: Boolean
  externalId: String
  customer: CompanyCustomerInput
  supplier: CompanySupplierInput
  target: TargetACIInput
}

input CompanyLegalInput {
  vat: String
  register: String
  licence: String
}

input CompanyContactDetailsInput {
  website: String
  email: String
  phone: PhoneInput
}

input PhoneInput {
  # Phone number
  number: String

  # Phone country code
  countryCode: String
  isValid: Boolean
}

input CompanyCustomerInput {
  phase: CustomerPhaseEnum
  score: String
}

input CompanySupplierInput {
  kind: SupplierTypeEnum
}

input CompanyUpdateInput {
  name: String
  description: String
  tags: [String!]
  media: MediaInput
  address: FullAddressInput
  legal: CompanyLegalInput
  banks: [String!]
  contact: CompanyContactDetailsInput
  logistic: Boolean
  externalId: String
  customer: CompanyCustomerInput
  supplier: CompanySupplierInput
}

input LoyaltyProgramInput {
  programName: String!
  picture: PictureInput
  company: String!
}

input ManufacturerCreateInput {
  name: String
  picture: PictureInput
  externalId: String
  address: FullAddressInput
  email: String
  company: String
  contactEmails: [String!]
  website: String
  currencies: [TargetCurrencyInput!]
}

input TargetCurrencyInput {
  currency: ID
  default: Boolean
}

input ManufacturerUpdateInput {
  name: String
  picture: PictureInput
  externalId: String
  address: FullAddressInput
  email: String
  company: String
  contactEmails: [String!]
  website: String
  currencies: [TargetCurrencyInput!]
  id: String!
}

input PointOfSaleInput {
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureInput
  outsidePictures: [PictureInput!]
  insidePictures: [PictureInput!]
  openingHours: OpeningHoursInput
  specialOffers: [SpecilOfferInput!]
  locations: [FullAddressInput!]
  email: [String!]
  contactEmails: [String!]
  currencies: [TargetCurrencyInput!]
  languages: [ID!]
  phone: [String!]
  website: String
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  averageCustomers: Float
  turnover: String
  posCategory: [ID!]
  company: String
  services: [ID!]
  paymentMethods: [ID!]
  loyaltyPrograms: [POSLoyaltyInput!]
}

input OpeningHoursInput {
  status: OpeningStatus!
  hours: [OpeningHoursDayInput!]!
}

input OpeningHoursDayInput {
  day: Days!
  from: String!
  to: String!
}

input SpecilOfferInput {
  offerType: SpecialOffersType
  hours: [OpeningHoursDayInput!]
}

input POSLoyaltyInput {
  loyaltyProgram: String
  from: DateTime!
  to: DateTime!
}

input AccountInput {
  expiresAt: DateTime!
  user: String!
  targets: TargetsInput!
}

enum UserPOSRoleEnum {
  POS_OWNER
  POS_WAITER
  POS_MANAGER
  DELIVERY_MAN
  POS_ASSISTANT
}

input AccountUpdateInput {
  expiresAt: DateTime
  user: String
  targets: TargetsInput
}

input POSCategoryInput {
  name: String!
  mapPicture: String!
  picture: PictureInput
}

input CatalogueCategoryInput {
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  parent: String
  description: String
  externalId: String
  pictures: [PictureInput!]
  seo: CatalogueCategorySeoInput
  variety: ProductVarietyEnum
  name: String!
  target: TargetACIInput!
  layer: Int!
}

input CatalogueCategorySeoInput {
  urlKey: String
  metaTitle: String
  metaDesription: String
  metaKeywords: [MetaKeywordsInput!]
}

input MetaKeywordsInput {
  name: String
  content: String
}

input CatalogueCategoryBulkInput {
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  parent: ID
  description: String
  externalId: String!
  pictures: [PictureInput!]
  seo: CatalogueCategorySeoInput
  variety: ProductVarietyEnum
  name: String!
  hasChildren: Boolean!
  target: TargetACIInput!
  rank: Int!
  layer: Int!
}

input CatalogueCategoryUpdateInput {
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  parent: String
  description: String
  externalId: String
  pictures: [PictureInput!]
  seo: CatalogueCategorySeoInput
  variety: ProductVarietyEnum
  id: ID!
  name: String
  layer: Int
}

input POSServicesInput {
  index: Int!
  name: String!
}

input WholesalerCreateInput {
  name: String
  description: String
  address: FullAddressInput
  picture: PictureInput
  email: String
  company: String
  website: String
  contactEmails: [String!]
  phone: IPhoneInput
  fax: IPhoneInput
  currencies: [TargetCurrencyInput!]
}

input WholesalerUpdateInput {
  name: String
  description: String
  address: FullAddressInput
  picture: PictureInput
  email: String
  company: String
  website: String
  contactEmails: [String!]
  phone: IPhoneInput
  fax: IPhoneInput
  currencies: [TargetCurrencyInput!]
  id: String!
}

input BrandInput {
  name: String!
  picture: PictureInput
  externalId: String
  website: String
  manufacturer: String
  target: TargetACIInput
}

input InventoryCategoryInput {
  name: String!
  picture: PictureInput
  layer: Int!
  rank: Int!
  hasChildren: Boolean!
  parent: String
}

input ProductInput {
  externalId: String
  name: String!
  sku: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  tags: [String!]
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  ean: String
  weight: Float
  price: String!
  class: [ProductClassEnum!]
  wholesalerPrice: String
  factoryPrice: String
  tax: String!
  taxes: [ProductTaxesInput!]
  productAttributes: [String!]

  # list of barcodes ids
  barcodes: [ID!]
  brand: String
  category: [String!]!
}

input ProductSpecsInput {
  key: String
  value: String
}

input ProductUpdateInput {
  externalId: String
  name: String
  sku: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  tags: [String!]
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  ean: String
  weight: Float
  price: String
  class: [ProductClassEnum!]
  wholesalerPrice: String
  factoryPrice: String
  tax: String
  taxes: [ProductTaxesInput!]
  productAttributes: [String!]

  # list of barcodes ids
  barcodes: [ID!]
  brand: String
  category: [String!]
}

input AttributeCreateInput {
  label: String!
  externalId: String!
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelInput
  variety: ProductVarietyEnum
  target: TargetACIInput
}

input AttributePixelInput {
  pixelAttribute: String
}

input AttributeUpdateInput {
  label: String
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelInput
  variety: ProductVarietyEnum
  id: ID!
}

input AttributeValueInput {
  label: String!
  externalId: String!
  target: TargetACIInput!
  attribute: ID!
}

input AttributeValueUpdateInput {
  label: String
  attribute: ID
  id: ID!
}

input ProductAttributeInput {
  isRequired: Boolean
  isMultipleChoice: Boolean
  attribute: String!
  reference: String!
  possibleValues: [String!]!
  target: TargetACIInput
}

input ProductAttributeUpdateInput {
  isRequired: Boolean
  isMultipleChoice: Boolean
  id: ID!
  attribute: String
  reference: String
  possibleValues: [String!]
}

input BarcodeInput {
  product: ID
  internalProduct: ID
  productAttributesValues: [ID!]
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditInput!]
  discount: DiscountDtoInput
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaInput
  catalogueCategory: [String!]
  maintenance: InternalProductMaintenanceInput
  pixel: PixelBarcodeInput
  priceList: [ProductPriceListInput!]
  taxes: [ProductTaxesInput!]
  supplier: ID
}

input CreateSimpleProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  target: TargetACIInput!
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
}

input GlobalCategoryInput {
  googleCategory: ID
  facebookCategory: ID
}

input UpdateSimpleProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
  id: ID!
}

input CreateInternalProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  internalProductAttributes: InternalProductAttributeInput

  # list of barcodes ids
  barcodes: [ID!]

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  product: String!
  target: TargetACIInput!
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
}

input InternalProductAttributeInput {
  attributes: [InternalProductAttributeInnerInput!]
}

input InternalProductAttributeInnerInput {
  price: String
  selectedValue: String!
  productAttribute: String!
}

input CreateCustomInternalProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  internalProductAttributes: InternalProductAttributeInput

  # list of barcodes ids
  barcodes: [ID!]

  # list of suppliers ids
  suppliers: [ID!]
  price: String!
  product: String
  target: TargetACIInput!
  productInput: ProductInput
  catalogueCategory: [String!]!
  globalCategory: GlobalCategoryInput
}

input UpdateInternalProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  internalProductAttributes: InternalProductAttributeInput

  # list of barcodes ids
  barcodes: [ID!]

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  product: String
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
  id: ID!
}

input FollowerInput {
  target: TargetACIInput
  user: String
}

input LocationInput {
  name: String
  externalId: String
  media: MediaInput
  tags: [String!]
  company: ID
  address: FullAddressInput
  locationType: LocationTypeEnum
}

input TaxInput {
  label: String
  externalId: String
  value: TaxValueInput
  use: [TaxUseEnum!]
  product: Boolean
  company: ID
}

input TaxValueInput {
  sign: TaxSignEnum!
  value: String
  type: DiscountType!
}

input PriceInput {
  label: String
  enable: Boolean
  company: ID
}

input RequestInput {
  requestor: RequestRequestorInput
  company: RequestCompanyInput
  request: RequestRequestInput
  type: RequestTypeEnum
  target: TargetACIInput
}

input RequestRequestorInput {
  firstName: String!
  lastName: String!
  email: String!
  phone: IPhoneInput
  address: FullAddressInput
}

input RequestCompanyInput {
  name: String!
  address: FullAddressInput
  vatId: String!
  registerNo: String!
  licenceNo: String!
  website: String!
  email: String!
  phone: IPhoneInput
}

input RequestRequestInput {
  subject: String!
  content: String!
}

input ModulesDefinitionInput {
  name: String!
  target: TargetTypeEnum
}

input ModulesAssignmentInput {
  module: String!
  assignee: AssigneeInput
}

input FavoriteProductInput {
  user: String
  product: String
}

input BookingTypeInput {
  index: Int!
  name: String!
}

input BookingSettingsInput {
  pos: String!
  bookingType: String
  bookTime: TimeFromToInput
  bookingMaxCapacity: Int
  mobileBooking: Boolean
  portalBooking: Boolean
  facebookBooking: Boolean
  nonBookableDays: [MonthDaysInput!]
  settingsAttributes: [SettingsAttributeInput!]
}

input TimeFromToInput {
  from: String
  to: String
}

input MonthDaysInput {
  month: Int!
  days: [Int!]
}

input SettingsAttributeInput {
  attribute: String!
  value: String!
}

input BookingSettingsUpdateInput {
  pos: String
  bookingType: String
  bookTime: TimeFromToInput
  bookingMaxCapacity: Int
  mobileBooking: Boolean
  portalBooking: Boolean
  facebookBooking: Boolean
  nonBookableDays: [MonthDaysInput!]
  settingsAttributes: [SettingsAttributeInput!]
}

input BookingInput {
  user: String!
  pos: String!
  instructions: String
  phone: String
  bookingTime: DateTime!
  attributes: [SettingsAttributeInput!]
  people: Int!
  source: BookingSourceEnum!
}

input ComplaintInput {
  reporter: String
  report: String!
  target: ComplaintTargetInput!
}

input ComplaintUpdateInput {
  id: ID!
  reporter: String
  report: String
  target: ComplaintTargetInput
}

input BookingAttributeInput {
  label: String!
  isRequired: Boolean
}

input StockPixelInput {
  quantityToSellOnFacebook: Int
}

input WarehouseInput {
  name: String
  media: MediaInput
  tags: [String!]
  location: ID!
  totalSurface: Float
  nonStorageSurface: Float
  externalId: String
}

input WarehouseUpdateInput {
  name: String
  media: MediaInput
  tags: [String!]
  location: ID
  totalSurface: Float
  nonStorageSurface: Float
  externalId: String
}

input StoriesInput {
  picture: PictureInput
  video: PictureInput
  content: [StoryContentContentInput!]
  user: ID
  pos: ID
  wholesaler: ID
  manufacturer: ID

  # Group id
  group: ID
}

input StoryContentContentInput {
  content: String
  position: StoryContentPositionInput
  dimension: StoryContentDimensionInput
  color: String
  contentType: StoriesContentTypeEnum
}

input StoryContentPositionInput {
  left: Float
  right: Float
  top: Float
  bottom: Float
}

input StoryContentDimensionInput {
  height: Float
  width: Float
  fontSize: Float
}

input ProductRatingInput {
  mark: Int!
  comment: String
  user: ID!
  product: ID!
  reviewType: ID!
}

input UpdateProductRatingInput {
  mark: Int
  comment: String
  user: ID
  product: ID
  reviewType: ID
}

input ProductRatingDefinitionInput {
  reviewType: String!
  active: Boolean!
}

input UpdateProductRatingDefinitionInput {
  reviewType: String
  active: Boolean
}

input CorporateRatingInput {
  # an integer minimum 1 and maximum 5.
  mark: Float!
  comment: String
  product: ID!

  # Corporate Rating review type.
  reviewType: String!
  target: TargetACIInput!
}

input CorporateUpdateRatingInput {
  # an integer minimum 1 and maximum 5.
  mark: Float
  comment: String

  # Corporate Rating review type.
  reviewType: String
}

input CorporateRatingAssignmentInput {
  active: Boolean
  target: TargetACIInput!
  reviewDefinition: ID!
}

input FeaturedCorporateInput {
  rank: Int!
  pos: String
  wholesaler: String
  manufacturer: String
}

input SEOInput {
  target: TargetACIInput!
  googleAnalyticsId: String
  titleTag: String
  metaDescriptionTag: String
  headerTags: [TagInput!]
}

input TagInput {
  name: String
  content: String
}

input UpdateSEOInput {
  googleAnalyticsId: String
  titleTag: String
  metaDescriptionTag: String
  headerTags: [TagInput!]
}

input VisualsInput {
  target: TargetACIInput!
  pageTitle: String
  logo: PictureInput
  wide: PictureInput
  square: PictureInput
  favicon: VisualsFaviconInput
}

input VisualsFaviconInput {
  size16: PictureInput
  size32: PictureInput
  size57: PictureInput
  size60: PictureInput
  size72: PictureInput
  size76: PictureInput
  size96: PictureInput
  size114: PictureInput
  size120: PictureInput
  size144: PictureInput
  size152: PictureInput
  size180: PictureInput
  size192: PictureInput
}

input UpdateVisualsInput {
  pageTitle: String
  logo: PictureInput
  wide: PictureInput
  square: PictureInput
  favicon: VisualsFaviconInput
}

input LandingPagesInput {
  target: TargetACIInput!
  pageType: LandingPageTypeEnum!
  pageReference: String!
  pageTitle: String!
  pageDescription: String
  url: String
  tags: [String!]
  seo: SeoComponentInput
  sectionData: [LandingPagesDataInput!]
}

input SeoComponentInput {
  metaTitle: String
  metaDesription: String
  metaKeywords: [TagInput!]
}

input LandingPagesDataInput {
  sectionReference: String
  sectionTitle: String
  sectionContent: String
  sectionPictures: [PictureInput!]
}

input UpdateLandingPagesInput {
  pageType: LandingPageTypeEnum
  pageReference: String
  pageTitle: String
  pageDescription: String
  url: String
  tags: [String!]
  seo: SeoComponentInput
  sectionData: [LandingPagesDataInput!]
}

input SlidesInput {
  target: TargetACIInput!
  reference: String
  visualType: SlideVisualTypeEnum
  content: [SlidesContentInput!]
}

input SlidesContentInput {
  image: PictureInput
  icon: String
  title: String
  description: String
  calltoaction: String
}

input UpdateSlidesInput {
  reference: String
  visualType: SlideVisualTypeEnum
  content: [SlidesContentInput!]
}

input BlogInput {
  title: String!
  target: TargetACIInput!
  url: String
  tags: [String!]
  seo: SeoComponentInput
  pictures: [PictureInput!]
  sectionData: [BlogDataInput!]
}

input BlogDataInput {
  sectionReference: String
  sectionTitle: String
  sectionContent: String
  sectionPictures: [PictureInput!]
}

input UpdateBlogInput {
  title: String
  url: String
  tags: [String!]
  seo: SeoComponentInput
  pictures: [PictureInput!]
  sectionData: [BlogDataInput!]
}

input CouponInput {
  target: TargetACIInput!
  discount: DiscountDtoInput!
  from: DateTime
  to: DateTime
}

input CouponsInput {
  target: TargetACIInput!
  discount: DiscountDtoInput!
  from: DateTime
  to: DateTime
  quantity: Int!
}

input UpdateCouponInput {
  discount: DiscountDtoInput
  from: DateTime
  to: DateTime
}

input OrderSettingsInput {
  target: TargetACIInput!
  pickupTime: TimeFromToInput
  pickup: Boolean
  delivery: Boolean
  showMenuInPortal: Boolean
  mobilePickup: Boolean
  portalPickup: Boolean
  facebookPickup: Boolean
  deliveryTime: TimeFromToInput
  mobileDelivery: Boolean
  portalDelivery: Boolean
  facebookDelivery: Boolean
  nonDeliveryDays: [MonthDaysInput!]
  nonPickupDays: [MonthDaysInput!]
}

input OrderSettingsUpdateInput {
  pickupTime: TimeFromToInput
  pickup: Boolean
  delivery: Boolean
  showMenuInPortal: Boolean
  mobilePickup: Boolean
  portalPickup: Boolean
  facebookPickup: Boolean
  deliveryTime: TimeFromToInput
  mobileDelivery: Boolean
  portalDelivery: Boolean
  facebookDelivery: Boolean
  nonDeliveryDays: [MonthDaysInput!]
  nonPickupDays: [MonthDaysInput!]
}

input DeliveryZonesInput {
  target: TargetACIInput!
  radius: Float
  minPrice: String!
  extraFees: String!
  color: String!
  type: ZoneTypesEnum!
  paths: [DeliveryZonePathInput!]!
}

input OrderDeliveryZonesUpdateInput {
  radius: Float
  minPrice: String
  extraFees: String
  color: String
  type: ZoneTypesEnum
  paths: [DeliveryZonePathInput!]
}

input PurchaseInput {
  externalId: String!
  notes: String
  status: PurchaseStatusEnum
  installments: [InstallmentInput!]!
  supplier: ID!
  attachments: [ID!]
  target: TargetACIInput!
}

input InstallmentInput {
  amount: String!
  paymentMethod: String!
  paymentStatus: PaymentStatusEnum!
  paidAt: DateTime
  deadline: DateTime
}

input UpdatePurchaseInput {
  externalId: String
  notes: String
  status: PurchaseStatusEnum
  installments: [InstallmentInput!]
  supplier: ID
  attachments: [ID!]
  target: TargetACIInput
}

input SupplierInput {
  reference: String!
  externalId: String!
  supplier: TargetACIInput!
  target: TargetACIInput!
}

input UpdateSupplierInput {
  reference: String
  externalId: String
  supplier: TargetACIInput
}

input BankInput {
  name: String!
  code: String
  bic: String
  address: FullAddressInput
  logo: BrowserLogoInput
}

input BrowserLogoInput {
  svg: PictureInput
  png: BrowserLogoPngInput
  icon: String
}

input BrowserLogoPngInput {
  default: PictureInput
  size16: PictureInput
  size24: PictureInput
  size32: PictureInput
  size48: PictureInput
  size64: PictureInput
  size128: PictureInput
  size256: PictureInput
  size512: PictureInput
}

input BankDetailsInput {
  account: String!
  iban: String
  bank: ID!
  externalId: String
  holder: BankDetailsHolderInput!
}

input BankDetailsHolderInput {
  name: String
  type: BankDetailsHolderTypeEnum
  address: FullAddressInput
}

input FavoriteInternalProductInput {
  user: String
  product: String
}

input DepartmentInput {
  name: String!
  target: TargetACIInput
}

input JobDefinitionInput {
  title: String!
  status: JobDefinitionStatusEnum
  department: ID!
  specs: [JobSpecsInput!]
  description: JobDescriptionInput
  responsibility: JobDescriptionInput
  offer: JobDescriptionInput
  target: TargetACIInput!
}

input JobSpecsInput {
  key: JobDefinitionSpecEnum!
  value: String!
}

input JobDescriptionInput {
  description: String!
  descriptionList: [String!]!
}

input JobDefinitionUpdateInput {
  title: String
  status: JobDefinitionStatusEnum
  department: ID
  specs: [JobSpecsInput!]
  description: JobDescriptionInput
  responsibility: JobDescriptionInput
  offer: JobDescriptionInput
}

input JobApplicationInput {
  firstName: String!
  lastName: String!
  email: String!
  message: String!
  cv: ID!
  cover: ID!
  status: JobApplicationStatusEnum!
  jobDefinition: String!
}

input JobApplicationUpdateInput {
  firstName: String
  lastName: String
  email: String
  message: String
  cv: ID
  cover: ID
  status: JobApplicationStatusEnum
  jobDefinition: String
}

input PromotionInput {
  startDate: DateTime!
  endDate: DateTime!
  status: PromotionStatusEnum
  promotion: [PromotionProductsInput!]!
  target: TargetACIInput!
}

input PromotionProductsInput {
  barcode: ID!
  discount: DiscountDtoInput!
}

input PromotionUpdateInput {
  startDate: DateTime
  endDate: DateTime
  status: PromotionStatusEnum
  promotion: [PromotionProductsInput!]
}

input CompareProductInput {
  limit: Int!
  product: ID!
}

input PerformTransactionInput {
  source: TargetTransferInput!
  receiver: TargetTransferInput!
  amount: String!
}

input TargetTransferInput {
  # user id
  user: String

  # pos id
  pos: String

  # wholesaler id
  wholesaler: String

  # manufacturer id
  manufacturer: String
}

input SubscribersInput {
  target: TargetACIInput!
  user: String
}

input QuestInput {
  title: String
  description: String
  media: MediaInput
  category: QuestCategoryEnum
  status: QuestStatusEnum
  recurrence: QuestActionsRecurrenceInput
  remuneration: [RemunerationInput!]
  activityType: ID
  sponsored: Boolean
  leaderboard: Boolean
  rewards: String
  maxAnswers: Int
  audience: ID
  target: TargetACIInput!
}

input QuestActionsRecurrenceInput {
  enable: Boolean
  cycle: Int
}

input RemunerationInput {
  pocketType: PocketTypeEnum!
  amount: String!
}

input QuestActivityInput {
  title: String
  description: String
  tags: [String!]
  media: MediaInput
  quest: ID
  rank: Int
  activity: IQuestActivityActivitiesInput
}

input IQuestActivityActivitiesInput {
  action: ID
  transition: IQuestActivityActivitiesTransitionInput
  condition: IQuestActivityActivitiesConditionInput
}

input IQuestActivityActivitiesTransitionInput {
  title: String
  description: String
}

input IQuestActivityActivitiesConditionInput {
  conditionType: QuestActivityConditionType
  condition: IQuestActivityActivitiesConditionConditionInput
  transition: IQuestActivityActivitiesConditionTransitionInput
}

input IQuestActivityActivitiesConditionConditionInput {
  action: IQuestActivityActivitiesConditionConditionActionInput
  score: IQuestActivityActivitiesConditionConditionScoreInput
}

input IQuestActivityActivitiesConditionConditionActionInput {
  definition: ID
  action: QuestActionActionInput
}

input QuestActionActionInput {
  textBox: QuestActionActionContentInput
  rating: QuestActionActionContentInput
  calculated: QuestActionActionContentInput
  date: QuestActionActionDateInput
  contact: QuestActionActionContactInput
  number: QuestActionActionNumberInput
  api: QuestActionActionApiInput
  matrix: QuestActionActionContentInput
  toggle: QuestActionActionContentInput
  choices: QuestActionActionChoicesInput
  smiley: QuestActionActionContentInput
  score: QuestActionActionContentInput
  lead: QuestActionActionContentInput
  verification: QuestActionActionVerificationInput
  video: QuestActionActionPerformedInput
  socialMedia: QuestActionActionPerformedInput
  appDownload: QuestActionActionPerformedInput
}

input QuestActionActionContentInput {
  content: String
}

input QuestActionActionDateInput {
  startDate: DateTime
  endDate: DateTime
}

input QuestActionActionContactInput {
  firstname: String
  lastname: String
  email: String
  phone: String
  description: String
  address: FullAddressInput
  birthday: DateTime
  gender: Gender
  civility: MaritalStatus
  profession: String
  academicLevel: AcademicLevel
  language: [ID!]
}

input QuestActionActionNumberInput {
  from: Float
  to: Float
}

input QuestActionActionApiInput {
  code: Float
  content: Float
}

input QuestActionActionChoicesInput {
  responses: [String!]
}

input QuestActionActionVerificationInput {
  number: QuestActionActionVerificationContentInput
  email: QuestActionActionVerificationContentInput
}

input QuestActionActionVerificationContentInput {
  verification: QuestActionActionPerformedInput
  verified: QuestActionActionPerformedInput
}

input QuestActionActionPerformedInput {
  performed: Boolean
}

input IQuestActivityActivitiesConditionConditionScoreInput {
  operator: OperatorEnum
  value: OperatorEnum
}

input IQuestActivityActivitiesConditionTransitionInput {
  transition: QuestActivityTransitionType
  goto: IQuestActivityActivitiesConditionTransitionGotoInput
  endMessage: String
}

input IQuestActivityActivitiesConditionTransitionGotoInput {
  action: ID
}

input QuestActionDefinitionInput {
  activityType: String
  required: Boolean
  definition: QuestActionDefinitionDefinitionInput
}

input QuestActionDefinitionDefinitionInput {
  textBox: QuestActionDefinitionDefinitionTextBoxInput
  rating: QuestActionDefinitionDefinitionRatingInput
  calculated: QuestActionDefinitionDefinitionCalculatedInput
  date: QuestActionDefinitionDefinitionDateInput
  contact: QuestActionDefinitionDefinitionContactInput
  number: QuestActionDefinitionDefinitionNumberInput
  api: QuestActionDefinitionDefinitionApiInput
  matrix: QuestActionDefinitionDefinitionMatrixInput
  toggle: QuestActionDefinitionDefinitionToggleInput
  choices: QuestActionDefinitionDefinitionChoicesInput
  smiley: QuestActionDefinitionDefinitionSmileyInput
  score: QuestActionDefinitionDefinitionScoreInput
  lead: QuestActionDefinitionDefinitionLeadInput
  verification: QuestActionDefinitionDefinitionVerificationInput
  video: QuestActionDefinitionDefinitionVideoInput
  socialMedia: QuestActionDefinitionDefinitionSocialMediaInput
  appDownload: QuestActionDefinitionDefinitionAppDownloadInput
}

input QuestActionDefinitionDefinitionTextBoxInput {
  min: Int
  max: Int
}

input QuestActionDefinitionDefinitionRatingInput {
  max: Int
  text: Boolean
}

input QuestActionDefinitionDefinitionCalculatedInput {
  output: CalculatedOutputEnum
  show: Boolean
  formula: String
  values: [QuestActionDefinitionDefinitionCalculatedValuesInput!]
}

input QuestActionDefinitionDefinitionCalculatedValuesInput {
  minValue: Int
  maxValue: Int
  score: Boolean
}

input QuestActionDefinitionDefinitionDateInput {
  outdated: Boolean
  interval: Boolean
}

input QuestActionDefinitionDefinitionContactInput {
  firstname: Boolean
  lastname: Boolean
  email: Boolean
  phone: Boolean
  description: Boolean
  address: Boolean
  birthday: Boolean
  gender: Boolean
  civility: Boolean
  profession: Boolean
  academicLevel: Boolean
  language: Boolean
}

input QuestActionDefinitionDefinitionNumberInput {
  minValue: Int
  maxValue: Int
  interval: Boolean
}

input QuestActionDefinitionDefinitionApiInput {
  link: Int
  method: ApiMethods
  auth: String
  secret: String
  params: [QuestActionDefinitionDefinitionApiParamsInput!]
}

input QuestActionDefinitionDefinitionApiParamsInput {
  name: String
  type: String
}

input QuestActionDefinitionDefinitionMatrixInput {
  lines: String
  columns: String
}

input QuestActionDefinitionDefinitionToggleInput {
  leftLabel: String
  rightLabel: String
}

input QuestActionDefinitionDefinitionChoicesInput {
  maxResponses: Float
  personalised: Boolean
  unique: Boolean
  random: Boolean
  leaderboard: Boolean
  api: Boolean
  image: Boolean
  interaction: Boolean
  suggestions: ID
}

input QuestActionDefinitionDefinitionSmileyInput {
  levels: Int
}

input QuestActionDefinitionDefinitionScoreInput {
  min: Int
}

input QuestActionDefinitionDefinitionLeadInput {
  url: String
  image: String
}

input QuestActionDefinitionDefinitionVerificationInput {
  number: QuestActionDefinitionDefinitionVerificationItemInput
  email: QuestActionDefinitionDefinitionVerificationItemInput
}

input QuestActionDefinitionDefinitionVerificationItemInput {
  verification: QuestActionDefinitionDefinitionVerificationItemContentInput
  verified: QuestActionDefinitionDefinitionVerificationItemContentInput
}

input QuestActionDefinitionDefinitionVerificationItemContentInput {
  rank: Int
}

input QuestActionDefinitionDefinitionVideoInput {
  minSeconds: Int
}

input QuestActionDefinitionDefinitionSocialMediaInput {
  socialMedia: String
  action: SocialActionEnum
  socialContent: SocialContentTypeEnum
  url: String
}

input QuestActionDefinitionDefinitionAppDownloadInput {
  playstore: String
  appstore: String
  appgallery: String
}

input QuestTypeInput {
  title: String
  description: String
  icon: String
  media: MediaInput
  activityTypes: [ID!]
  maxActivities: Int
  rewardPoints: String
  minCoins: String
  fees: String
  score: Boolean
  profile: Boolean
  admin: Boolean
  transition: Boolean
  condition: Boolean
  enable: Boolean
  target: TargetACIInput
}

input ActivityTypeInput {
  title: String
  description: String
  icon: String
  theme: String
  media: MediaInput
  predefined: PredefinedActionInput
  target: TargetACIInput
}

input PredefinedActionInput {
  enable: Boolean
  action: PredefinedActionsEnum
}

input ActivityTypeUpdateInput {
  title: String
  description: String
  icon: String
  theme: String
  media: MediaInput
  predefined: PredefinedActionInput
  target: TargetACIInput
}

input UpdateReputationInput {
  id: ID!
  inactivityCycle: Int
  lossAmount: Int
  perks: PerksInput
  color: String
  reputationLevel: String
  picture: UpdatePictureInput
}

input PerksInput {
  discount: String
  description: String!
}

input UpdatePictureInput {
  width: Int
  height: Int
  x: Int
  y: Int
  alt: String
  baseUrl: String
  path: String
}

input OnsiteConverterInput {
  remunerations: [RemunerationWithReputationInput!]!
}

input RemunerationWithReputationInput {
  qualitativeAmount: String!
  quantitativeAmount: String!
  reputationLevel: ID
}

input PushConverterInput {
  user: String!
  amount: String!
}

input AudienceInput {
  title: String
  description: String
  icon: String
  media: MediaInput
  segments: [AudienceSegmentInput!]
  target: TargetACIInput
}

input AudienceCriteriaInput {
  title: String
  description: String
  icon: String
  style: String
  enable: Boolean
  media: MediaInput
  fields: [AudienceCriteriaFieldInput!]
}

input AudienceCriteriaFieldInput {
  field: AudienceCriteriaFieldEnum
  operators: [OperatorEnum!]
}

input GoogleSearchAuditConfigInput {
  queries: [String!]
  countryCode: GoogleAuditCountryCodeEnum
  languageCode: GoogleAuditLanguageCodeEnum
  target: TargetACIInput!
}

input GoogleMapsAuditConfigInput {
  searchStringsArray: [String!]
  countryCode: GoogleAuditCountryCodeEnum
  city: String
  language: GoogleAuditLanguageCodeEnum
  target: TargetACIInput!
}

input CartProductUpdateCreditInput {
  # barcode local db id
  barcode: ID!
  quantity: Int = 1
  rent: RentalRefInput
  priceCredit: PriceCreditInput!
}

input MarketPlaceOrderInput {
  user: String
  notes: String
  orderType: OrderTypeEnum!
  paymentMethod: String!
  deliveryAddress: FullAddressInput
  orderTime: DateTime!
  fees: MarketPlaceOrderDtoFeesInput
}

input MarketPlaceOrderDtoFeesInput {
  feesType: MarketPlaceOrderWithCartFeesEnum
  amount: String
}

enum MarketPlaceOrderWithCartFeesEnum {
  DEFAULT
  CUSTOM
}

input MarketPlaceOrderWithCartInput {
  user: String
  notes: String
  orderType: OrderTypeEnum!
  installments: [InstallmentInput!]
  fees: MarketPlaceOrderDtoFeesInput
  deliveryAddress: FullAddressInput
  orderTime: DateTime!
  discount: DiscountDtoInput
  products: [CartProductInput!]!
  target: TargetACIInput
}

input MarketPlaceOrderWithCartAfterRegisterInput {
  user: String
  notes: String
  orderType: OrderTypeEnum!
  installments: [InstallmentInput!]
  fees: MarketPlaceOrderDtoFeesInput
  deliveryAddress: FullAddressInput
  orderTime: DateTime!
  discount: DiscountDtoInput
  products: [CartProductInput!]!
  target: TargetACIInput
  apps: [App!]
  userSubject: String
  orderSubject: String
  email: String!
  password: String!
  lastName: String!
  firstName: String!
  roles: [UserRole!]!
  phone: IPhoneInput!
  shippingAddress: [FullAddressInput!]!
}

input MarketPlaceOrderProductInput {
  orderId: String!
  barcodeId: String!
}

input InstallmentPaymentInput {
  orderId: ID!
  installmentId: ID!
}

input MarketPlaceOrderStatusByPOSInput {
  orderId: String!
  barcodeId: String!
  status: UpdateOrderProductStatusForPOSEnum!
}

enum UpdateOrderProductStatusForPOSEnum {
  OPEN
  CONFIRMED
  DELIVERED
  READY_FOR_PICKUP
}

input ShortcutInput {
  label: String!
  description: String
  icon: String!
  picture: PictureInput
  link: String!
  router: Boolean!
  user: String!
}

input ShortcutUpdateInput {
  label: String
  description: String
  icon: String
  picture: PictureInput
  link: String
  router: Boolean
}

input TaskInput {
  title: String!
  done: Boolean
}

input BoardCardTasksInput {
  task: String
  done: Boolean
}

input BoardCardProcedureInput {
  title: String
  task: BoardCardProcedureEnum
  time: DateTime
}

input MaintenanceBoardCardInput {
  title: String!
  description: String
  dueDate: DateTime
  archived: Boolean
  priority: BoardCardPriorityEnum
  tags: [String!]
  pictures: [PictureInput!]
  project: ID
  barcode: ID
  tasks: [BoardCardTasksInput!]
  labels: [ID!]
  rank: Int
  assignedTo: [ID!]
  budget: String
  customer: ID
  procedure: [BoardCardProcedureInput!]
  attachments: [ID!]
  target: TargetACIInput!
}

input ProjectInput {
  name: String
  description: String
  media: MediaInput
  privacy: ProjectPrivacyEnum
  tags: [String!]
  deadline: DateTime
  priority: ProjectPriorityEnum
  status: ProjectStatusEnum
  color: String
  externalId: String
  picture: PictureInput
  members: [ProjectMemberInput!]
  resources: [ID!]
  attachments: [ID!]
  target: TargetACIInput
}

input ProjectMemberInput {
  member: ID
  role: ProjectRoleEnum
}

input ProjectUpdateInput {
  name: String
  description: String
  media: MediaInput
  privacy: ProjectPrivacyEnum
  tags: [String!]
  deadline: DateTime
  priority: ProjectPriorityEnum
  status: ProjectStatusEnum
  color: String
  externalId: String
  picture: PictureInput
  members: [ProjectMemberInput!]
  resources: [ID!]
  attachments: [ID!]
  target: TargetACIInput
  id: ID!
}

input TicketInput {
  name: String
  description: String
  media: MediaInput
  tags: [String!]
  deadline: DateTime
  priority: TicketPriorityEnum
  status: TicketStatusEnum
  attachments: [ID!]
  color: String
  assignedTo: [ID!]
  customer: ID
  project: ID
  target: TargetACIInput!
  company: ID!
}

input TicketUpdateInput {
  name: String
  description: String
  media: MediaInput
  tags: [String!]
  deadline: DateTime
  priority: TicketPriorityEnum
  status: TicketStatusEnum
  attachments: [ID!]
  color: String
  assignedTo: [ID!]
  customer: ID
  project: ID
  target: TargetACIInput
  id: ID!
}

input CommentInput {
  user: ID
  comment: String
  replyTo: ID
  attachments: [ID!]
  holder: CommentHolderInput
}

input TimeTrackInput {
  user: ID
  title: String
  start: DateTime
  end: DateTime
  idle: String
  holder: TimeTrackOnInput
}

input LoyaltySettingsUpdateInput {
  qualitative: LoyaltySettingsWalletInput
  quantitative: LoyaltySettingsWalletInput
  onsiteConverter: LoyaltySettingsOnsiteConverterinput
  loyaltyCard: LoyaltySettingsWalletCardInput
  leaderboard: LoyaltySettingsWalletLeaderboardInput
  subscribers: LoyaltySettingsWalletSubscribersInput
  id: ID!
}

input LoyaltySettingsWalletInput {
  active: Boolean
  picture: PictureInput
}

input LoyaltySettingsOnsiteConverterinput {
  active: Boolean
  onsiteConverter: ID
  cashregisterIntegration: LoyaltySettingsOnsiteConverterIntgInput
}

input LoyaltySettingsOnsiteConverterIntgInput {
  active: Boolean
  credentials: APICredentialsInput
}

input APICredentialsInput {
  publicKey: String
  secretKey: String
}

input LoyaltySettingsWalletCardInput {
  digital: Boolean
  physical: Boolean
  validity: Int
}

input LoyaltySettingsWalletLeaderboardInput {
  active: Boolean
  overall: Boolean
  monthly: Boolean
  weekly: Boolean
}

input LoyaltySettingsWalletSubscribersInput {
  verification: Boolean
}

input GoogleAnalyticsUpdateInput {
  target: TargetACIInput
  googleTagId: String
  active: Boolean
  id: ID!
}

input FBPixelUpdateInput {
  target: TargetACIInput
  pixelId: String
  active: Boolean
  id: ID!
}

input FBCatalogSyncUpdateInput {
  sell: Boolean
  googleCategory: Boolean
  fbCategory: Boolean
  sale: Boolean
  attributes: FBCatalogSyncAttributesInput
  shipping: FBCatalogSyncShippingInput
  id: ID!
}

input FBCatalogSyncAttributesInput {
  active: Boolean
  color: Boolean
  gender: Boolean
  size: Boolean
  ageGroup: Boolean
  material: Boolean
  pattern: Boolean
}

input FBCatalogSyncShippingInput {
  active: Boolean
  country: ID
  service: String
  price: String
}

input PluginInput {
  name: String!
  description: String
  code: String
  cost: String
  url: String
  info: String
  category: String
  pictures: PluginPicturesInput
  icon: String
  recommended: Boolean
}

input PluginPicturesInput {
  square: PictureInput
  wide: PictureInput
}

input TargetPluginInput {
  plugin: ID!
  target: TargetACIInput!
}

input TargetPluginUpdateInput {
  plugin: ID
  target: TargetACIInput
  id: ID!
}

input FigamyIntegrationUpdateInput {
  authentication: FigamyIntegrationAuthenticationInput
  wallet: FigamyIntegrationWalletInput
  catalog: FigamyIntegrationCatalogInput
  deals: FigamyIntegrationDealsInput
  converter: FigamyIntegratioConverterInput
  marketplace: FigamyIntegratioMarketplaceInput
  id: ID!
}

input FigamyIntegrationAuthenticationInput {
  active: Boolean
  appAuth: FigamyIntegrationAuthInput
  figamyAuth: FigamyIntegrationAuthInput
  login: FigamyIntegrationAuthenticationLoginInput
}

input FigamyIntegrationAuthInput {
  publicKey: String
  secretKey: String
}

input FigamyIntegrationAuthenticationLoginInput {
  active: Boolean
}

input FigamyIntegrationWalletInput {
  active: Boolean!
  quantitative: FigamyIntegrationAuthenticationLoginInput
  qualitative: FigamyIntegrationAuthenticationLoginInput
  reputation: FigamyIntegrationWalletReputationInput
}

input FigamyIntegrationWalletReputationInput {
  active: Boolean!
  inactivityCycle: Boolean!
  lossAmount: Boolean!
  perks: Boolean!
}

input FigamyIntegrationCatalogInput {
  active: Boolean!
  auth: FigamyIntegrationAuthInput
  syncTime: RecurrenceType
  sell: Boolean!
  sale: Boolean!
  shipping: Boolean!
}

input FigamyIntegrationDealsInput {
  active: Boolean!
  monthlyAmount: String
  selfManaging: Boolean!
}

input FigamyIntegratioConverterInput {
  active: Boolean!
  rate: String
}

input FigamyIntegratioMarketplaceInput {
  active: Boolean
  paymentCycle: RecurrenceType
  comission: String
}

input ErpIntegrationUpdateInput {
  target: TargetACIInput
  url: String
  username: String
  password: String
  recurrence: ErpIntegrationCycleEnum
  vendor: ErpVendorEnum
  active: Boolean
  id: ID!
}

input WidgetIntegrationInput {
  theme: String
  picture: PictureInput
  icon: String
  active: Boolean
  content: WidgetIntegrationContentInput
  target: TargetACIInput
}

input WidgetIntegrationContentInput {
  profile: Boolean
  notification: Boolean
  quantitative: Boolean
  qualitative: Boolean
  chat: Boolean
  campaigns: Boolean
  pages: [LandingPageTypeEnum!]
}

input WidgetIntegrationActionsInput {
  definition: ID
  recurrence: QuestActionsRecurrenceInput
  remuneration: [RemunerationInput!]
}

input CountryInput {
  name: String!
  code: String
  dialCode: String
  flagSquare: PictureInput
  flagWide: PictureInput
  iconFlag: String
}

input CurrencyInput {
  name: String!
  code: String
  symbol: String
  flagSquare: PictureInput
  flagWide: PictureInput
  iconFlag: String
}

input StateInput {
  name: String!
  code: String
  created: DateTime!
  surface: String!
  dialCode: String
  flagSquare: PictureInput
  flagWide: PictureInput
  country: ID
}

input LanguageInput {
  name: String!
  code: String
  flagSquare: PictureInput
  flagWide: PictureInput
  iconFlag: String
}

input SocialInput {
  name: String!
  code: String
  fontIcon: String
  images: [SocialImagesInput!]
}

input SocialImagesInput {
  style: SocialImageStyleEnum!
  images: [SocialImagesImagesInput!]
}

input SocialImagesImagesInput {
  svg: SocialImagesImagesSetInput
  png: SocialImagesImagesSetInput
}

input SocialImagesImagesSetInput {
  size48: PictureInput
  size96: PictureInput
  size144: PictureInput
  size240: PictureInput
  size480: PictureInput
}

input PaymentInput {
  name: String!
  code: String
  paymentType: PaymentTypeEnum
  materialIcon: String
  images: PaymentImagesInput
}

input PaymentImagesInput {
  svg: PaymentImagesSvgInput
  png: PaymentImagesPngInput
}

input PaymentImagesSvgInput {
  alt: PictureInput
  card_flat: PictureInput
  dark: PictureInput
  flat: PictureInput
  light: PictureInput
  default: PictureInput
}

input PaymentImagesPngInput {
  alt: PictureInput
  alt2x: PictureInput
  alt_128: PictureInput
  alt_256: PictureInput
  alt_512: PictureInput
  card_flat: PictureInput
  card_flat2x: PictureInput
  card_flat_128: PictureInput
  card_flat_256: PictureInput
  card_flat_512: PictureInput
  dark: PictureInput
  dark2x: PictureInput
  dark_128: PictureInput
  dark_256: PictureInput
  dark_512: PictureInput
  flat: PictureInput
  flat2x: PictureInput
  flat_128: PictureInput
  flat_256: PictureInput
  flat_512: PictureInput
  light: PictureInput
  light2x: PictureInput
  light_128: PictureInput
  light_256: PictureInput
  light_512: PictureInput
  default: PictureInput
  default2x: PictureInput
  default_128: PictureInput
  default_256: PictureInput
  default_512: PictureInput
}

input BrowserInput {
  name: String
  tags: [String!]
  code: String!
  logo: BrowserLogoInput
}

input TechDeviceInput {
  name: String
  tags: [String!]
  code: String
  picture: PictureInput
  releasedat: String
  body: String
  os: String
  storage: String
  displaySize: String
  displayResolution: String
  cameraPixels: String
  videoPixels: String
  ram: String
  chipset: String
  batterySize: String
  batteryType: String
  specifications: TechDeviceSpecsInput
  brand: ID
}

input TechDeviceSpecsInput {
  technology: String
  band2g: String
  gprs: String
  edge: String
  announced: String
  status: String
  dimensions: String
  weight: String
  sim: String
  type: String
  size: String
  resolution: String
  cardSlot: String
  phonebook: String
  callRecords: String
  loudspeaker: String
  alertTypes: String
  jack35mm: String
  wlan: String
  bluetooth: String
  gps: String
  radio: String
  usb: String
  sensors: String
  messaging: String
  browser: String
  clock: String
  alarm: String
  games: String
  languages: String
  java: String
  colors: String
}

input TechDeviceBrandInput {
  name: String!
  code: String
  tags: [String!]
  logo: DeviceBrandLogoInput
}

input DeviceBrandLogoInput {
  svg: PictureInput
  png: DeviceBrandLogoPngInput
  icon: String
}

input DeviceBrandLogoPngInput {
  default: PictureInput
  size16: PictureInput
  size24: PictureInput
  size32: PictureInput
  size48: PictureInput
  size64: PictureInput
  size128: PictureInput
  size256: PictureInput
  size512: PictureInput
}

input TechDeviceTypeInput {
  name: String
  tags: [String!]
  nodeName: String
  code: String
  pictureSquare: PictureInput
  pictureWide: PictureInput
  icon: String
}

input OperatingSystemInput {
  name: String!
  code: String
  tags: [String!]
  slug: String
  logo: OSLogoInput
}

input OSLogoInput {
  svg: PictureInput
  png: OSLogoPngInput
  icon: String
}

input OSLogoPngInput {
  default: PictureInput
  size16: PictureInput
  size24: PictureInput
  size32: PictureInput
  size48: PictureInput
  size64: PictureInput
  size128: PictureInput
}

input CorporateTemplateInput {
  name: CorporateTemplateTypeEnum!
  content: String!
  target: TargetACIInput!
}

input QuotationInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  customer: SaleCustomerInput!
  conversion: QuotationConversionInput
}

input KeyValueInput {
  key: String
  value: String
}

input InvoicingProductsBundleInput {
  product: InvoicingProductsInput
  text: String
  value: String
  rank: Int!
  kind: ProductKindEnum!
}

input InvoicingAddressInput {
  billing: FullAddressInput
  shipping: FullAddressInput
}

input taxRankInput {
  tax: ID!
  rank: Int!
}

input TotalPriceInput {
  net: String
  gross: String
}

input SaleCustomerInput {
  customer: ID!
  details: [KeyValueInput!]
}

input QuotationConversionInput {
  order: ID
  deliveryNote: ID
  invoice: ID
}

input QuotationUpdateInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput
  company: ID
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  customer: SaleCustomerInput
  conversion: QuotationConversionInput
  id: ID!
}

input SaleOrderInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  customer: SaleCustomerInput!
  conversion: SaleOrderConversionInput
  origin: SaleOrderOriginInput
}

input SaleOrderConversionInput {
  deliveryNote: ID
  invoice: ID
}

input SaleOrderOriginInput {
  quotation: ID
}

input SaleIssueNoteInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  customer: SaleCustomerInput!
}

input SaleInvoiceInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  customer: SaleCustomerInput!
  origin: SaleInvoiceOriginInput
}

input SaleInvoiceOriginInput {
  quotation: ID
  order: ID
}

input SaleAvoirInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  customer: SaleCustomerInput!
  origin: SaleInvoiceOriginInput
  avoir: ID!
}

input SaleDeliveryNoteInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  customer: SaleCustomerInput!
  origin: SaleDeliveryNoteOriginInput
  warehouse: ID!
}

input SaleDeliveryNoteOriginInput {
  quotation: ID
  order: ID
}

input PurchaseOrderInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  supplier: PurchaseSupplierInput
  conversion: PurchaseOrderConversionInput
  origin: PurchaseOrderOriginInput
}

input PurchaseSupplierInput {
  supplier: ID
  details: [KeyValueInput!]
}

input PurchaseOrderConversionInput {
  deliveryNote: ID
  invoice: ID
}

input PurchaseOrderOriginInput {
  quotation: ID
}

input PurchaseInvoiceInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  supplier: PurchaseSupplierInput
  origin: PurchaseInvoiceOriginInput
}

input PurchaseInvoiceOriginInput {
  quotation: ID
  order: ID
}

input PurchaseDeliveryNoteInput {
  number: String
  date: DateTime
  note: String
  details: [KeyValueInput!]
  products: [InvoicingProductsBundleInput!]!
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressInput
  taxes: [taxRankInput!]
  installments: [InstallmentInput!]
  discount: DiscountDtoInput
  logistic: ID
  project: ID
  target: TargetACIInput!
  company: ID!
  totalPrice: TotalPriceInput
  toPay: String
  totalTax: String
  totalReductions: String
  bank: ID
  supplier: PurchaseSupplierInput
  origin: PurchaseDeliveryNoteOriginInput
  warehouse: ID
}

input PurchaseDeliveryNoteOriginInput {
  quotation: ID
  order: ID
}

input LogisticInput {
  company: ID
  driver: ID
  tracker: [LogisticTrackerInput!]
  warehouse: ID
}

input LogisticTrackerInput {
  status: LogisticStatus
  date: DateTime!
}

input RentalUpdateInput {
  location: String
  description: String
  status: RentalStatusEnum
  start: DateTime
  end: DateTime
  note: RentalNoteInput
}

input CompanyContactInput {
  firstName: String
  lastName: String
  email: String
  phone: IPhoneInput
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  lastContacted: DateTime
  leadScore: String
  media: MediaInput
  tags: [String!]
  externalId: String
  company: ID
  address: FullAddressInput
}

input CompanyContactUpdateInput {
  firstName: String
  lastName: String
  email: String
  phone: IPhoneInput
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  lastContacted: DateTime
  leadScore: String
  media: MediaInput
  tags: [String!]
  externalId: String
  address: FullAddressInput
}

input CompanySettingsInput {
  sale: CompanySettingsSaleInput
  purchase: CompanySettingsPurchaseInput
  tickets: CompanySettingsTicketsInput
  logistic: CompanySettingsTicketsInput
  company: ID!
}

input CompanySettingsSaleInput {
  quotation: CompanySettingsSaleQuotationInput
  order: CompanySettingsSaleQuotationInput
  invoice: CompanySettingsSaleQuotationInput
  deliveryNote: CompanySettingsSaleQuotationInput
  issueNote: CompanySettingsSaleQuotationInput
}

input CompanySettingsSaleQuotationInput {
  reference: DocumentReferenceModelEnum
  label: String
  prefix: String
  validity: CompanySettingsSaleQuotationValidityInput
  color: String
  note: String
}

input CompanySettingsSaleQuotationValidityInput {
  period: String
  cycle: String
}

input CompanySettingsPurchaseInput {
  inventory: CompanySettingsPurchaseNoteInput
  order: CompanySettingsPurchaseNoteInput
  invoice: CompanySettingsPurchaseNoteInput
  deliveryNote: CompanySettingsPurchaseNoteInput
}

input CompanySettingsPurchaseNoteInput {
  reference: DocumentReferenceModelEnum
  prefix: String
  note: String
}

input CompanySettingsTicketsInput {
  prefix: String
}

input CompanySettingsUpdateInput {
  sale: CompanySettingsSaleInput
  purchase: CompanySettingsPurchaseInput
  tickets: CompanySettingsTicketsInput
  logistic: CompanySettingsTicketsInput
}

input DocumentInput {
  name: String!
  content: DocumentContentInput
  size: Float
  owner: ID
}

input DocumentContentInput {
  type: ID
  base64: String
}

input ContentTypeInput {
  name: String!
  type: String
  image: ContentTypeImageInput
}

input ContentTypeImageInput {
  background: ContentTypeImageFormatInput
  black: ContentTypeImageFormatInput
  white: ContentTypeImageFormatInput
  icon: String
}

input ContentTypeImageFormatInput {
  png: PictureInput
  svg: PictureInput
}

input GlobalProviderCategoryInput {
  identifier: Int!
  name: String!
  provider: GlobalCategoryProviderEnum
}

input GmailDraftInput {
  id: String
  message: GmailMessageInput
}

input GmailLabelInput {
  id: String
  name: String
  messageListVisibility: MessageListVisibilityEnum
  labelListVisibility: LabelListVisibilityEnum
  type: GoogleTypeEnum
  messagesTotal: Int
  messagesUnread: Int
  threadsTotal: Int
  threadsUnread: Int
}

enum GoogleTypeEnum {
  system
  user
}

input GmailInsertMessageInput {
  internalDateSource: InternalDateSourceEnum
  deleted: Boolean
}

input GmailModifyMessageInput {
  addLabelIds: [String!]
  removeLabelIds: [String!]
}

input InsertCalendarListInput {
  id: String!
  backgroundColor: String
  colorId: String
  defaultReminders: [InsertCalendarDefaultReminderInput!]
  foregroundColor: String
  hidden: Boolean
  notificationSettings: InsertCalendarNotificationSettingsNotifInput
}

input InsertCalendarDefaultReminderInput {
  method: String!
  minutes: Int
}

input InsertCalendarNotificationSettingsNotifInput {
  notifications: [InsertCalendarNotificationSettingsInput!]!
}

input InsertCalendarNotificationSettingsInput {
  method: String!
  type: String!
}

input InsertCalendarListExtendInput {
  id: String!
  backgroundColor: String
  colorId: String
  defaultReminders: [InsertCalendarDefaultReminderInput!]
  foregroundColor: String
  hidden: Boolean
  notificationSettings: InsertCalendarNotificationSettingsNotifInput
  selected: Boolean
  summaryOverride: String
}

input InsertGoogleCalendarInput {
  summary: String
  description: String
  location: String
  timeZone: String
  kind: String!
  etag: String
  id: String
  conferenceProperties: GoogleCalendarConferencePropertiesInput
}

input GoogleCalendarConferencePropertiesInput {
  allowedConferenceSolutionTypes: [String!]!
}

input UpdateGoogleCalendarInput {
  summary: String
  description: String
  location: String
  timeZone: String
}

input GoogleCalendarPatchEventInput {
  alwaysIncludeEmail: Boolean
  conferenceDataVersion: Int
  maxAttendees: Int
  sendNotifications: Boolean
  sendUpdates: String
  supportsAttachments: Boolean
}

type Subscription {
  listenForUserAuthentication: UserAuthenticationType!
  listenForCorporateUserStatusChanged(target: TargetACIInput!): UserStatsType!
  listenForUserStatusChanged: UserType!
  listenForUserCreated: UserType!
  listenForNewMessage(userId: ID!): MessageType!
  listenForMessageGroupUpdated(userId: ID!): MessageGroupType!
  listenForPartnershipReferral: PartnerReferralType!
  listenForCompanyCreated: CompanyType!
  listenForLoyaltyProgramCreated: LoyaltyProgramType!
  listenForManufacturerCreated: ManufacturerType!
  pointOfSaleCreated: PointOfSaleType!
  listenForPOSCategoryCreated: POSCategoryType!
  listenForWholesalerCreated: WholesalerType!
  listenForBrandCreated: BrandType!
  listenForProductCreated: ProductType!
  listenForFollowersCreated(code: String!): FollowerType!
  listenForRequest: RequestType!
  listenForBookingCreated(posId: String!): BookingType!
  listenForBookingConfirmed(userId: String!): BookingType!
  listenForBookingCancelled(userId: String, posId: String): BookingType!
  listenForNewAdhocNotification: NotificationFullType!
  listenForSendAdhocNotificationTest(
    userId: String!
  ): AdhocNotificationTestType!
  listenForNewAdhocCorporateNotification(
    userId: ID!
  ): CorporateNotificationFullType!
  listenForSendAdhocCorporateNotificationTest(
    userId: ID!
  ): AdhocCorporateNotificationTestType!
  listenForSubscriptionRequest(target: TargetACIInput!): SubscribersFullType!
  listenForSubscriptionReply(userId: String!): SubscribersFullType!
  listenForQuestActivityStarted(targets: TargetsInput!): QuestActivityType!
  listenForQuestActionDefinitionStarted(
    targets: TargetsInput!
  ): QuestActionDefinitionType!
  listenForQuestTypeStarted(targets: TargetsInput!): QuestTypeType!
  listenForOnsiteConverterPushed(userId: String!): PushAmountResponseType!
  listenForAudienceStarted(targets: TargetsInput!): AudienceType!
  listenForAudienceCriteriaStarted(
    targets: TargetsInput!
  ): AudienceCriteriaType!
  listenForMarketPlaceOrderCreated(posId: ID!): MarketPlaceOrderDtoType!
  listenForDeliveryMarketPlaceOrderCreated(posId: ID!): MarketPlaceOrderDtoType!
  listenForUpdateProductMarketPlaceOrderStatus(
    deliveryManId: ID
    userId: ID
    posId: ID
  ): MarketPlaceOrderDtoType!
  listenForUpdateProductPaymentStatus(userId: ID!): MarketPlaceOrderDtoType!
}
